<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="初读 Pro Git"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content="pro-git-the-book,git"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"%E5%88%9D%E8%AF%BB-Pro-Git","permalink":"https://hxhue.github.io/pro-git-the-book/%E5%88%9D%E8%AF%BB-Pro-Git/","title":"初读 Pro Git","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>初读 Pro Git - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#git-基础>git 基础</a></li><li><a href=#git-add>git add</a></li><li><a href=#git-status>git status</a></li><li><a href=#git-rm>git rm</a></li><li><a href=#git-log>git log</a></li><li><a href=#git-tag>git tag</a></li><li><a href=#git-checkoutbranch>git checkout/branch</a></li><li><a href=#三种-track-远程分支的方式>三种 track 远程分支的方式</a></li><li><a href=#git-rebase>git rebase</a></li><li><a href=#git-on-the-server>git on the server</a><ul><li><a href=#四种传输协议>四种传输协议</a></li><li><a href=#bare-repository>Bare Repository</a></li><li><a href=#ssh-和-git-shell>ssh 和 git-shell</a></li><li><a href=#其他搭建方式>其他搭建方式</a></li></ul></li><li><a href=#distributed-git>Distributed Git</a><ul><li><a href=#workflow>Workflow</a></li><li><a href=#检查改动是否有格式问题>检查改动是否有格式问题</a></li><li><a href=#5072-规则>50/72 规则</a></li><li><a href=#workflow-private-small-team>Workflow: private small team</a></li><li><a href=#workflow-private-managed-team>Workflow: private managed team</a></li><li><a href=#使用邮件工作diff-和-patch>使用邮件工作：diff 和 patch</a></li><li><a href=#两点式和三点式的-commit-range>两点式和三点式的 commit range</a></li><li><a href=#在-git-中包含密钥>在 git 中包含密钥</a></li><li><a href=#为-commit-创建可读的名称>为 commit 创建可读的名称</a></li><li><a href=#创建-archive>创建 archive</a></li><li><a href=#shortlog>Shortlog</a></li></ul></li><li><a href=#github>Github</a></li><li><a href=#git-tools>Git Tools</a><ul><li><a href=#git-reflog>git reflog</a><ul><li><a href=#escaping-braces-in-powershell>Escaping braces in PowerShell</a></li></ul></li><li><a href=#commit>{commit}^</a></li><li><a href=#commit-表示法>Commit 表示法</a></li><li><a href=#git-add--i>git add -i</a></li><li><a href=#git-stash>git stash</a></li><li><a href=#git-clean>git clean</a></li><li><a href=#gpg-签名>gpg 签名</a></li><li><a href=#git-grep>git grep</a></li><li><a href=#git-commit---amend>git commit &ndash;amend</a></li><li><a href=#git-rebase--i>git rebase -i</a><ul><li><a href=#git-rebase--i-的-edit-选项>git rebase -i 的 edit 选项</a></li><li><a href=#git-rebase-发生冲突怎么办>git rebase 发生冲突怎么办</a></li></ul></li><li><a href=#git-reset>git reset</a><ul><li><a href=#只-reset-部分文件>只 reset 部分文件</a></li><li><a href=#用-reset-来做-squashing>用 reset 来做 squashing</a></li></ul></li><li><a href=#git-checkout>git checkout</a></li><li><a href=#git-merge>git merge</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/pro-git-the-book/%E5%88%9D%E8%AF%BB-Pro-Git/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="初读 Pro Git"><meta itemprop=description content="一些需要弄明白的名词：commit range/refspec。
git 基础

git 的管理方式是记录每个文件的快照。








然后分成三个区：








git add

如果一个文件改动了多个地方，但是只想要提交其中的部分行，可以用 git add --patch。这样 git 会启动一个交互式的程序，并询问用户每个 chunk 是否要加入。这种交互式环境提供多种操作，其中 e 操作允许用户使用编辑器精准编辑要添加的修改。"></span><header class=post-header><h1 class=post-title itemprop="name headline">初读 Pro Git</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-11-16 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-11-16 00:00:00 +0800 CST">2023-11-16
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-04-26T00:00:00+08:00 itemprop=dateModified datetime=2025-04-26T00:00:00+08:00>2025-04-26</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/pro-git-the-book itemprop=url rel=index><span itemprop=name>pro-git-the-book</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>8455</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>17分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><p>一些需要弄明白的名词：commit range/refspec。</p><h1 id=git-基础>git 基础
<a class=header-anchor href=#git-%e5%9f%ba%e7%a1%80></a></h1><p>git 的管理方式是记录每个文件的快照。</p><p><img src=/assets/85fc388c6e2e33f14af4af02b672389b.webp></p><p>然后分成三个区：</p><p><img src=/assets/0a706ecf17b1dad0bff56e9c61c58c73.webp></p><h1 id=git-add>git add
<a class=header-anchor href=#git-add></a></h1><p>如果一个文件改动了多个地方，但是只想要提交其中的部分行，可以用 <code>git add --patch</code>。这样 git 会启动一个交互式的程序，并询问用户每个 chunk 是否要加入。这种交互式环境提供多种操作，其中 <code>e</code> 操作允许用户使用编辑器精准编辑要添加的修改。</p><h1 id=git-status>git status
<a class=header-anchor href=#git-status></a></h1><p><code>git status</code> 可以显示当前工作区的状态。添加 <code>-s</code> 选项，即 <code>git status -s</code>，可以显示更简单（摘要）的状态（很像 VS Code 边栏上的信息）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git status -s
</span></span><span style=display:flex><span>?? .cache/
</span></span><span style=display:flex><span>?? .clang-tidy
</span></span><span style=display:flex><span>?? utils/clang-tidy.py
</span></span></code></pre></div><p>输出的有些文件签名是双问号，表示 untracked。</p><h1 id=git-rm>git rm
<a class=header-anchor href=#git-rm></a></h1><p><strong>关于 <code>git rm --cached</code> 和 <code>git restore --staged</code> 的区别</strong>（<a href=https://stackoverflow.com/a/65434709/ title=https://stackoverflow.com/a/65434709/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://stackoverflow.com/a/65434709/<i class="fa fa-external-link-alt"></i></a>）：</p><blockquote><p><code>git rm --cached file</code>: removes the copy of the file from the index / staging-area, without touching the working tree copy. The proposed next commit now lacks the file. If the current commit has the file, and you do in fact make a next commit at this point, the difference between the previous commit and the new commit is that the file is gone.</p><p><code>git restore --staged file</code>: Git copies the file from the HEAD commit into the index, without touching the working tree copy. The index copy and the HEAD copy now match, whether or not they matched before. A new commit made now will have the same copy of the file as the current commit.</p><p>If the current commit lacks the file, this has the effect of removing the file from the index. So in this case it does the same thing as <code>git rm --cached</code>.</p><p><code>git reset file</code>: this copies the HEAD version of the file to the index, just like <code>git restore --staged file</code>.</p></blockquote><p>注意转义星号（git 本身和部分 shell 会解释星号），比如<code>git rm log/\*.log</code>。</p><h1 id=git-log>git log
<a class=header-anchor href=#git-log></a></h1><p><code>git log -p -2</code>（也可以写成 <code>--patch</code>）能够在显示日志的时候同时显示改动的内容（相当于同时做了 diff），然后 <code>-2</code> 限制了只显示最开头的两个 commits（这个选项和 <code>-p</code> 是正交的）。</p><p><code>git log --stat</code> 会在 log 中显示每个 commit 的 summary。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#719e07>=</span>oneline
</span></span><span style=display:flex><span>ca82a6dff817ec66f44342007202690a93763949 Change version number
</span></span><span style=display:flex><span>085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Remove unnecessary <span style=color:#b58900>test</span>
</span></span><span style=display:flex><span>a11bef06a3f659402fe7563abf99ad00de2209e6 Initial commit
</span></span></code></pre></div><p><code>--pretty=oneline</code> 会显示完整的 hash，而 <code>--oneline</code> 只显示前 7 个字符（<code>--pretty=oneline --abbrev-commit</code>）。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#719e07>=</span>format:<span style=color:#2aa198>&#34;%h - %an, %ar : %s&#34;</span>
</span></span><span style=display:flex><span>ca82a6d - Scott Chacon, <span style=color:#2aa198>6</span> years ago : Change version number
</span></span><span style=display:flex><span>085bb3b - Scott Chacon, <span style=color:#2aa198>6</span> years ago : Remove unnecessary <span style=color:#b58900>test</span>
</span></span><span style=display:flex><span>a11bef0 - Scott Chacon, <span style=color:#2aa198>6</span> years ago : Initial commit
</span></span></code></pre></div><p><code>-S</code> 表示搜索，这会过滤整个仓库的 commits（如果仓库很大可能有点慢）并显示所有让给定的字符串的出现次数改变的 commits。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log -S narrow_cast
</span></span><span style=display:flex><span>commit 287fd454cdaca7bf65b0be8e91c730ebeb6bdecd <span style=color:#719e07>(</span>HEAD -&gt; types, origin/xx/types<span style=color:#719e07>)</span>
</span></span><span style=display:flex><span>Author: AA BB &lt;user@email.com&gt;
</span></span><span style=display:flex><span>Date:   Thu Nov <span style=color:#2aa198>16</span> 21:28:44 <span style=color:#2aa198>2023</span> +0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    feat: narrow_cast and sign_cast
</span></span></code></pre></div><p>显示让特定文件改变的那些提交：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git log -- path/to/file
</span></span></code></pre></div><p>显示特定 commit 的日志（而不是 HEAD）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git log master
</span></span></code></pre></div><h1 id=git-tag>git tag
<a class=header-anchor href=#git-tag></a></h1><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag
</span></span><span style=display:flex><span>v1.0
</span></span><span style=display:flex><span>v2.0
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag -l <span style=color:#2aa198>&#34;v1.8.5*&#34;</span>
</span></span><span style=display:flex><span>v1.8.5
</span></span><span style=display:flex><span>v1.8.5-rc0
</span></span><span style=display:flex><span>v1.8.5-rc1
</span></span><span style=display:flex><span>v1.8.5-rc2
</span></span><span style=display:flex><span>v1.8.5-rc3
</span></span></code></pre></div><p><mark>git 支持两种 tag：lightweight 和 annotated</mark>。创建有注释的 tag 可以用于发布，这些信息会详细地存储在 repo 中：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git tag -a v1.4 -m <span style=color:#2aa198>&#34;my version 1.4&#34;</span>
</span></span></code></pre></div><p><code>-m</code> 和 <code>git commit</code> 的 <code>-m</code> 选项类似，如果不给就会弹出默认的编辑器。</p><p>如果不加 <code>-a</code> 选项，就会创建一个简单的 tag，就像一个不用更新的 branch 一样。这样的 tag 适合临时使用。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag v1.4-lw
</span></span><span style=display:flex><span>$ git show v1.4-lw
</span></span><span style=display:flex><span>commit ca82a6dff817ec66f44342007202690a93763949
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date: Mon Mar <span style=color:#2aa198>17</span> 21:52:11 <span style=color:#2aa198>2008</span> -0700
</span></span><span style=display:flex><span>Change version number
</span></span></code></pre></div><p>给除了 HEAD 以外的 commit 加 tag 的例子（需要多加一个参数）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git tag -a v1.2 9fceb02
</span></span></code></pre></div><blockquote><p>By default, the git push command doesn&rsquo;t transfer tags to remote servers.</p></blockquote><p><code>git push origin &lt;tagname></code> 能够把本地的 tag 推送到远程主机。
<code>git push origin --tags</code> 会将本地的所有 tags（包括 lightweight 和 annotated）推送的远程主机。
<code>git push origin --follow-tags</code> 会将本地的所有 annotated tags 推送的远程主机。</p><div class="markdown-alert markdown-alert-note"><p class=markdown-alert-title><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>Note</p><p>在我阅读 Pro Git 这本书的时候，还没有只推送 lightweight tags 的选项。</p></div><p>删除一个本地的 tag：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git tag -d v1.4-lw
</span></span></code></pre></div><p>删除一个远程的 tag：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git push origin :refs/tags/v1.4-lw
</span></span></code></pre></div><p>也可以用 <code>git push origin --delete &lt;tagname></code> 达到同样的效果。</p><h1 id=git-checkoutbranch>git checkout/branch
<a class=header-anchor href=#git-checkoutbranch></a></h1><p><code>git checkout -b newBranch &lt;commit></code> 可以从给定的 commit 分叉出一个新分支。这里的 commit 还可以用 branch 或者 tag。这样就不必先 checkout 到给定的分支再创建新的了（两步合成一步）。</p><p>git 的有向无环图结构存储的是 parent 指针（可能有多个），而不是 children 指针。每个分支、tag 都包含了这样的指针。</p><p><strong>创建新的分支但是不 checkout</strong>：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git branch testing
</span></span></code></pre></div><p><img src=/assets/9118957388d1d527952877a83ebd98bd.webp></p><p><code>git log --decorate</code> 会在日志中展示每个 commit 和哪些分支关联，相当于 <code>git log --decorate=short</code>。旧 git 不会自动 decorate，而新版已经默认开启了 <code>--decorate=auto</code>。</p><p>创建并转移到新的分支：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout -b branchA
</span></span><span style=display:flex><span><span style=color:#586e75># or</span>
</span></span><span style=display:flex><span>git switch -c branchA
</span></span><span style=display:flex><span><span style=color:#586e75># -c is the same as --create</span>
</span></span></code></pre></div><p>git 的 hash 全长是 40 个字符，但是简写是 7 个字符。在 unmerged files 里面留的标记也是连续 7 个 <code>&lt;</code>、<code>=</code>、<code>></code>。</p><p><code>git branch -v</code> 能显示分支和各分支最近一次的提交。<code>git branch -vv</code> 会比 <code>-v</code> 多显示本地分支和远程分支的 track 关系：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch -vv
</span></span><span style=display:flex><span>iss53 7e424c3 <span style=color:#719e07>[</span>origin/iss53: ahead 2<span style=color:#719e07>]</span> Add forgotten brackets
</span></span><span style=display:flex><span>master 1ae2a45 <span style=color:#719e07>[</span>origin/master<span style=color:#719e07>]</span> Deploy index fix
</span></span><span style=display:flex><span>- serverfix f8674d9 <span style=color:#719e07>[</span>teamone/server-fix-good: ahead 3, behind 1<span style=color:#719e07>]</span> This should <span style=color:#719e07>do</span> it
</span></span><span style=display:flex><span>testing 5ea463a Try something new
</span></span></code></pre></div><blockquote><p>The useful <code>--merged</code> and <code>--no-merged</code> options can filter this list to branches that you have or have not
yet merged into the branch you&rsquo;re currently on.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git branch         <span style=color:#586e75># 显示本地分支</span>
</span></span><span style=display:flex><span>git branch -r      <span style=color:#586e75># 显示远程分支</span>
</span></span><span style=display:flex><span>git branch --all   <span style=color:#586e75># 显示本地和远程分支</span>
</span></span></code></pre></div><p>在克隆的时候可以指定远程主机的命名（否则是 origin），比如<code>git clone -o booyah</code></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git push origin serverfix
</span></span><span style=display:flex><span>Counting objects: 24, <span style=color:#719e07>done</span>.
</span></span><span style=display:flex><span>Delta compression using up to <span style=color:#2aa198>8</span> threads.
</span></span><span style=display:flex><span>Compressing objects: 100% <span style=color:#719e07>(</span>15/15<span style=color:#719e07>)</span>, <span style=color:#719e07>done</span>.
</span></span><span style=display:flex><span>Writing objects: 100% <span style=color:#719e07>(</span>24/24<span style=color:#719e07>)</span>, 1.91 KiB | <span style=color:#2aa198>0</span> bytes/s, <span style=color:#719e07>done</span>.
</span></span><span style=display:flex><span>Total <span style=color:#2aa198>24</span> <span style=color:#719e07>(</span>delta 2<span style=color:#719e07>)</span>, reused <span style=color:#2aa198>0</span> <span style=color:#719e07>(</span>delta 0<span style=color:#719e07>)</span>
</span></span><span style=display:flex><span>To https://github.com/schacon/simplegit
</span></span><span style=display:flex><span>- <span style=color:#719e07>[</span>new branch<span style=color:#719e07>]</span> serverfix -&gt; serverfix
</span></span></code></pre></div><blockquote><p>Git automatically expands the serverfix branch name out to <code>refs/heads/serverfix:refs/heads/serverfix</code>.</p></blockquote><h1 id=三种-track-远程分支的方式>三种 track 远程分支的方式
<a class=header-anchor href=#%e4%b8%89%e7%a7%8d-track-%e8%bf%9c%e7%a8%8b%e5%88%86%e6%94%af%e7%9a%84%e6%96%b9%e5%bc%8f></a></h1><p>从给定的分支 checkout 出新分支：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout -b sf origin/serverfix
</span></span><span style=display:flex><span>Branch sf <span style=color:#b58900>set</span> up to track remote branch serverfix from origin.
</span></span><span style=display:flex><span>Switched to a new branch <span style=color:#2aa198>&#39;sf&#39;</span>
</span></span></code></pre></div><p><mark>同时，由于 checkout 到的新分支是基于远程分支的，会自动 track！</mark></p><p><strong>track 一个远程分支</strong>的另外一种写法（本地的分支名也是 <code>serverfix</code>）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout --track origin/serverfix
</span></span></code></pre></div><p>这条命令并<strong>不是让当前分支</strong>去 track 远程分支，<strong>而是创建一个同名分支并 track 远程分支</strong>。相当于 <code>git checkout -b severfix origin/serverfix</code>。</p><p>如果 checkout 的分支不存在，而且又恰好有对应的远程分支，可以不加选项地使用 checkout：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout serverfix
</span></span><span style=display:flex><span>Branch serverfix <span style=color:#b58900>set</span> up to track remote branch serverfix from origin.
</span></span><span style=display:flex><span>Switched to a new branch <span style=color:#2aa198>&#39;serverfix&#39;</span>
</span></span></code></pre></div><p>要让当前分支去 track 给定的远程分支，可以用 <code>git branch -u</code>：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch -u origin/serverfix
</span></span><span style=display:flex><span>Branch serverfix <span style=color:#b58900>set</span> up to track remote branch serverfix from origin.
</span></span></code></pre></div><p>如果本地分支 track 了远程分支，用 <code>@{u}</code> 或者 <code>@{upstream}</code> 可以代表对应的远程分支。这样在 <code>git merge</code> 等场景会比较方便。</p><h1 id=git-rebase>git rebase
<a class=header-anchor href=#git-rebase></a></h1><p><strong>git rebase</strong> 可以用来将分支上的 commits 线性添加到另外一个分支上。</p><p><img src=/assets/930e59e6da017d48c685aa0adad7c504.webp></p><p>在这个例子中，如果想要让 client 的改动放到 master 上，但是不想要 server 的改动也就是 C3 也移动过去，就需要用到 rebase。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase --onto master server client
</span></span><span style=display:flex><span><span style=color:#586e75># 同 git rebase --onto master &#34;$(git merge-base server client)&#34; client</span>
</span></span></code></pre></div><p>上面的命令指定要前往的新分支是 master。而从 server 到 client 是要挑选的 commits 范围。git rebase 会从考虑两个分支的祖先（不包含）到第二个分支（包含）之间的改动。</p><h1 id=git-on-the-server>git on the server
<a class=header-anchor href=#git-on-the-server></a></h1><h2 id=四种传输协议>四种传输协议
<a class=header-anchor href=#%e5%9b%9b%e7%a7%8d%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae></a></h2><p>git 支持四种协议：local/http/ssh/git。</p><p>local 可以是 file:// 开头的 url，也可以是本地路径。前者会使用本地网络拷贝，速度较慢。后者会使用硬链接或者直接拷贝文件，速度快但是不如前者干净（比如刚从 svn 转移过来时有不少冗余分支）。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>/tmp/git-remote $ git remote add origin /root/proj/.git
</span></span><span style=display:flex><span>/tmp/git-remote $ git fetch origin
</span></span><span style=display:flex><span>remote: Enumerating objects: 15548, <span style=color:#719e07>done</span>.
</span></span><span style=display:flex><span>remote: Counting objects: 100% <span style=color:#719e07>(</span>15548/15548<span style=color:#719e07>)</span>, <span style=color:#719e07>done</span>.
</span></span><span style=display:flex><span>remote: Compressing objects: 100% <span style=color:#719e07>(</span>5231/5231<span style=color:#719e07>)</span>, <span style=color:#719e07>done</span>.
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>本地协议的终点必须是一个 bare repository，也就是 .git 文件夹，而不包含工作区文件。事实上，远程仓库没有工作区，因为没有人会在远程仓库直接工作。</p><p><strong>用 NFS 搭建的远程访问上的 file:// 协议往往速度比 ssh 要慢</strong>。所以除非是可以本地访问（一台大服务器上的多个 docker 容器使用了路径映射），但不建议这种方式。（放在同一台服务器上也不安全吧？）</p><p>git 用的 http 协议分成 smart http 和 dumb http。前者（现在一般使用的是这个）通过 http 协议支持各种功能，后者只能作为一个简单的 http 服务器 serve 裸仓库。裸仓库克隆之后不会自动设置一些信息，比如 objects/info/packs 和 info/refs。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ <span style=color:#b58900>cd</span> /var/www/htdocs/
</span></span><span style=display:flex><span>$ git clone --bare /path/to/git_project gitproject.git
</span></span><span style=display:flex><span>$ <span style=color:#b58900>cd</span> gitproject.git
</span></span><span style=display:flex><span>$ mv hooks/post-update.sample hooks/post-update
</span></span><span style=display:flex><span>$ chmod a+x hooks/post-update
</span></span></code></pre></div><p>ssh 协议可以不用加 ssh:// 前缀（也可以加）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git clone user@git.example.com:/srv/git/my_project.git
</span></span></code></pre></div><blockquote><p>Finally, we have the Git protocol. This is a special daemon that comes packaged with Git; it listens on a dedicated port (9418) that provides a service similar to the SSH protocol, but with absolutely no authentication or cryptography.</p></blockquote><p>git 协议还需要创建 git-daemon-export-ok 文件。git 协议是所有人都有权限，不需要认证，所以一般大家只开放 pull 而不开放 push。git 协议是所有协议中最快的，它使用了和 ssh 相同的数据传输协议，但是没有加密传输的开销。另一方面，由于 git 协议不加密，所以 pull 下来的代码可能是不安全的（比如中间人攻击插入恶意代码）。而 https 和 ssh 都是有加密的。</p><p>git 协议需要自己的 daemon，所以搭建起来也不是很容易。</p><h2 id=bare-repository>Bare Repository
<a class=header-anchor href=#bare-repository></a></h2><p>在 git init 和 git clone 的时候都能指定 <code>--bare</code> 选项表示裸仓库。</p><blockquote><p>Git will automatically add group write permissions to a repository properly if you run the git init command with the &ndash;shared option.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>ssh user@git.example.com
</span></span><span style=display:flex><span><span style=color:#b58900>cd</span> /srv/git/my_project.git
</span></span><span style=display:flex><span>git init --bare --shared
</span></span></code></pre></div><p>在书里的例子中，/srv/git/my_project.git 本来就是一个裸仓库，所以第三句的含义是将裸仓库初始化成共享仓库。也就是让仓库目录的归属组都有写权限，否则只有仓库目录的归属用户有写权限。（在个人电脑上，归属组和归属用户可能是重名的。）</p><p>裸仓库是直接将正常仓库中的 .git 里的内容写到给定的路径里的，没有 working tree。</p><h2 id=ssh-和-git-shell>ssh 和 git-shell
<a class=header-anchor href=#ssh-%e5%92%8c-git-shell></a></h2><p>如果安装了 git-shell，可以创建一个名为 git 的用户（只是建议，git 不是特殊的名字）然后改变其登陆 shell：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>sudo chsh git -s <span style=color:#719e07>$(</span>which git-shell<span style=color:#719e07>)</span>
</span></span></code></pre></div><p>用户直接登陆通过 ssh 协议 serve 有仓库的服务器时使用 git-shell 的好处是管理者可以给 git-shell 加一些限制规则，从而限制用户可以执行的命令。（现在不会有人用这个吧？）</p><h2 id=其他搭建方式>其他搭建方式
<a class=header-anchor href=#%e5%85%b6%e4%bb%96%e6%90%ad%e5%bb%ba%e6%96%b9%e5%bc%8f></a></h2><p>Git daemon/http/GitWeb/Gitlab 等，略。</p><p>书中讲的 gitlab 不是搭建 gitlab 容器，而是将项目上传到 gitlab 上，讲的比较浅不用看。</p><h1 id=distributed-git>Distributed Git
<a class=header-anchor href=#distributed-git></a></h1><h2 id=workflow>Workflow
<a class=header-anchor href=#workflow></a></h2><p>这里讲了两种：</p><p><img src=/assets/7aa01e45eb251c0bff343cc4b1c6c0bd.webp></p><p><img src=/assets/95cb17c66224099f960a03b94600674a.webp>（仁慈的独裁者）</p><h2 id=检查改动是否有格式问题>检查改动是否有格式问题
<a class=header-anchor href=#%e6%a3%80%e6%9f%a5%e6%94%b9%e5%8a%a8%e6%98%af%e5%90%a6%e6%9c%89%e6%a0%bc%e5%bc%8f%e9%97%ae%e9%a2%98></a></h2><p><code>git diff --check</code> 能够检查此次改动中：</p><ol><li>空白字符相关的格式问题：文件每一行的末尾是否有多余的空白字符、文件的末尾是否有两个空行（只有一个空行是可以的）等。</li><li>是否有 conflict markers（合并或 rebase 还没有处理完成）。</li></ol><p><strong>在提交前可以跑一下 git diff &ndash;cached &ndash;check</strong>。</p><h2 id=5072-规则>50/72 规则
<a class=header-anchor href=#5072-%e8%a7%84%e5%88%99></a></h2><p>git commit 信息中标题建议不要超过 50 个字符，正文信息每行不要超过 72 字符。</p><h2 id=workflow-private-small-team>Workflow: private small team
<a class=header-anchor href=#workflow-private-small-team></a></h2><p><img src=/assets/4b20ee0963f5ed0eac88a3bd38609e41.webp></p><p>假设想要看看 origin/master 比本地的 issue54 多了哪些修改：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --no-merges issue54..origin/master
</span></span><span style=display:flex><span>commit 738ee872852dfaa9d6634e0dea7a324040193016
</span></span><span style=display:flex><span>Author: John Smith &lt;jsmith@example.com&gt;
</span></span><span style=display:flex><span>Date: Fri May <span style=color:#2aa198>29</span> 16:01:27 <span style=color:#2aa198>2009</span> -0700
</span></span><span style=display:flex><span>Remove invalid default value
</span></span></code></pre></div><p>其中 <code>--no-merges</code> 选项表示不显示 merge 结点（也就是 parents 数量超过 1 个的结点），在这里是 origin/master 本身。只是由于用户在运行其他命令之前看不到读者在书中相应位置能看到的图，所以不知道远程到底有没有 merge 结点（毕竟如果知道则可以根据图手动把这个 commit 划入范围之外）。</p><blockquote><p>The <strong>issue54..origin/master</strong> syntax is a log filter that asks Git to display only those commits that are <strong>on the latter branch (in this case origin/master) and that are not on the first branch</strong>.</p></blockquote><h2 id=workflow-private-managed-team>Workflow: private managed team
<a class=header-anchor href=#workflow-private-managed-team></a></h2><p>除非要删除开发分支，最好不要在合并的时候 squash。因为 squash 合并后只有一个 parent，开发者之后的改动又会需要 rebase！</p><p><code>git merge --no-commit</code> 是指不要创建描述本次合并的 merge commit 结点，但是仍然可能 fast-forward。<code>git merge --no-commit --no-ff</code> 还会禁用 fast-forward。这两个选项都打开就能达到检查合并结果，但是暂不合并的效果。（比如想要测试是否能够成功合并，或者想在合并之前检查一下合并结果再 commit。）</p><h2 id=使用邮件工作diff-和-patch>使用邮件工作：diff 和 patch
<a class=header-anchor href=#%e4%bd%bf%e7%94%a8%e9%82%ae%e4%bb%b6%e5%b7%a5%e4%bd%9cdiff-%e5%92%8c-patch></a></h2><p><code>diff</code> 和 <code>patch</code> 两个命令本身就在 Linux 中存在（前者生成 patch，后者应用 patch）。但如果可能，使用 <code>git format-patch</code> 和 <code>git am</code>，而不是直接使用这两个命令。</p><p><code>git format-patch</code> 可以生成 patches。</p><blockquote><p>不要用 <code>git diff master</code> 来生成 patch，因为 <code>git diff master</code> 只是简单比较文件的变化情况，如果你的 master 分支并不是 topic 分支的 parent（在 branch 之后已经向前移动了），那么 diff 中会出现有删有增的变化！这个时候应该用 commit range 的两点表示法，否则 patch 之后 master 的新改动会丢失。</p></blockquote><p><code>git apply</code> 可以应用一般的 diff，但是和 patch 命令相比具有原子性，要么全部成功，要么全部失败。<code>git apply --check</code> 可以用来检查本次 apply 是否能够成功，但是不会真的 apply。</p><p><code>git am</code> 是对 <code>git apply</code> 的包装，能够对 mbox 格式的文件处理。mbox 是一系列 diff 文件拼接到一起作为邮件正文传输的一种格式。</p><h2 id=两点式和三点式的-commit-range>两点式和三点式的 commit range
<a class=header-anchor href=#%e4%b8%a4%e7%82%b9%e5%bc%8f%e5%92%8c%e4%b8%89%e7%82%b9%e5%bc%8f%e7%9a%84-commit-range></a></h2><p>注意！<strong>不适用于 git diff</strong>！更多见
<a href=/pro-git-the-book/%E5%88%9D%E8%AF%BB-Pro-Git/#commit-%e8%a1%a8%e7%a4%ba%e6%b3%95 title="Commit 表示法">Commit 表示法</a>。</p><p><img src=/assets/1b8a90f1b0ad703c7bae42b5b3621b56.webp> 三点式：出现在 A 但不出现于 B，或者相反。</p><p><img src=/assets/43f771beda5ee65164d1626f8e982450.webp> 两点式：出现在 B 中，但不出现在 A 中。</p><p><code>git log contrib --not master</code> 和 <code>git log master..contrib</code> 效果是一样的。</p><h2 id=在-git-中包含密钥>在 git 中包含密钥
<a class=header-anchor href=#%e5%9c%a8-git-%e4%b8%ad%e5%8c%85%e5%90%ab%e5%af%86%e9%92%a5></a></h2><p>可能现在不会用到了。这种导入密钥的方式只会在 git 仓库的 objects 中包含一个文件，并不会让文件出现在工作区。</p><p>导出密钥，并将密钥写入到仓库的 objects 中。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ gpg -a --export F721C45A | git hash-object -w --stdin
</span></span><span style=display:flex><span>659ef797d181633c87ec71ac3f9ba29fe5775b92
</span></span></code></pre></div><p>然后给 objects 一个 tag，防止 gc 的时候丢失（同时也能方便查找）。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92
</span></span></code></pre></div><p>给完 tag 之后后续别人可以通过 tag 找到 hash，然后找到文件并导入：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git show maintainer-pgp-pub | gpg --import
</span></span></code></pre></div><p>举个例子，我现在在 darknet 的仓库中（手头有个仓库，顺便打开了）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git ls-tree master
</span></span><span style=display:flex><span><span style=color:#2aa198>100644</span> blob bea19ff44fcb77ccca5448e730bd154327088a30    .gitignore
</span></span><span style=display:flex><span><span style=color:#2aa198>100644</span> blob a50f7d700ba02bfacd50f59b315311cf4d0bbda2    LICENSE
</span></span><span style=display:flex><span><span style=color:#2aa198>100644</span> blob 8b1a9d8189b3b9f4479221d52882ce36fdc73a62    LICENSE.fuck
</span></span><span style=display:flex><span><span style=color:#2aa198>100644</span> blob c54113271e15057c4def6676693eb96fd6362b28    LICENSE.gen
</span></span><span style=display:flex><span><span style=color:#2aa198>100644</span> blob 9cecc1d4669ee8af2ca727a5d8cde10cd8b2d7cc    LICENSE.gpl
</span></span><span style=display:flex><span><span style=color:#2aa198>100644</span> blob 6728bd28d319c68ae04944fb034118dcc4c9aa09    LICENSE.meta
</span></span><span style=display:flex><span><span style=color:#2aa198>100644</span> blob 5bd806ce16ea5053c8631793787362439375026e    LICENSE.mit
</span></span><span style=display:flex><span><span style=color:#2aa198>100644</span> blob 5b8709acc43e7b76ed69758a52a9eaffaba775e6    LICENSE.v1
</span></span><span style=display:flex><span><span style=color:#2aa198>100644</span> blob 63e15e657fa3e47455598beaf8f27df4386f5a9e    Makefile
</span></span><span style=display:flex><span><span style=color:#2aa198>100644</span> blob fb58c2640038a963cd573d121e4fab59399f67dc    README.md
</span></span><span style=display:flex><span><span style=color:#2aa198>040000</span> tree b789d4e25fb76862394c3805d2a529d49c353ae9    cfg
</span></span><span style=display:flex><span><span style=color:#2aa198>040000</span> tree 7751b6063e5b86ef67fd155b2d4496c5c85d4516    data
</span></span><span style=display:flex><span><span style=color:#2aa198>040000</span> tree da080efd69a73cdfd765b1785e0df5fcee769a52    examples
</span></span><span style=display:flex><span><span style=color:#2aa198>040000</span> tree 87a27ca1a74b281df2301d41b7a5b359c5322335    include
</span></span><span style=display:flex><span><span style=color:#2aa198>040000</span> tree 5cf5ca862a8e43ac9276a84c7187680d32754aa0    python
</span></span><span style=display:flex><span><span style=color:#2aa198>040000</span> tree f5c65d4da6faf9f382a28a7f766d1c2247453150    scripts
</span></span><span style=display:flex><span><span style=color:#2aa198>040000</span> tree e4da33bf1850bf3c6eab30232e299acddf672b62    src
</span></span></code></pre></div><p>使用 <code>git show {hash}</code>，如果 hash 对应某个 blob，将直接展示快照的内容。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show a50f7d700ba02bfacd50f59b315311cf4d0bbda2
</span></span><span style=display:flex><span>                                  YOLO LICENSE
</span></span><span style=display:flex><span>                             Version 2, July <span style=color:#2aa198>29</span> <span style=color:#2aa198>2016</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>THIS SOFTWARE LICENSE IS PROVIDED <span style=color:#2aa198>&#34;ALL CAPS&#34;</span> SO THAT YOU KNOW IT IS SUPER
</span></span><span style=display:flex><span>SERIOUS AND YOU DON<span style=color:#2aa198>&#39;T MESS AROUND WITH COPYRIGHT LAW BECAUSE YOU WILL GET IN
</span></span></span><span style=display:flex><span><span style=color:#2aa198>TROUBLE HERE ARE SOME OTHER BUZZWORDS COMMONLY IN THESE THINGS WARRANTIES
</span></span></span><span style=display:flex><span><span style=color:#2aa198>LIABILITY CONTRACT TORT LIABLE CLAIMS RESTRICTION MERCHANTABILITY. NOW HERE&#39;</span>S
</span></span><span style=display:flex><span>THE REAL LICENSE:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0. Darknet is public domain.
</span></span><span style=display:flex><span>1. Do whatever you want with it.
</span></span><span style=display:flex><span>2. Stop emailing me about it!
</span></span></code></pre></div><p>如果 hash 对应一个 tree，会列举文件夹：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show 7751b6063e5b86ef67fd155b2d4496c5c85d4516
</span></span><span style=display:flex><span>tree 7751b6063e5b86ef67fd155b2d4496c5c85d4516
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>9k.labels
</span></span><span style=display:flex><span>9k.names
</span></span><span style=display:flex><span>9k.tree
</span></span><span style=display:flex><span>coco.names
</span></span><span style=display:flex><span>coco9k.map
</span></span><span style=display:flex><span>dog.jpg
</span></span><span style=display:flex><span>eagle.jpg
</span></span><span style=display:flex><span>giraffe.jpg
</span></span><span style=display:flex><span>goal.txt
</span></span><span style=display:flex><span>horses.jpg
</span></span><span style=display:flex><span>imagenet.labels.list
</span></span><span style=display:flex><span>imagenet.shortnames.list
</span></span><span style=display:flex><span>inet9k.map
</span></span><span style=display:flex><span>kite.jpg
</span></span><span style=display:flex><span>labels/
</span></span><span style=display:flex><span>openimages.names
</span></span><span style=display:flex><span>person.jpg
</span></span><span style=display:flex><span>scream.jpg
</span></span><span style=display:flex><span>voc.names
</span></span></code></pre></div><p>如果 hash 对应一个 commit，对显示 commit 的日志。</p><h2 id=为-commit-创建可读的名称>为 commit 创建可读的名称
<a class=header-anchor href=#%e4%b8%ba-commit-%e5%88%9b%e5%bb%ba%e5%8f%af%e8%af%bb%e7%9a%84%e5%90%8d%e7%a7%b0></a></h2><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git describe master
</span></span><span style=display:flex><span>v1.6.2-rc1-20-g8c5b85c
</span></span><span style=display:flex><span><span style=color:#586e75>########## ^^  ^^^^^^^</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#      /    |     \</span>
</span></span><span style=display:flex><span><span style=color:#586e75># last tag  |   partial sha1</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#           |</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#   commits since the tag</span>
</span></span></code></pre></div><blockquote><p>In response, Git generates a string consisting of the name of the most recent tag earlier than that commit, followed by the number of commits since that tag, followed finally by a partial SHA-1 value of the commit being described (prefixed with the letter &ldquo;g&rdquo; meaning Git).</p></blockquote><p>但是必须得让 git 先找到对应分支上最近的 tag，才能用 describe。也就是说无 tag 的时候是不能 describe 的，会报错。</p><p>默认情况下，git describe 描述的 tags 的只能是 annotated tags。可以加 &ndash;tags 来描述无注释的 tags。</p><h2 id=创建-archive>创建 archive
<a class=header-anchor href=#%e5%88%9b%e5%bb%ba-archive></a></h2><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git archive master --prefix<span style=color:#719e07>=</span><span style=color:#2aa198>&#39;project/&#39;</span> --format<span style=color:#719e07>=</span>zip &gt; <span style=color:#586e75>`</span>git describe master<span style=color:#586e75>`</span>.zip
</span></span></code></pre></div><p>如果没有 <code>--format</code> 选项，则会采用 tar.gz。</p><h2 id=shortlog>Shortlog
<a class=header-anchor href=#shortlog></a></h2><p><code>git shortlog</code> 能够展示选定范围内的所有改动，而且是按<strong>作者</strong>分组的，概览起来比较方便。主要用途是阅读一段时间内不同人员对仓库做出的贡献。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git shortlog --no-merges master --not v1.0.1
</span></span><span style=display:flex><span>Chris Wanstrath <span style=color:#719e07>(</span>6<span style=color:#719e07>)</span>:
</span></span><span style=display:flex><span>    Add support <span style=color:#719e07>for</span> annotated tags to Grit::Tag
</span></span><span style=display:flex><span>    Add packed-refs annotated tag support.
</span></span><span style=display:flex><span>    Add Grit::Commit#to_patch
</span></span><span style=display:flex><span>    Update version and History.txt
</span></span><span style=display:flex><span>    Remove stray <span style=color:#586e75>`</span>puts<span style=color:#586e75>`</span>
</span></span><span style=display:flex><span>    Make ls_tree ignore nils
</span></span><span style=display:flex><span>Tom Preston-Werner <span style=color:#719e07>(</span>4<span style=color:#719e07>)</span>:
</span></span><span style=display:flex><span>    fix dates in <span style=color:#b58900>history</span>
</span></span><span style=display:flex><span>    dynamic version method
</span></span><span style=display:flex><span>    Version bump to 1.0.2
</span></span><span style=display:flex><span>    Regenerated gemspec <span style=color:#719e07>for</span> version 1.0.2
</span></span></code></pre></div><h1 id=github>Github
<a class=header-anchor href=#github></a></h1><p>这一章基本可以跳过，但是还是有一些新的知识点。</p><p><code>git diff --word-diff</code> 可以用来按照词显示差异。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>$ git diff --word-diff
</span></span><span style=display:flex><span>diff --git a/blink.ino b/blink.ino
</span></span><span style=display:flex><span>index 15b9911..a6cc5a5 100644
</span></span><span style=display:flex><span>--- a/blink.ino
</span></span><span style=display:flex><span>+++ b/blink.ino
</span></span><span style=display:flex><span>@@ -18,7 +18,7 @@ void setup() {
</span></span><span style=display:flex><span>// the loop routine runs over and over again forever:
</span></span><span style=display:flex><span>void loop() {
</span></span><span style=display:flex><span>digitalWrite(led, HIGH); // turn the LED on (HIGH is the voltage level)
</span></span><span style=display:flex><span>[-delay(1000);-]{+delay(3000);+} // wait for a second
</span></span><span style=display:flex><span>digitalWrite(led, LOW); // turn the LED off by making the voltage LOW
</span></span><span style=display:flex><span>[-delay(1000);-]{+delay(3000);+} // wait for a second
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是 Gitlab-flavored markdown 支持的。Github 可能也支持？</p><blockquote><p>The other interesting URLs are the .diff and .patch URLs, which as you may guess, provide unified
diff and patch versions of the Pull Request. You could technically merge in the Pull Request work
with something like this:</p></blockquote><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ curl https://github.com/tonychacon/fade/pull/1.patch | git am
</span></span></code></pre></div><p>这样能够直接从 gitlab 的 url 上面下载新的东西 patch 并应用。gitlab 也支持。</p><p>在 merge-request 或者 pull 页面加上后缀：</p><ul><li><code>.diff</code> 后缀：相当于运行 git diff，改动按照文件分类。</li><li><code>.patch</code> 后缀：相当于运行 git format-patch，改动先按照 commit 分类再按照文件分类。</li></ul><p>另一方面，在原来使用主机的地方，可以直接使用 url，主要是用于临时下载（不想要保存主机再删除的情况）。</p><h1 id=git-tools>Git Tools
<a class=header-anchor href=#git-tools></a></h1><h2 id=git-reflog>git reflog
<a class=header-anchor href=#git-reflog></a></h2><p>git reflog 能够显示过去一段时间对 HEAD 的操作信息，记录了当前的分支是怎么改动的。比如什么时候发生了 reset 或者 checkout。<strong>reflog 信息是完全本地的</strong>。</p><blockquote><p>Think of the reflog as Git&rsquo;s version of shell history.</p></blockquote><p><img src=/assets/5ebfa85039debd727416a3c7fb920a56.webp></p><p>这些信息对于最终的代码没用，但是对于工作可能很有帮助。比如先查到 <code>git reflog</code> 信息之后可以这样指代一个 commit：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git show HEAD@<span style=color:#719e07>{</span>5<span style=color:#719e07>}</span>
</span></span><span style=display:flex><span><span style=color:#586e75># or</span>
</span></span><span style=display:flex><span>git show master@<span style=color:#719e07>{</span>yesterday<span style=color:#719e07>}</span>
</span></span><span style=display:flex><span><span style=color:#586e75># or</span>
</span></span><span style=display:flex><span>git show HEAD@<span style=color:#719e07>{</span>2.months.ago<span style=color:#719e07>}</span>
</span></span></code></pre></div><p>使用 <code>git log -g</code> 可以在 log 中显示 reflog 信息。</p><h3 id=escaping-braces-in-powershell>Escaping braces in PowerShell
<a class=header-anchor href=#escaping-braces-in-powershell></a></h3><p>When using PowerShell, braces like { and } are special characters and must be escaped. You can escape them with a backtick <kbd>`</kbd> or put the commit reference in quotes:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show HEAD@<span style=color:#719e07>{</span>0<span style=color:#719e07>}</span>   <span style=color:#586e75># will NOT work</span>
</span></span><span style=display:flex><span>$ git show HEAD@<span style=color:#586e75>`</span><span style=color:#719e07>{</span>0<span style=color:#586e75>`</span><span style=color:#719e07>}</span> <span style=color:#586e75># OK</span>
</span></span><span style=display:flex><span>$ git show <span style=color:#2aa198>&#34;HEAD@{0}&#34;</span> <span style=color:#586e75># OK</span>
</span></span></code></pre></div><p>这也是为什么我不喜欢 PowerShell。</p><h2 id=commit>{commit}^
<a class=header-anchor href=#commit></a></h2><p>^ 表示 parent。注意 Windows 的 cmd 上要用 ^^，因为 cmd 对 ^ 有转义。</p><p>见
<a href=/posts/systems/Windows/Windows-cmd-%E8%BD%AC%E4%B9%89/ title="Windows cmd 转义">Windows cmd 转义</a>。</p><h2 id=commit-表示法>Commit 表示法
<a class=header-anchor href=#commit-%e8%a1%a8%e7%a4%ba%e6%b3%95></a></h2><blockquote><p>You can get the same results as in the previous example by typing <code>git log origin/master..</code> — Git substitutes HEAD if one side is missing.</p></blockquote><p>如果 range 的一端被省略，则 git 会用 HEAD 代替。</p><p>也可以多点表示。以下三种写法含义相同：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log refA..refB
</span></span><span style=display:flex><span>$ git log ^refA refB
</span></span><span style=display:flex><span>$ git log refB --not refA
</span></span></code></pre></div><p>其中 <code>^refA</code> 就表示 <code>--not refA</code>。这种写法比起 两点和三点表示法 可以支持更多的分支。比如：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log refA refB ^refC
</span></span><span style=display:flex><span>$ git log refA refB --not refC
</span></span></code></pre></div><p><strong>注意！这不适用于 git diff！git diff 仅能比较两个提交</strong>，而且有历史性的、不满足 commit 表示法的实现需要兼容。</p><ol><li>如果包含 <code>--not</code> 或 <code>^</code>，先转换成两点表示法，再进行下一步。</li><li>如果是两点表示法，去掉 <code>..</code> 相当于直接比较两个端点（endpoint）。</li><li>如果是三点表示法，则先找到两个端点的 merge-base，再比较 merge-base 和第二个端点。</li></ol><blockquote><p><code>git diff [&lt;options>] &lt;commit>..&lt;commit> [--] [&lt;path>…​]</code>
This is synonymous to the earlier form (without the <code>..</code>) for viewing the changes between two arbitrary <code>&lt;commit></code>. If <code>&lt;commit></code> on one side is omitted, it will have the same effect as using HEAD instead.</p><p><code>git diff [&lt;options>] &lt;commit>...&lt;commit> [--] [&lt;path>…​]</code>
This form is to view the changes on the branch containing and up to the second <code>&lt;commit></code>, starting at a common ancestor of both <code>&lt;commit></code>. <code>git diff A...B</code> is equivalent to <code>git diff $(git merge-base A B) B</code>. You can omit any one of <code>&lt;commit></code>, which has the same effect as using HEAD instead.</p></blockquote><p><strong>因为历史遗留问题，看上去 git diff 的两点表示法和三点表示法和其他命令是相反的！</strong></p><p><code>git log</code> 使用三点表示法（被给定的某一个分支包含，却不是同时包含的那些 commits）的时候还可以加上 <strong>&ndash;left-right</strong> 参数：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --left-right master...experiment
</span></span><span style=display:flex><span>&lt; F
</span></span><span style=display:flex><span>&lt; E
</span></span><span style=display:flex><span>&gt; D
</span></span><span style=display:flex><span>&gt; C
</span></span></code></pre></div><p>这样能看到 commit 是来自左边还是右边。</p><h2 id=git-add--i>git add -i
<a class=header-anchor href=#git-add--i></a></h2><p><img src=/assets/4fdd0766f10c7df60530856e566bd4fe.webp>
一些命令：</p><ul><li>revert 可以撤掉对一个文件的更新，相当于 <code>git restore --staged -- {file}</code>。</li><li>update 可以整体添加文件。</li><li>patch 可以添加文件的一个部分。在 patch 模式中使用 e 选项可以编辑 chunk，但只是会修改要暂存的内容（index），这里编辑的内容并不会影响工作区。从 <code>git add -p</code> 也可以直接进入这一步。</li></ul><p>其他说明：</p><ul><li><code>git reset</code>、<code>git stash save</code> 和 <code>git checkout</code> 也都能加 <code>-p</code> 选项！</li><li>git stash save（deprecated）现在被 git stash push 替代。</li><li>VS Code 也有按照选区添加内容的方式。</li></ul><h2 id=git-stash>git stash
<a class=header-anchor href=#git-stash></a></h2><p>git stash list 之后选择要应用的 stash：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git stash apply stash@<span style=color:#719e07>{</span>2<span style=color:#719e07>}</span>
</span></span></code></pre></div><p>这个格式是不是很熟悉？这是 reflog 的格式，这也同样表明 git stash 的内容是完全本地，不会被提交到远程仓库的！git stash 内容如果丢失将无法恢复。</p><p>在 stash 的时候忽略 index 区：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git stash --keep-index
</span></span><span style=display:flex><span>Saved working directory and index state WIP on master: 1b65b17 added the index file
</span></span><span style=display:flex><span>HEAD is now at 1b65b17 added the index file
</span></span></code></pre></div><p>Stash 未追踪的内容可以用 <code>--include-untracked</code> or <code>-u</code>，但是这不会 stash 写在 .gitignore 中的内容。使用 <code>--all</code> 或者 <code>-a</code> 能将 .gitignore 中的内容也 stash。</p><p><code>git stash --patch</code>：将部分文件内容加入 stash。</p><p><code>git stash branch &lt;new branchname></code>：创建 stash，<code>checkout -b</code> 到新分支，再 apply stash。在工作区产生了别的改动内容时有用。</p><h2 id=git-clean>git clean
<a class=header-anchor href=#git-clean></a></h2><p><code>git clean</code> 用来移除 untracked 文件。（<strong>作为对比，<code>git reset</code> 是重置 tracked 文件</strong>。）</p><p>如果不放心，可以先 <code>--dry-run</code> 或者 <code>-n</code> 一下。</p><p>一些选项：-f 强制删除，-ff 在强制删除不可行的时候强调强制删除。-i 交互式删除，-d 删除文件夹（否则会忽略文件夹），-x 忽略 .gitignore 文件。</p><p><code>git clean</code> 相对来说不是很安全，也可以考虑 git stash -a 作为替代。</p><h2 id=gpg-签名>gpg 签名
<a class=header-anchor href=#gpg-%e7%ad%be%e5%90%8d></a></h2><p>可以用 gpg 签名一个 tag 或者 commit，这样其他人就能验证提交者的身份。在 git 配置文件中设置 <code>commit.gpgsign</code> 为 true 会默认启用签名。</p><p><em>其他的包括创建密钥、导出、验证、在 tag 或 commit 的时候签名的内容就此省略</em>。</p><h2 id=git-grep>git grep
<a class=header-anchor href=#git-grep></a></h2><p><code>git grep</code> 只会搜 git 知道的文件，所以速度比 grep 更快（前提是你要找的内容就在 git 中）！</p><p>默认搜索范围是整个工作区。</p><p><code>-n</code> 或者 <code>--line-number</code> 可以让输出结果附加行号（默认的输出只有文件名和内容行）。</p><p><em>感觉和可视化界面相比不是很好用。</em></p><p><code>git log -S</code> 搜索字符串变化情况。</p><p><strong><code>git log -L</code> 可以搜索行历史。-L argument 可以是 &lsquo;start,end:file&rsquo; or &lsquo;:funcname:file&rsquo;</strong>。搜索 funcname 可能搜索不到，比如 python 文件中类的成员函数。也可以用正则表达式指定函数的开始和结束，比如：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>git log -L <span style=color:#2aa198>&#39;/unsigned long git_deflate_bound/&#39;</span>,/^<span style=color:#719e07>}</span>/:zlib.c
</span></span></code></pre></div><p>这样就能搜到：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>@@ -81,0 +85,5 @@
</span></span><span style=display:flex><span>+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)
</span></span><span style=display:flex><span>+{
</span></span><span style=display:flex><span>+ return deflateBound(strm, size);
</span></span><span style=display:flex><span>+}
</span></span><span style=display:flex><span>+
</span></span></code></pre></div><h2 id=git-commit---amend>git commit &ndash;amend
<a class=header-anchor href=#git-commit---amend></a></h2><p>如果不需要为 <code>git commit --amend</code> 提供信息，可以用 <code>git commit --amend --no-edit</code>。</p><h2 id=git-rebase--i>git rebase -i
<a class=header-anchor href=#git-rebase--i></a></h2><p>可以 squash commits、修改 commits 的提交信息、交换 commits 的顺序、将一个 commit 分裂成多个。</p><h3 id=git-rebase--i-的-edit-选项>git rebase -i 的 edit 选项
<a class=header-anchor href=#git-rebase--i-%e7%9a%84-edit-%e9%80%89%e9%a1%b9></a></h3><p>其中 edit 选项能够编辑过去的一个 commit（可以 reword、选择提交的文件、分多次提交等等）。怎么做呢？</p><p>给某个 commit 选择 edit，git-rebase 就会在这个地方停下来。我们可以按照自己的意愿进行提交，然后使用 <code>git rebase --continue</code> 让 git 继续 rebase。后续的 commits 就像用 cherrypick 选出来的一样（正如 cherrypick，被编辑的 commit 之后的所有 commit 的 hash 都会变）。</p><p>如果这个时候直接使用 <code>git rebase --continue</code>，那就相当于没有编辑这个 commit。如果想要编辑则需要先 reset：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git reset HEAD^
</span></span><span style=display:flex><span>$ git add README
</span></span><span style=display:flex><span>$ git commit -m <span style=color:#2aa198>&#39;Update README formatting&#39;</span>
</span></span><span style=display:flex><span>$ git add lib/simplegit.rb
</span></span><span style=display:flex><span>$ git commit -m <span style=color:#2aa198>&#39;Add blame&#39;</span>
</span></span><span style=display:flex><span>$ git rebase --continue
</span></span></code></pre></div><p>这样这条 commit 就变成了两条。在使用 <code>git rebase --continue</code> 之后，后面的命令会接上来。</p><p><strong>用 git rebase &ndash;abort 可以取消之前的 rebase</strong>。</p><p>fixup 功能: 当你发现了之前 commit 的一个小错误，想要将小错误修补回去时，可以先将这个小错误的修复提交，然后用 rebase -i 来重组提交。将该修复移动到之前提交的下方，然后选择 fixup。</p><p>也有更方便的方式（主要是难记）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ git add <span style=color:#719e07>{</span>filename...<span style=color:#719e07>}</span>                 <span style=color:#586e75># Stage a fix</span>
</span></span><span style=display:flex><span>$ git commit --fixup<span style=color:#719e07>=</span>a0b1c2d3           <span style=color:#586e75># Perform the commit to fix broken a0b1c2d3</span>
</span></span><span style=display:flex><span>$ git rebase -i --autosquash a0b1c2d3~1 <span style=color:#586e75># Now merge fixup commit into broken commit</span>
</span></span></code></pre></div><p>fixup 和 squash 很像，但是不会弹出编辑器要求你提供 commit message。</p><p><code>git commit --fixup</code> 的作用是让这次的提交信息变成 &ldquo;fixup! " 加上要 fixup 的那条 commit 的日志，这样使用 <code>git rebase -i --autosquash</code> 的时候工具就能把它放在一个正确的位置，理论上比手动编辑 commit 更方便。然而，你需要知道要 fixup 的 commit，也就是说要粘贴两次（commit 一次，rebase 一次），而且 <code>--autosquash</code> 这个选项还挺长的。感觉还是 vim dd + p 比较方便。</p><h3 id=git-rebase-发生冲突怎么办>git rebase 发生冲突怎么办
<a class=header-anchor href=#git-rebase-%e5%8f%91%e7%94%9f%e5%86%b2%e7%aa%81%e6%80%8e%e4%b9%88%e5%8a%9e></a></h3><blockquote><p>The first is how you complete the conflict resolution. Rather than <code>git commit</code> like you&rsquo;ll use when addressing conflicts that arise from <code>git merge</code>, the appropriate command for rebasing is <code>git rebase --continue</code>.</p></blockquote><p>同样会在文件中留下 markers，解决冲突之后要用 git rebase &ndash;continue 而不是 git merge。</p><blockquote><p>If you want to take a look at the diff of the commit that Git failed to replay, and which resulted in a merge conflict, you can use <code>git rebase --show-current-patch</code>, or its equivalent <code>git show REBASE_HEAD</code>.</p></blockquote><blockquote><p>Finally, it&rsquo;s worth noting that when using <code>git checkout --ours</code> or <code>--theirs</code> to quickly resolve conflicted paths by checking out a specific version from the index, the meaning of those options is reversed compared to a regular <code>git merge</code> merge conflict: during rebase, <code>--theirs</code> refers to the changes from the branch being rebased (<code>REBASE_HEAD</code>), and <code>--ours</code> refers to the changes from the branch onto which we are rebasing (<code>HEAD</code>). <a href=https://git-rebase.io/#note-6 title=https://git-rebase.io/#note-6 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://git-rebase.io/#note-6<i class="fa fa-external-link-alt"></i></a></p></blockquote><h2 id=git-reset>git reset
<a class=header-anchor href=#git-reset></a></h2><blockquote><p>The reset command overwrites these three trees in a specific order, stopping when you tell it to:</p><ol><li>Move the branch HEAD points to (stop here if <code>--soft</code>).</li><li>Make the index look like HEAD (stop here unless <code>--hard</code>).</li><li>Make the working directory look like the index.</li></ol></blockquote><h3 id=只-reset-部分文件>只 reset 部分文件
<a class=header-anchor href=#%e5%8f%aa-reset-%e9%83%a8%e5%88%86%e6%96%87%e4%bb%b6></a></h3><p><code>git reset file.txt</code> 相当于 <code>git reset --mixed HEAD file.txt</code>。由于 HEAD 只是一个指针，不能同时指向不同的地方，git reset 文件的时候是不会移动 HEAD 的。那这一步的效果就是从 HEAD 中取出文件快照还原到 index 区，相当于 <code>git restore --staged file.txt</code>。</p><p>只 reset 部分文件的时候，好像只能是 &ndash;mixed 模式。</p><h3 id=用-reset-来做-squashing>用 reset 来做 squashing
<a class=header-anchor href=#%e7%94%a8-reset-%e6%9d%a5%e5%81%9a-squashing></a></h3><p>首先是 git reset &ndash;soft {commit} 定位到之前的位置，然后直接 git commit。因为 git reset &ndash;soft {commit} 不会改动 index 和工作区！</p><h2 id=git-checkout>git checkout
<a class=header-anchor href=#git-checkout></a></h2><p><code>git checkout {commit}</code> 表面上有点像 <code>git reset --hard {commit}</code>，但是：</p><ol><li>git checkout 在修改文件之前会做检查，只会将未修改过的文件更新。</li><li><strong>git checkout 只会简单修改 HEAD，因而能在不同的分支之间跳转。git reset &ndash;hard 会把当前分支的 HEAD 改成给定的 commit 并移动过去！</strong></li></ol><p><code>git checkout -- {files...}</code> 相当于 <code>git reset -- {files...}</code>（只修改 index）之后又将相关文件在 index 的内容复制到工作区。</p><p>要找只修改工作区文件而不修改 index 的单个命令就只有 <code>git restore</code> 能做到。</p><h2 id=git-merge>git merge
<a class=header-anchor href=#git-merge></a></h2><p>git merge 可以使用 <code>-Xignore-all-space</code> 或者 <code>-Xignore-space-change</code> 参数。后者将多个空白字符视作一个，但是将有空白字符和无空白字符视作差异。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/pro-git-the-book>pro-git-the-book
</a><a href=/tags/git>git</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/pro-git-the-book/7.9-Git-Tools-Rerere/ rel=next title="7.9 Git Tools - Rerere"><i class="fa fa-chevron-left"></i> 7.9 Git Tools - Rerere</a></div><div class="post-nav-prev post-nav-item"></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>