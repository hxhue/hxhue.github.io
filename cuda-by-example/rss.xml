<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cuda-by-Examples on Bluegill</title><link>https://hxhue.github.io/cuda-by-example/</link><description>Recent content in Cuda-by-Examples on Bluegill</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sat, 26 Apr 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://hxhue.github.io/cuda-by-example/rss.xml" rel="self" type="application/rss+xml"/><item><title>CUDA by Example: Appendex</title><link>https://hxhue.github.io/cuda-by-example/CUDA-by-Example-%E9%99%84%E5%BD%95/</link><pubDate>Tue, 06 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cuda-by-example/CUDA-by-Example-%E9%99%84%E5%BD%95/</guid><description>&lt;h1 id="再次考虑-dot-计算">再次考虑 dot 计算
&lt;a class="header-anchor" href="#%e5%86%8d%e6%ac%a1%e8%80%83%e8%99%91-dot-%e8%ae%a1%e7%ae%97">&lt;/a>
&lt;/h1>&lt;p>在第 5 章的 dot 计算中，我们在每个块上做完 reduction 之后就将数据拷贝回到 CPU 了，然后让 CPU 做最后的加法。&lt;/p>
&lt;p>为什么在 compute capability 2.0 之前，&lt;code>atomicAdd&lt;/code> 只支持整数？因为原子加法是不能指定计算的发生顺序的，因而每个计算都必须遵守结合律，也就是 $(A+B)+C$ 必须等于 $A+(B+C)$。&lt;strong>但是浮点数因为中间结果的舍入问题，并不能保证这一点&lt;/strong>！！&lt;/p></description></item><item><title>CUDA by Example: Chapter 01-05</title><link>https://hxhue.github.io/cuda-by-example/CUDA-by-Example-chapter01-05/</link><pubDate>Tue, 06 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cuda-by-example/CUDA-by-Example-chapter01-05/</guid><description>&lt;p>源码可以参考 &lt;a href="https://github.com/yottaawesome/cuda-by-example/" title="https://github.com/yottaawesome/cuda-by-example/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://github.com/yottaawesome/cuda-by-example/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> ，官网的源码链接挂了。&lt;/p>
&lt;p>书中的代码有些需要用 opengl 来跑。安装了 &lt;code>freeglut3-dev&lt;/code> 和 &lt;code>mesa-utils&lt;/code>。（不确定 &lt;code>libgl1-mesa-dev&lt;/code> 是否是必要的。）然后 cmake 规则中要 link 对应的库：&lt;/p></description></item><item><title>CUDA by Example: Chapter 06-08</title><link>https://hxhue.github.io/cuda-by-example/CUDA-by-Example-chapter06-08/</link><pubDate>Tue, 06 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cuda-by-example/CUDA-by-Example-chapter06-08/</guid><description>&lt;h1 id="第-6-章-constant-memory-and-events">第 6 章 Constant Memory and Events
&lt;a class="header-anchor" href="#%e7%ac%ac-6-%e7%ab%a0-constant-memory-and-events">&lt;/a>
&lt;/h1>&lt;h2 id="常量内存">常量内存
&lt;a class="header-anchor" href="#%e5%b8%b8%e9%87%8f%e5%86%85%e5%ad%98">&lt;/a>
&lt;/h2>&lt;p>常量内存是在全局区域声明的。如果漏掉了 &lt;code>__constant__&lt;/code> 关键字，就会将其定义在全局内存区域，尽管存储方式、分配的时机和用 &lt;code>cudaMalloc&lt;/code> 申请的内存有一些差异。&lt;/p></description></item><item><title>CUDA by Example: Chapter 09-12</title><link>https://hxhue.github.io/cuda-by-example/CUDA-by-Example-chapter09-12/</link><pubDate>Fri, 02 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cuda-by-example/CUDA-by-Example-chapter09-12/</guid><description>&lt;h1 id="第-9-章-原子操作">第 9 章 原子操作
&lt;a class="header-anchor" href="#%e7%ac%ac-9-%e7%ab%a0-%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c">&lt;/a>
&lt;/h1>&lt;blockquote>
 &lt;p>You should know that atomic operations on &lt;strong>global memory&lt;/strong> are supported only on GPUs of compute capability 1.1 or higher. Furthermore, atomic operations on &lt;strong>shared memory&lt;/strong> require a GPU of compute capability 1.2 or higher.&lt;/p>
&lt;/blockquote>&lt;p>指定计算能力：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nvcc -arch&lt;span style="color:#719e07">=&lt;/span>sm_11
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样就指定了计算能力是 1.1，当有些指令是只有 1.1 才能编译时加这个参数可以确保编译。同时，有了更加精确的生成目标，nvcc 可以执行一些和硬件相关的优化手段，这些优化手段在更早的架构上可能没有。&lt;/p></description></item></channel></rss>