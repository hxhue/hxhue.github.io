<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="chapter11 - installing and packaging"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content="cmake,cpp,modern-cmake-for-cpp"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"chapter11-installing-and-packaging","permalink":"https://hxhue.github.io/modern-cmake-for-cpp/chapter11-installing-and-packaging/","title":"chapter11 - installing and packaging","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>chapter11 - installing and packaging - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#exporting-without-installation>Exporting without installation</a></li><li><a href=#cmake---install><code>cmake --install</code></a></li><li><a href=#install-命令><code>install()</code> 命令</a></li><li><a href=#installtargets><code>install(TARGETS)</code></a><ul><li><a href=#gnuinstalldirs><code>GNUInstallDirs</code></a></li><li><a href=#处理-public-headers>处理 public headers</a></li></ul></li><li><a href=#installfilesprograms><code>install(FILES|PROGRAMS)</code></a></li><li><a href=#installdirectory><code>install(DIRECTORY)</code></a></li><li><a href=#installscriptcode><code>install(SCRIPT|CODE)</code></a></li><li><a href=#installexport><code>install(EXPORT)</code></a></li><li><a href=#写-config-file>写 Config file</a><ul><li><a href=#basic-config-file>Basic config file</a></li><li><a href=#advanced-config-file>Advanced config file</a></li><li><a href=#version-file>Version file</a></li></ul></li><li><a href=#components>Components</a></li><li><a href=#managing-symbolic-links-for-versioned-shared-libraries>Managing symbolic links for versioned shared libraries</a></li><li><a href=#cpack>CPack</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/modern-cmake-for-cpp/chapter11-installing-and-packaging/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="chapter11 - installing and packaging"><meta itemprop=description content="Exporting without installation

使用 export 命令可以创建导出文件，然后其他工程只要 include 这个导出文件就能使用当前这个包中的 target，而不需要先将这个包用 install 安装在系统里。
export(TARGETS [target1 [target2 [...]]]
      [NAMESPACE <namespace>] [APPEND] FILE <path>
      [EXPORT_LINK_INTERFACE_LIBRARIES]

  NAMESPACE is recommended as a hint, stating that the target has been imported from other projects."></span><header class=post-header><h1 class=post-title itemprop="name headline">chapter11 - installing and packaging</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-02-01 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-02-01 00:00:00 +0800 CST">2024-02-01
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-08-18T00:00:00+08:00 itemprop=dateModified datetime=2024-08-18T00:00:00+08:00>2024-08-18</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/modern-cmake-for-cpp itemprop=url rel=index><span itemprop=name>modern-cmake-for-cpp</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>5274</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>11分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=exporting-without-installation>Exporting without installation
<a class=header-anchor href=#exporting-without-installation></a></h1><p>使用 <code>export</code> 命令可以创建导出文件，然后其他工程只要 include 这个导出文件就能使用当前这个包中的 target，而不需要先将这个包用 <code>install</code> 安装在系统里。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>export</span>(<span style=color:#2aa198>TARGETS</span> <span style=color:#2aa198>[target1</span> <span style=color:#2aa198>[target2</span> <span style=color:#2aa198>[...]]]</span>
</span></span><span style=display:flex><span>      <span style=color:#2aa198>[NAMESPACE</span> <span style=color:#2aa198>&lt;namespace&gt;]</span> <span style=color:#2aa198>[APPEND]</span> <span style=color:#2aa198>FILE</span> <span style=color:#2aa198>&lt;path&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#2aa198>[EXPORT_LINK_INTERFACE_LIBRARIES]</span>
</span></span></code></pre></div><blockquote><p><code>NAMESPACE</code> is recommended as a hint, stating that the target has been imported from other projects.</p><p><code>APPEND</code> tells CMake that it shouldn&rsquo;t erase the contents of the file before writing. 也就是说本身会按照 <code>FILE</code> 来覆写文件，但是 <code>APPEND</code> 使得写入方式变成追加。</p><p><code>EXPORT_LINK_INTERFACE_LIBRARIES</code> will export target link dependencies (including imported and config-specific variants).</p></blockquote><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>cmake_minimum_required</span>(<span style=color:#2aa198>VERSION</span> <span style=color:#2aa198>3.20.0</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>project</span>(<span style=color:#2aa198>ExportCalcCXX</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>add_subdirectory</span>(<span style=color:#2aa198>src</span> <span style=color:#2aa198>bin</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>set</span>(<span style=color:#2aa198>EXPORT_DIR</span> <span style=color:#2aa198>&#34;${CMAKE_CURRENT_BINARY_DIR}/cmake&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>export</span>(<span style=color:#2aa198>TARGETS</span> <span style=color:#2aa198>calc</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>FILE</span> <span style=color:#2aa198>&#34;${EXPORT_DIR}/CalcTargets.cmake&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>NAMESPACE</span> <span style=color:#2aa198>Calc::</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p><strong>这段代码将导出文件生成在了 binary tree 里面</strong>，这样的文件不会污染系统，但是可以被其他工程包含进去。还要注意 CMake 在 build tree 中导出的 target export file 里用的是绝对路径，所以不能轻易移动。上面代码还用到了一个名字空间 <code>Calc::</code>，因而创建的 target export file 中声明的 target 是 <code>Calc::calc</code>。</p><p>export 命令还有一个形式：<code>export(EXPORT &lt;export> [NAMESPACE &lt;namespace>] [FILE &lt;path>])</code>。这个形式不需要 targets，但是需要一个之前创建的 export 的名字。</p><blockquote><p>However, it requires a <code>&lt;export></code> name rather than a list of exported targets. Such <code>&lt;export></code> instances are named lists of targets that are defined by install(TARGETS)</p></blockquote><p>export 命令在 build tree 的生成阶段就会导出 target export file。<strong>使用 <code>${CMAKE_INSTALL_LIBDIR}</code> 作为前缀是安全的</strong>（更保险一点的是先 <code>include(GNUInstallDirs)</code>），因为它是一个相对路径，生成阶段的相对位置是 build tree，所以不会真正安装到系统里面去。</p><h1 id=cmake---install><code>cmake --install</code>
<a class=header-anchor href=#cmake---install></a></h1><p><code>cmake --install</code> 接受这些参数（它们的参数都是前面不加等号的）：</p><ol><li><code>--config</code>：对多配置生成器有用。</li><li><code>--component</code>：选择要安装的部分（后面讲）。</li><li><code>--default-directory-permissions</code>：设置安装目录的权限（<code>u=rwx,g=rx,o=rx</code>）。</li><li><code>--prefix</code>：设置 <code>CMAKE_INSTALL_PREFIX</code> 的值（对 Windows 来说默认为 <code>c:/Program Files/${PROJECT_NAME}</code>，对 unix 来说默认为 <code>/usr/local</code>）。</li><li><code>-v</code>, <code>--verbose</code></li></ol><h1 id=install-命令><code>install()</code> 命令
<a class=header-anchor href=#install-%e5%91%bd%e4%bb%a4></a></h1><ul><li><code>install(TARGETS)</code>: This installs output artifacts such as libraries and executables.</li><li><code>install(FILES|PROGRAMS)</code>: This installs individual files and sets their permissions. 这两命令非常相似，但是设置的默认权限不同，显然 <code>PROGRAMS</code> 会设置写权限。</li><li><code>install(DIRECTORY)</code>: This installs whole directories.</li><li><code>install(SCRIPT|CODE)</code>: This runs a CMake script or a snippet during installation.</li><li><code>install(EXPORT)</code>: This generates and installs a target export file.</li></ul><p><code>install</code> 命令可以指定 <code>DESTINATION</code>/<code>PERMISSIONS</code>/<code>CONFIGURATIONS</code>/<code>OPTIONAL</code> 等参数。在 <code>COMPONENT</code> 模式下，还可以指定 <code>EXCLUDE_FROM_ALL</code>。如果给定的安装位置是相对路径，那么实际上的安装位置是 <code>${CMAKE_INSTALL_PREFIX} + ${DESTINATION}</code>。</p><h1 id=installtargets><code>install(TARGETS)</code>
<a class=header-anchor href=#installtargets></a></h1><div class="markdown-alert markdown-alert-note"><p class=markdown-alert-title><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>Note</p><p><code>OPTIONAL</code> 指的是如果找不到要安装的文件也不报错。<code>CONFIGURATIONS</code> 指的是这个安装对哪些配置（Debug, Release）有效，处在无效配置时这条 <code>install</code> 命令被忽略。</p></div><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>install</span>(<span style=color:#2aa198>TARGETS</span> <span style=color:#2aa198>&lt;target&gt;...</span> <span style=color:#2aa198>[EXPORT</span> <span style=color:#2aa198>&lt;export-name&gt;]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[&lt;output-artifact-configuration&gt;</span> <span style=color:#2aa198>...]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[INCLUDES</span> <span style=color:#2aa198>DESTINATION</span> <span style=color:#2aa198>[&lt;dir&gt;</span> <span style=color:#2aa198>...]]</span>
</span></span><span style=display:flex><span>        )
</span></span></code></pre></div><p><code>&lt;output-artifact-configuration></code> 指的是：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span>&lt;TYPE&gt; [DESTINATION &lt;dir&gt;] [PERMISSIONS permissions...]
</span></span><span style=display:flex><span>       [CONFIGURATIONS [Debug|Release|...]]
</span></span><span style=display:flex><span>       [COMPONENT &lt;component&gt;]
</span></span><span style=display:flex><span>       [NAMELINK_COMPONENT &lt;component&gt;]
</span></span><span style=display:flex><span>       [OPTIONAL] [EXCLUDE_FROM_ALL]
</span></span><span style=display:flex><span>       [NAMELINK_ONLY|NAMELINK_SKIP]
</span></span></code></pre></div><p>其中的 <code>&lt;TYPE></code> 可以是：</p><ol><li><code>ARCHIVE</code> 静态库（Static libraries (.a) and DLL import libraries for Windows-based systems (.lib)）</li><li><code>LIBRARY</code> 动态库（Shared libraries (.so), but not DLLs）</li><li><code>RUNTIME</code> 可执行文件和 DLLs。</li><li><code>OBJECT</code> 目标文件</li><li><code>FRAMEWORK</code> macOS 专属</li><li><code>BUNDLE</code> macOS 专属</li><li><code>PUBLIC_HEADER</code>, <code>PRIVATE_HEADER</code>, <code>RESOURCE</code></li></ol><p>一个 target 可以同时指定安装多个 types。也就是说，有个 target 可能既需要安装静态库，又需要安装动态库，同时还安装头文件。如果一个 target 被指定了需要安装某一类成品（比如设置了 <code>PUBLIC_HEADER</code> 属性），但是这个成品没有在 <code>install</code> 命令中给出配置，那么在 3.20.0 之前就会忽略它的安装，而在这之后则是使用默认配置安装。参考：</p><blockquote><p>The CMake documentation claims that if you only configure one artifact type (for example, <code>LIBRARY</code>), only this type will be installed. For CMake version 3.20.0, this is not true: all the artifacts will be installed as if they were configured with the default options. This can be solved by specifying <code>&lt;TYPE> EXCLUDE_FROM_ALL</code> for all unwanted artifact types.</p></blockquote><p>这个命令也有局限性，比如虽然 <code>CONFIGURATIONS</code> 是可以对每个成品类型单独设置，但是一个成品类型只能在 <code>install</code> 命令中出现一次。也就是说想要对 Debug 和 Release 两种配置单独设置某种成品的安装方式，需要两条 <code>install</code> 命令，不能放在一起写。</p><p><img src=/assets/4a429e2c96abfb245883b6fd8e556f15.webp></p><p>上面的这些变量也能够通过命令行设置（大概是因为它们是 cached 变量）。</p><h2 id=gnuinstalldirs><code>GNUInstallDirs</code>
<a class=header-anchor href=#gnuinstalldirs></a></h2><p>CMake 有一个 <code>GNUInstallDirs</code> 模块。这个模块可以检查 GNU 平台的种类（比如说有些系统并不是安装在 <code>/usr/local</code> 中比较好），并正确设置好和安装路径相关的变量。在安装之前 <code>include</code> 一下就行了。</p><h2 id=处理-public-headers>处理 public headers
<a class=header-anchor href=#%e5%a4%84%e7%90%86-public-headers></a></h2><blockquote><p>The <code>install(TARGETS)</code> documentation recommends that we specify public headers (as a semicolon-separated list) in the <code>PUBLIC_HEADER</code> property of the library target.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>add_library</span>(<span style=color:#2aa198>calc</span> <span style=color:#2aa198>STATIC</span> <span style=color:#2aa198>calc.cpp</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>target_include_directories</span>(<span style=color:#2aa198>calc</span> <span style=color:#2aa198>INTERFACE</span> <span style=color:#2aa198>include</span>)
</span></span><span style=display:flex><span><span style=color:#586e75># 也可以直接设置 INTERFACE_ 开头的变量
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#b58900>set_target_properties</span>(<span style=color:#2aa198>calc</span> <span style=color:#2aa198>PROPERTIES</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>PUBLIC_HEADER</span> <span style=color:#2aa198>src/include/calc/calc.h</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>因为设置了 calc 这个 target 的 <code>PUBLIC_HEADER</code> 属性，这下用 install 安装 calc 的时候，只要指定 <code>PUBLIC_HEADER</code> 也能将这些头文件也一起安装。</p><p>但是我们还需要解决一个问题，CMake 的默认安装位置很可能不是我们想要的。尤其是直接将头文件裸露在 /usr/local/include 里面这一点。包含 <code>GNUInstallDirs</code> 模块之后，<code>CMAKE_INSTALL_INCLUDEDIR</code> 会被重设。然后我们根据它注明我们要安装的位置（参数 <code>DESTINATION</code>）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>cmake_minimum_required</span>(<span style=color:#2aa198>VERSION</span> <span style=color:#2aa198>3.20.0</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>project</span>(<span style=color:#2aa198>InstallTargets</span> <span style=color:#2aa198>CXX</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>add_subdirectory</span>(<span style=color:#2aa198>src</span> <span style=color:#2aa198>bin</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>include</span>(<span style=color:#2aa198>GNUInstallDirs</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>install</span>(<span style=color:#2aa198>TARGETS</span> <span style=color:#2aa198>calc</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>ARCHIVE</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>PUBLIC_HEADER</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>DESTINATION</span> <span style=color:#719e07>${</span><span style=color:#268bd2>CMAKE_INSTALL_INCLUDEDIR</span><span style=color:#719e07>}</span><span style=color:#2aa198>/calc</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><div class="markdown-alert markdown-alert-note"><p class=markdown-alert-title><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>Note</p><p>在 Debian 12 上测试，<code>CMAKE_INSTALL_INCLUDEDIR</code> 都是 include。拼接上默认的前缀路径就是 usr/local/include。</p></div><p>这个变量似乎在所有平台上其实都是一样的，但是也有一些变量在不同平台上表现不同，比如：</p><blockquote><p><code>CMAKE_INSTALL_LIBDIR</code> will vary by architecture and distribution – <code>lib</code>, <code>lib64</code>, or <code>lib/&lt;multiarch-tuple></code>.</p></blockquote><p>书上给出的运行结果：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#586e75># cmake -S &lt;source-tree&gt; -B &lt;build-tree&gt;</span>
</span></span><span style=display:flex><span><span style=color:#586e75># cmake --build &lt;build-tree&gt;</span>
</span></span><span style=display:flex><span><span style=color:#586e75># cmake --install &lt;build-tree&gt;</span>
</span></span><span style=display:flex><span>-- Install configuration: <span style=color:#2aa198>&#34;&#34;</span>
</span></span><span style=display:flex><span>-- Installing: /usr/local/lib/libcalc.a
</span></span><span style=display:flex><span>-- Installing: /usr/local/include/calc/calc.h
</span></span></code></pre></div><p>由于版本比较新，而且没有指定静态库成品的安装方式，所以按照默认方式安装了。</p><p>这种基于 target 的安装感觉比基于其他方式的安装更加灵活和方便，毕竟是把很多成品都捆绑在一起了。但是也有缺点，比如必须要给出所有的头文件，手动列举容易形成超长的列表。而且所有头文件都被安装在了同一个目录，丢失了层级关系：</p><div class="markdown-alert markdown-alert-warning"><p class=markdown-alert-title><svg class="octicon octicon-alert mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086.0l6.082 11.378A1.75 1.75.0 0114.082 15H1.918A1.75 1.75.0 01.375 12.425zm1.763.707a.25.25.0 00-.44.0L1.698 13.132a.25.25.0 00.22.368h12.164a.25.25.0 00.22-.368zm.53 3.996v2.5a.75.75.0 01-1.5.0v-2.5a.75.75.0 011.5.0zM9 11a1 1 0 11-2 0 1 1 0 012 0z"/></svg>Warning</p><p>This works well for this basic case, but there&rsquo;s a slight drawback: files specified in this way don&rsquo;t retain their directory structure. They will all be installed in the same destination, even if they&rsquo;re nested in different base directories.</p></div><p>在 CMake 3.23.0 之后，<code>target_sources</code> 有新选项 <code>FILE_SET</code> 可以更好解决这个问题。</p><h1 id=installfilesprograms><code>install(FILES|PROGRAMS)</code>
<a class=header-anchor href=#installfilesprograms></a></h1><p>签名：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>install</span>(<span style=color:#2aa198>&lt;FILES|PROGRAMS&gt;</span> <span style=color:#2aa198>files...</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>TYPE</span> <span style=color:#2aa198>&lt;type&gt;</span> <span style=color:#2aa198>|</span> <span style=color:#2aa198>DESTINATION</span> <span style=color:#2aa198>&lt;dir&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[PERMISSIONS</span> <span style=color:#2aa198>permissions...]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[CONFIGURATIONS</span> <span style=color:#2aa198>[Debug|Release|...]]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[COMPONENT</span> <span style=color:#2aa198>&lt;component&gt;]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[RENAME</span> <span style=color:#2aa198>&lt;name&gt;]</span> <span style=color:#2aa198>[OPTIONAL]</span> <span style=color:#2aa198>[EXCLUDE_FROM_ALL]</span>)
</span></span></code></pre></div><p>这两命令非常相似，但是设置的默认权限不同，主要是 <code>PROGRAMS</code> 会设置写权限。下面是不同类型和默认的安装位置。</p><p><img src=/assets/01e051f3683d45def6221e2a53e1630e.webp></p><h1 id=installdirectory><code>install(DIRECTORY)</code>
<a class=header-anchor href=#installdirectory></a></h1><p>签名：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>install</span>(<span style=color:#2aa198>DIRECTORY</span> <span style=color:#2aa198>dirs...</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>TYPE</span> <span style=color:#2aa198>&lt;type&gt;</span> <span style=color:#2aa198>|</span> <span style=color:#2aa198>DESTINATION</span> <span style=color:#2aa198>&lt;dir&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[FILE_PERMISSIONS</span> <span style=color:#2aa198>permissions...]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[DIRECTORY_PERMISSIONS</span> <span style=color:#2aa198>permissions...]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[USE_SOURCE_PERMISSIONS]</span> <span style=color:#2aa198>[OPTIONAL]</span> <span style=color:#2aa198>[MESSAGE_NEVER]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[CONFIGURATIONS</span> <span style=color:#2aa198>[Debug|Release|...]]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[COMPONENT</span> <span style=color:#2aa198>&lt;component&gt;]</span> <span style=color:#2aa198>[EXCLUDE_FROM_ALL]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[FILES_MATCHING]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[[PATTERN</span> <span style=color:#2aa198>&lt;pattern&gt;</span> <span style=color:#2aa198>|</span> <span style=color:#2aa198>REGEX</span> <span style=color:#2aa198>&lt;regex&gt;]</span> <span style=color:#2aa198>[EXCLUDE]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[PERMISSIONS</span> <span style=color:#2aa198>permissions...]]</span> <span style=color:#2aa198>[...]</span>
</span></span></code></pre></div><p><code>TYPE</code> 选项和 <code>install(FILES|PROGRAMS)</code> 是一样的。</p><p>有个小细节需要注意：<strong>如果给的目录没有以 / 结尾，将会将目录本身复制到目的位置。如果以 / 结尾，将会把目录中的内容复制到目的位置，这个和 rsync 的拷贝有相同之处</strong>！</p><blockquote><p>There&rsquo;s one detail worth noting: if the paths that are provided after the <code>DIRECTORY</code> keyword do not end with /, the last directory of the path will be appended to the destination, like so:</p><p><code>install(DIRECTORY a DESTINATION /x)</code></p><p>This will create a directory called <strong>/x/a</strong> and copy the contents of a to it. Now, look at the following code:</p><p><code>install(DIRECTORY a/ DESTINATION /x)</code></p><p>This will copy the contents of a <strong>directly to /x</strong>.</p></blockquote><p>使用这个模式的时候可以用 <code>DIRECTORY_PERMISSIONS</code> 参数设置文件夹的 <code>x</code> 权限。这是因为文件夹的 <code>x</code> 权限表示用户是否能够进入目录和列举目录内容，是和文件有一点不同的。</p><p>还能过滤目录中的文件。可以用 <code>PATTERN</code> 来匹配 glob 表达式（<strong>以给定的 parttern 结尾</strong>的所有文件名都会被匹配上），或者用 <code>REGEX</code> 来匹配正则表达式。用 <code>FILES_MATCHING</code> 来选择文件（但是不会排除目录，因而目录结构会被保留）。用 <code>EXCLUDE</code> 来排除一部分已经匹配上的内容。</p><h1 id=installscriptcode><code>install(SCRIPT|CODE)</code>
<a class=header-anchor href=#installscriptcode></a></h1><p><strong>在安装的时候执行代码</strong>。这里的代码得是 CMake 的代码，并不是 shell 的代码：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>cmake_minimum_required</span>(<span style=color:#2aa198>VERSION</span> <span style=color:#2aa198>3.20.0</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>project</span>(<span style=color:#2aa198>InstallCode</span> <span style=color:#2aa198>CXX</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>add_subdirectory</span>(<span style=color:#2aa198>src</span> <span style=color:#2aa198>bin</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b58900>include</span>(<span style=color:#2aa198>GNUInstallDirs</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>install</span>(<span style=color:#2aa198>TARGETS</span> <span style=color:#2aa198>calc</span> <span style=color:#2aa198>LIBRARY</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>PUBLIC_HEADER</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>DESTINATION</span> <span style=color:#719e07>${</span><span style=color:#268bd2>CMAKE_INSTALL_INCLUDEDIR</span><span style=color:#719e07>}</span><span style=color:#2aa198>/calc</span>
</span></span><span style=display:flex><span>       )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b58900>if</span> (<span style=color:#2aa198>UNIX</span>)
</span></span><span style=display:flex><span>  <span style=color:#b58900>install</span>(<span style=color:#2aa198>CODE</span> <span style=color:#2aa198>&#34;execute_process(COMMAND ldconfig)&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>endif</span>()
</span></span></code></pre></div><p>这里的 <code>"execute_process(COMMAND ldconfig)"</code> 只能用奇异来形容。</p><p>也可以用 <code>install(SCRIPT)</code>，但是它的参数是 CMake 脚本文件的路径而不是代码字符串。</p><h1 id=installexport><code>install(EXPORT)</code>
<a class=header-anchor href=#installexport></a></h1><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>install</span>(<span style=color:#2aa198>EXPORT</span> <span style=color:#2aa198>&lt;export-name&gt;</span> <span style=color:#2aa198>DESTINATION</span> <span style=color:#2aa198>&lt;dir&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[NAMESPACE</span> <span style=color:#2aa198>&lt;namespace&gt;]</span> <span style=color:#2aa198>[[FILE</span> <span style=color:#2aa198>&lt;name&gt;.cmake]|</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[PERMISSIONS</span> <span style=color:#2aa198>permissions...]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[CONFIGURATIONS</span> <span style=color:#2aa198>[Debug|Release|...]]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[EXPORT_LINK_INTERFACE_LIBRARIES]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[COMPONENT</span> <span style=color:#2aa198>&lt;component&gt;]</span>
</span></span><span style=display:flex><span>        <span style=color:#2aa198>[EXCLUDE_FROM_ALL]</span>)
</span></span></code></pre></div><blockquote><p>It&rsquo;s a combination of &ldquo;plain&rdquo; <code>export(EXPORT)</code> and other <code>install()</code> commands.</p></blockquote><div class="markdown-alert markdown-alert-note"><p class=markdown-alert-title><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>Note</p><p>好像能使用的 <code>EXPORT</code> 参数的 <code>install()</code> 命令除了 <code>install(EXPORT)</code> 本身也就只有 <code>install(TARGETS)</code> 了。</p></div><p>这个命令是用来安装 export 文件的。用 <code>export</code> 或者 <code>install(TARGETS ... EXPORT)</code> 可以生成 export 文件。这个命令不会在构建时在 binary tree 里产生文件哦！</p><h1 id=写-config-file>写 Config file
<a class=header-anchor href=#%e5%86%99-config-file></a></h1><h2 id=basic-config-file>Basic config file
<a class=header-anchor href=#basic-config-file></a></h2><blockquote><p>A complete package definition consists of the <strong>target export files</strong>, the package&rsquo;s <strong>config file</strong>, and the package&rsquo;s <strong>version file</strong>, but technically, all that&rsquo;s needed for <code>find_package()</code> to work is a config-file.</p></blockquote><p>Config file 的命名：<code>&lt;PackageName>-config.cmake</code> or <code>&lt;PackageName>Config.cmake</code>。搜索路径有很多，一般可以放在 <code>${CMAKE_INSTALL_LIBDIR}/&lt;PackageName>/cmake/</code> 下。</p><p>最简单的 config file 就是直接将 target export files 引用进来：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#586e75># CMakeLists.txt
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#b58900>install</span>(<span style=color:#2aa198>EXPORT</span> <span style=color:#2aa198>CalcTargets</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>DESTINATION</span> <span style=color:#719e07>${</span><span style=color:#268bd2>CMAKE_INSTALL_LIBDIR</span><span style=color:#719e07>}</span><span style=color:#2aa198>/calc/cmake</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>NAMESPACE</span> <span style=color:#2aa198>Calc::</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#b58900>install</span>(<span style=color:#2aa198>FILES</span> <span style=color:#2aa198>&#34;CalcConfig.cmake&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>DESTINATION</span> <span style=color:#719e07>${</span><span style=color:#268bd2>CMAKE_INSTALL_LIBDIR</span><span style=color:#719e07>}</span><span style=color:#2aa198>/calc/cmake</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#586e75># CalcConfig.cmake
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#b58900>include</span>(<span style=color:#2aa198>&#34;${CMAKE_CURRENT_LIST_DIR}/CalcTargets.cmake&#34;</span>)
</span></span></code></pre></div><h2 id=advanced-config-file>Advanced config file
<a class=header-anchor href=#advanced-config-file></a></h2><p>更高级一点的是不自己写 CalcConfig.cmake，而是提供模板 CalcConfig.cmake.in 文件（一般按照这种方式命名）。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>cmake_minimum_required</span>(<span style=color:#2aa198>VERSION</span> <span style=color:#2aa198>3.20.0</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>project</span>(<span style=color:#2aa198>AdvancedConfig</span> <span style=color:#2aa198>CXX</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>include</span>(<span style=color:#2aa198>GNUInstallDirs</span>) <span style=color:#586e75># so it&#39;s available in ./src/
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#b58900>add_subdirectory</span>(<span style=color:#2aa198>src</span> <span style=color:#2aa198>bin</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b58900>install</span>(<span style=color:#2aa198>TARGETS</span> <span style=color:#2aa198>calc</span> <span style=color:#2aa198>EXPORT</span> <span style=color:#2aa198>CalcTargets</span> <span style=color:#2aa198>ARCHIVE</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>PUBLIC_HEADER</span> <span style=color:#2aa198>DESTINATION</span> <span style=color:#719e07>${</span><span style=color:#268bd2>CMAKE_INSTALL_INCLUDEDIR</span><span style=color:#719e07>}</span><span style=color:#2aa198>/calc</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#b58900>install</span>(<span style=color:#2aa198>EXPORT</span> <span style=color:#2aa198>CalcTargets</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>DESTINATION</span> <span style=color:#719e07>${</span><span style=color:#268bd2>CMAKE_INSTALL_LIBDIR</span><span style=color:#719e07>}</span><span style=color:#2aa198>/calc/cmake</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>NAMESPACE</span> <span style=color:#2aa198>Calc::</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#586e75># 到这一步已经有了 target export file，但是没有 config file
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#b58900>include</span>(<span style=color:#2aa198>CMakePackageConfigHelpers</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>set</span>(<span style=color:#2aa198>LIB_INSTALL_DIR</span> <span style=color:#719e07>${</span><span style=color:#268bd2>CMAKE_INSTALL_LIBDIR</span><span style=color:#719e07>}</span><span style=color:#2aa198>/calc</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>configure_package_config_file</span>(
</span></span><span style=display:flex><span>  <span style=color:#719e07>${</span><span style=color:#268bd2>CMAKE_CURRENT_SOURCE_DIR</span><span style=color:#719e07>}</span><span style=color:#2aa198>/CalcConfig.cmake.in</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>&#34;${CMAKE_CURRENT_BINARY_DIR}/CalcConfig.cmake&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>INSTALL_DESTINATION</span> <span style=color:#719e07>${</span><span style=color:#268bd2>CMAKE_INSTALL_LIBDIR</span><span style=color:#719e07>}</span><span style=color:#2aa198>/calc/cmake</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>PATH_VARS</span> <span style=color:#2aa198>LIB_INSTALL_DIR</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#586e75># 到这一步已经根据模板文件创建了 config file
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#b58900>install</span>(<span style=color:#2aa198>FILES</span> <span style=color:#2aa198>&#34;${CMAKE_CURRENT_BINARY_DIR}/CalcConfig.cmake&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>DESTINATION</span> <span style=color:#719e07>${</span><span style=color:#268bd2>CMAKE_INSTALL_LIBDIR</span><span style=color:#719e07>}</span><span style=color:#2aa198>/calc/cmake</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>一般使用 <a href=https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html title=CMakePackageConfigHelpers rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>CMakePackageConfigHelpers</code><i class="fa fa-external-link-alt"></i></a> 模块来帮助完成这个操作。使用 <a href=https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html#command:configure_package_config_file title rel="noopener external nofollow noreferrer" target=_blank class=exturl><i class="fa fa-external-link-alt"></i></a> 和 <code>install</code> 分了两部，而不是一口气安装到系统目录，这是因为 configure 的时候不确定用户是否需要安装，所以不能轻易安装。只有用户使用 <code>cmake --install</code> 启动安装过程时，才应该将其安装到系统。另外就是在 configure 的时候就要明确目的安装路径了，因为可能有些安装文件是要硬编码最终的安装路径的。</p><p><code>PATH_VARS</code> 是我们要从当前的 CMake 脚本向 <code>*.cmake.in</code> 文件传递的变量，这些变量可以在模板文件中引用。并且这个函数会对我们传入的变量重新计算，正确处理好绝对路径和相对路径。比如上面代码中传入的是 <code>LIB_INSTALL_DIR</code>，在模板文件中可以用 <code>@PACKAGE_LIB_INSTALL_DIR@</code> 来引用，注意有一个 <code>PACKAGE</code> 前缀。如果传入的是 <code>calc</code>（相对路径），会被展开为 <code>${PACKAGE_PREFIX_DIR}/calc</code>；传入的是 <code>/calc</code>（绝对路径），会被展开为 <code>/calc</code>（不做路径拼接）。</p><p>模板文件写法如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span>@PACKAGE_INIT@
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b58900>set_and_check</span>(<span style=color:#2aa198>CALC_LIB_DIR</span> <span style=color:#2aa198>&#34;@PACKAGE_LIB_INSTALL_DIR@&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>include</span>(<span style=color:#2aa198>&#34;${CALC_LIB_DIR}/cmake/CalcTargets.cmake&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b58900>check_required_components</span>(<span style=color:#2aa198>Calc</span>)
</span></span></code></pre></div><p>开头有一个固定的 <code>@PACKAGE_INIT@</code> 头。<code>set_and_check</code> 和 <code>check_required_components</code> 都是 <code>configure_package_config_file</code> 提供的宏，会在 <code>@PACKAGE_INIT@</code> 展开的时候补充出来。好像目前版本里就只提供了这两个宏。</p><p><code>set_and_check</code> 会在设置变量后检查它是否为一个在操作系统上存在的路径，不存在则报错。<code>check_required_components</code> 的参数是当前包的名字，它会根据 CMake 的 find_package 调用规定检查传来的 COMPONENTS 是否全部被找到了（以 FOUND 为后缀的变量是否为真），没有找到则报错。所以这个宏要放在整个模板文件的最后使用。</p><p>基本上一头一尾是固定的，中间是一些 include 和变量设置。</p><p>如果有一些必须要满足的依赖可以使用 <code>CMakeFindDependencyMacro</code> 中的 <code>find_dependency()</code> 去找，注意这个宏有找不到就返回的性质。这个函数在
<a href=/modern-cmake-for-cpp/chapter07-managing-dependencies/ title="chapter07 - managing dependencies">chapter07 - managing dependencies</a> 已经提到过了。</p><h2 id=version-file>Version file
<a class=header-anchor href=#version-file></a></h2><p><code>CMakePackageConfigHelpers</code> 还提供了生成 version 文件的功能。有了 version，用户就能像这样来查找包：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>find_package</span>(<span style=color:#2aa198>Calc</span> <span style=color:#2aa198>1.2.3</span> <span style=color:#2aa198>REQUIRED</span>)
</span></span></code></pre></div><blockquote><p>CMake will then search the config-file for Calc and check if a version file named <code>&lt;config-file>-version.cmake</code> or <code>&lt;config-file>Version.cmake</code> is present in the same directory, that is, <code>CalcConfigVersion.cmake</code>.</p></blockquote><p><code>write_basic_package_version_file</code> 的用法：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>write_basic_package_version_file</span>(<span style=color:#2aa198>&lt;filename&gt;</span> <span style=color:#2aa198>[VERSION</span> <span style=color:#2aa198>&lt;ver&gt;]</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>COMPATIBILITY</span> <span style=color:#2aa198>&lt;AnyNewerVersion</span>  <span style=color:#2aa198>|</span> <span style=color:#2aa198>SameMajorVersion</span> <span style=color:#2aa198>|</span>
</span></span><span style=display:flex><span>                 <span style=color:#2aa198>SameMinorVersion</span> <span style=color:#2aa198>|</span> <span style=color:#2aa198>ExactVersion&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>[ARCH_INDEPENDENT]</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>其中兼容性指定的是版本可能不同时的处理情况，如果使用 <code>AnyNewerVersion</code>，则可以向下兼容请求的版本。</p><blockquote><p>First, we need to provide the <code>&lt;filename></code> property of the artifact we want to create; it must follow the rules we outlined earlier. Other than that, keep in mind that we should store all the generated files in the build tree.</p></blockquote><p>注意这个命令还是将文件写入到 build tree 的。安装步骤是要分开的。我们可以提供一个 <code>VERSION</code> 参数，如果不提供则会使用我们的 <code>project()</code> 中标注的 <code>VERSION</code> 参数，如果 <code>project()</code> 也没有提供 <code>VERSION</code> 就会报错了。</p><h1 id=components>Components
<a class=header-anchor href=#components></a></h1><p><code>find_package</code> 可以有 <code>COMPONENTS</code> 和 <code>OPTIONAL_COMPONENTS</code> 参数。注意这些参数需要由 config 提供者在 config 文件中做好检查，如果不检查那么就会无事发生。</p><blockquote><p>Requested components are passed to the config-file in the <code>&lt;package>_FIND_COMPONENTS</code> variable (both optional and not). Additionally, for every non-optional component, a <code>&lt;package>_FIND_REQUIRED_&lt;component></code> will be set. As package authors, we could write a macro to scan this list and check if we have provided all the required components. But we don&rsquo;t need to – this is exactly what <code>check_required_components()</code> does. To use it, the config-file should set the <code>&lt;Package>_&lt;Component>_FOUND</code> variable when the necessary component is found. The macro at the end of the file will check if all the required variables were set.</p></blockquote><p>对于必要的 components 做检查时，可以使用 <code>CMakePackageConfigHelper</code> 模块中提供的 <code>check_required_components()</code> 宏。到文件最后还没有设置 FOUND 变量的对应模块就被视为没有找到。</p><p>CMake 在命令行从 build tree 中安装 components（如果指定的某些 components 没有匹配成功，也不会报错，只是不安装而已）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>cmake --install &lt;build tree&gt; --component<span style=color:#719e07>=</span>&lt;component name&gt;
</span></span></code></pre></div><p>install() 命令中可以给每一项都加 COMPONENT 参数，将给定项目归类到一个 COMPONENT 中。这样在限定 COMPONENT 时，就只会安装对应的文件。但是即便是标记了 COMPONENT，文件也会被默认安装，想要将其排除需要使用 EXCLUDE_FROM_ALL。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>install</span>(<span style=color:#2aa198>TARGETS</span> <span style=color:#2aa198>calc</span> <span style=color:#2aa198>EXPORT</span> <span style=color:#2aa198>CalcTargets</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>ARCHIVE</span>
</span></span><span style=display:flex><span>    <span style=color:#2aa198>COMPONENT</span> <span style=color:#2aa198>lib</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>PUBLIC_HEADER</span>
</span></span><span style=display:flex><span>    <span style=color:#2aa198>DESTINATION</span> <span style=color:#719e07>${</span><span style=color:#268bd2>CMAKE_INSTALL_INCLUDEDIR</span><span style=color:#719e07>}</span><span style=color:#2aa198>/calc</span>
</span></span><span style=display:flex><span>    <span style=color:#2aa198>COMPONENT</span> <span style=color:#2aa198>headers</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><blockquote><p>If no <code>COMPONENT</code> keyword is specified for the installed artifact, it will get a default value of Unspecified from the <code>CMAKE_INSTALL_DEFAULT_COMPONENT_NAME</code> variable.</p></blockquote><h1 id=managing-symbolic-links-for-versioned-shared-libraries>Managing symbolic links for versioned shared libraries
<a class=header-anchor href=#managing-symbolic-links-for-versioned-shared-libraries></a></h1><p>在安装的时候 CMake 可能会使用符号链接帮助我们处理好 linker 的问题：</p><blockquote><p>The target platform for your installation may use symbolic links to help linkers discover the currently installed version of a shared library. After creating a <code>lib&lt;name>.so</code> symlink to the <code>lib&lt;name>.so.1</code> file, it&rsquo;s possible to link this library by passing the <code>-l&lt;name></code> argument to the linker. The creation of such symlinks is handled by <code>CMake</code>&rsquo;s <code>install(TARGETS &lt;target> LIBRARY)</code> block when needed.</p></blockquote><p>可以跳过符号链接的阶段，或者只进行符号链接的阶段。</p><p><img src=/assets/5e75910ef77984fadaa879387f8921a1.webp></p><h1 id=cpack>CPack
<a class=header-anchor href=#cpack></a></h1><p>以下是 CPack 支持的 package generators。请不要将 package generators 和 build generators 搞混淆。</p><p><img src=/assets/33ecd0b25782c14cde3061e906c7688c.webp></p><p>使用 CPack 只需要在 CMakeLists.txt 正确写好 install 命令，然后加入对 CPack 相关变量的设置和对 CPack 模块的引用。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>set</span>(<span style=color:#2aa198>CPACK_PACKAGE_VENDOR</span> <span style=color:#2aa198>&#34;Rafal Swidzinski&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>set</span>(<span style=color:#2aa198>CPACK_PACKAGE_CONTACT</span> <span style=color:#2aa198>&#34;email@example.com&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>set</span>(<span style=color:#2aa198>CPACK_PACKAGE_DESCRIPTION</span> <span style=color:#2aa198>&#34;Simple Calculator&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#b58900>include</span>(<span style=color:#2aa198>CPack</span>)
</span></span></code></pre></div><p>这里 CPack 模块的作用是从 project 命令的设置结果中推导一些 cpack 程序需要用到的变量。没有 CPack 也可以手动设置这些变量。</p><p>这几个变量是安装必不可缺的（还有很多不可缺少的变量，<code>include(CPack)</code> 就能推导）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span>变量名                       对应命令行参数（覆盖）
</span></span><span style=display:flex><span>CPACK_PACKAGE_NAME          -P
</span></span><span style=display:flex><span>CPACK_PACKAGE_VERSION       -R
</span></span><span style=display:flex><span>CPACK_PACKAGE_VENDOR        --vendor
</span></span></code></pre></div><p>最终文件名是 <code>$CPACK_PACKAGE_NAME-$CPACK_PACKAGE_VERSION-$CPACK_SYSTEM_NAME</code>，比如 CPackPackage-1.2.3-Linux.zip（package generator 是 ZIP）。</p><p>为了让 CPack 能推导变量，project() 命令就要写的详细一点（其实也就只是需要一个明确的 version，毕竟名字是必需的、语言是无关的）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#b58900>project</span>(<span style=color:#2aa198>CPackPackage</span> <span style=color:#2aa198>VERSION</span> <span style=color:#2aa198>1.2.3</span> <span style=color:#2aa198>LANGUAGES</span> <span style=color:#2aa198>CXX</span>)
</span></span></code></pre></div><p>其他选项：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>-G &lt;generators&gt;      semicolon-separated list of package generators
</span></span><span style=display:flex><span>                     可以在 CMakeLists.txt 的 include(CPack) 之前设置 CPACK_GENERATOR 变量以提供默认值
</span></span><span style=display:flex><span>-C &lt;configs&gt;         semicolon-separated list of build configurations (debug, release)
</span></span><span style=display:flex><span>-D &lt;var&gt;=&lt;value&gt;
</span></span><span style=display:flex><span>--config &lt;config-file&gt;
</span></span><span style=display:flex><span>                     覆盖 CPackConfig.cmake 的路径（这样就可以不命名为 CPackConfig.cmake）
</span></span><span style=display:flex><span>-B &lt;packageDirectory&gt;
</span></span><span style=display:flex><span>                     输出路径。默认是当前工作路径。
</span></span></code></pre></div><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>cpack -G <span style=color:#2aa198>&#34;ZIP;7Z;DEB&#34;</span> -B pkgs
</span></span></code></pre></div><p>这样会生成三个包，分别是（书中给出的结果）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>CPackPackage-1.2.3-Linux.7z
</span></span><span style=display:flex><span>CPackPackage-1.2.3-Linux.deb
</span></span><span style=display:flex><span>CPackPackage-1.2.3-Linux.zip
</span></span></code></pre></div><p>因为 cpack 还会生成临时的目录 <code>_CPack_Packages</code>，所以最好显式提供 -B 参数，不要生成在当前路径。就算是在 build 里面，将多个包分组在同一个文件夹里面也是更好的做法。</p><div class="markdown-alert markdown-alert-caution"><p class=markdown-alert-title><svg class="octicon octicon-stop mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M4.47.22A.749.749.0 015 0h6c.199.0.389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749.0 01-.22.53l-4.25 4.25A.749.749.0 0111 16H5a.749.749.0 01-.53-.22L.22 11.53A.749.749.0 010 11V5c0-.199.079-.389.22-.53zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5zM8 4a.75.75.0 01.75.75v3.5a.75.75.0 01-1.5.0v-3.5A.75.75.0 018 4zm0 8a1 1 0 110-2 1 1 0 010 2z"/></svg>Caution</p><p>cpack 要在 build tree 里面跑，这个和 ctest 一样。</p><p>为什么要在 build tree 里跑呢？因为 build tree 中有生成的 CPackConfig.cmake。如果在别处跑，就不会自动加载这个文件，从而报错：<code>CPack Error: CPack project name not specified</code>。这样的报错很隐晦，因为 cpack 程序并不要求存在 CPackConfig.cmake 才能运行，而我们也使用了 <code>include(CPack)</code> 的写法，没有手动提供必需的变量。</p><p>如果直接在 source tree 里跑，能够通过 <code>--config</code> 选项传入 build tree 中的 CPackConfig.cmake 路径，也是可以成功的。</p></div><div class="markdown-alert markdown-alert-note"><p class=markdown-alert-title><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>Note</p><p>cpack 在 multi-config generator（至少 Ninja Multi-Config 是这样）的 build tree 中默认寻找的是 Release 版本。使用 <code>-C Debug</code> 来允许 Debug 版本的安装。</p></div><p>感觉 CPack 很好用，在写好 install 命令的基础上几乎不必花时间去适配 CPack。主要还是 install 比较复杂。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/cmake>cmake
</a><a href=/tags/cpp>cpp
</a><a href=/tags/modern-cmake-for-cpp>modern-cmake-for-cpp</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/modern-cmake-for-cpp/chapter10-documents/ rel=next title="chapter10 - documents"><i class="fa fa-chevron-left"></i> chapter10 - documents</a></div><div class="post-nav-prev post-nav-item"><a href=/modern-cmake-for-cpp/chapter11.a-%E5%AF%B9%E6%AF%94-export-%E5%92%8C-install-%E5%91%BD%E4%BB%A4/ rel=prev title="chapter11.a - 对比 export 和 install 命令">chapter11.a - 对比 export 和 install 命令
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>