<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="(CppCon 2023) Lock-free Atomic Shared Pointers Without a Split Reference Count"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content="cpp,cppcon"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"CppCon-2023-Lock-free-Atomic-Shared-Pointers-Without-a-Split-Reference-Count","permalink":"https://hxhue.github.io/cppcon-talks/CppCon-2023-Lock-free-Atomic-Shared-Pointers-Without-a-Split-Reference-Count/","title":"(CppCon 2023) Lock-free Atomic Shared Pointers Without a Split Reference Count","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>(CppCon 2023) Lock-free Atomic Shared Pointers Without a Split Reference Count - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#共享指针是线程安全的吗>共享指针是线程安全的吗？</a></li><li><a href=#为什么有时候希望共享指针本身也能线程安全>为什么有时候希望共享指针本身也能线程安全？</a></li><li><a href=#标准库中对共享指针的原子操作支持>标准库中对共享指针的原子操作支持</a></li><li><a href=#为什么原子共享指针很难实现为无锁>为什么原子共享指针很难实现为无锁？</a></li><li><a href=#方案-1the-split-reference-count>方案 1：The split reference count</a></li><li><a href=#方案-2hazard-pointer风险指针和共享指针结合>方案 2：Hazard pointer（风险指针）和共享指针结合</a></li><li><a href=#补充介绍风险指针>补充：介绍风险指针</a></li><li><a href=#阅读代码>阅读代码</a></li><li><a href=#思考>思考</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cppcon-talks/CppCon-2023-Lock-free-Atomic-Shared-Pointers-Without-a-Split-Reference-Count/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="(CppCon 2023) Lock-free Atomic Shared Pointers Without a Split Reference Count"><meta itemprop=description content="https://youtu.be/lNPZV9Iqo3U?si=lS1hf2ND4SS-6ELB by Daniel Anderson
幻灯片链接： https://raw.githubusercontent.com/CppCon/CppCon2023/main/Presentations/lock_free_atomic_shared_ptr_cppcon2023.pptx
共享指针是线程安全的吗？

std::shared_ptr 的控制块是线程安全的（其实也就是析构是线程安全的， https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2 中有 “Note that the control block of a shared_ptr is thread-safe&mldr;” 这句话），但是："></span><header class=post-header><h1 class=post-title itemprop="name headline">(CppCon 2023) Lock-free Atomic Shared Pointers Without a Split Reference Count</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-05 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-03-05 00:00:00 +0800 CST">2024-03-05
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-01-31T00:00:00+08:00 itemprop=dateModified datetime=2025-01-31T00:00:00+08:00>2025-01-31</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cppcon itemprop=url rel=index><span itemprop=name>cppcon</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>3361</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>7分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><p><a href="https://youtu.be/lNPZV9Iqo3U?si=lS1hf2ND4SS-6ELB" title="https://youtu.be/lNPZV9Iqo3U?si=lS1hf2ND4SS-6ELB" rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://youtu.be/lNPZV9Iqo3U?si=lS1hf2ND4SS-6ELB<i class="fa fa-external-link-alt"></i></a> by Daniel Anderson</p><p>幻灯片链接： <a href=https://raw.githubusercontent.com/CppCon/CppCon2023/main/Presentations/lock_free_atomic_shared_ptr_cppcon2023.pptx title=https://raw.githubusercontent.com/CppCon/CppCon2023/main/Presentations/lock_free_atomic_shared_ptr_cppcon2023.pptx rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://raw.githubusercontent.com/CppCon/CppCon2023/main/Presentations/lock_free_atomic_shared_ptr_cppcon2023.pptx<i class="fa fa-external-link-alt"></i></a></p><h1 id=共享指针是线程安全的吗>共享指针是线程安全的吗？
<a class=header-anchor href=#%e5%85%b1%e4%ba%ab%e6%8c%87%e9%92%88%e6%98%af%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e5%90%97></a></h1><p><code>std::shared_ptr</code> 的控制块是线程安全的（其实也就是析构是线程安全的， <a href=https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2 title=https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2<i class="fa fa-external-link-alt"></i></a> 中有 “<em>Note that the control block of a <code>shared_ptr</code> is thread-safe&mldr;</em>” 这句话），但是：</p><ol><li>对它指向的对象的访问不是线程安全的。</li><li>对它本身的读写不是线程安全的。</li></ol><p>这个 lecture 主要考虑第 2 点。</p><p>Daniel 提到了一种情况：<u>如果一个共享指针正在被析构导致引用计数归零（比如给某个共享指针赋值为一个另一对象的共享指针），此时另外一个线程正复制这个共享指针</u>，则可能会出现内存安全问题。这其实是在两个线程中未做保护地对同一个共享指针读写。大多数情况下，我们可以在线程创建的时候将共享指针拷贝给另外一个线程，避免使用同一个实例。</p><h1 id=为什么有时候希望共享指针本身也能线程安全>为什么有时候希望共享指针本身也能线程安全？
<a class=header-anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9c%89%e6%97%b6%e5%80%99%e5%b8%8c%e6%9c%9b%e5%85%b1%e4%ba%ab%e6%8c%87%e9%92%88%e6%9c%ac%e8%ba%ab%e4%b9%9f%e8%83%bd%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8></a></h1><p>有些时候我们仍然希望多个线程访问同一个共享指针，而不是共享指针的多份拷贝。<strong>明明只要跨线程正确复制共享指针就能保证共享指针内存管理的安全性，为什么还非要使用共享指针的同一个引用呢</strong>？在无锁编程中，有一个常见场景是用原子操作和链表实现一个无锁的队列 / 栈。这时，多个消费者（以及生产者）就可能会访问相同的链表结点（比如 head）。此时，我们需要能安全地修改指针本身的值。要注意的是：共享指针只是内存管理手段，并不是 lock-free 手段。</p><p>下面是 Daniel 给出的一种无锁栈的一种错误实现，他指出问题是：<code>std::atomic&lt;std::shared_ptr&lt;T>></code> 这个类型并不是 lock-free 的。</p><p><img src=/cppcon-talks/assets/Pasted%20image%2020240828213637.webp width=900></p><h1 id=标准库中对共享指针的原子操作支持>标准库中对共享指针的原子操作支持
<a class=header-anchor href=#%e6%a0%87%e5%87%86%e5%ba%93%e4%b8%ad%e5%af%b9%e5%85%b1%e4%ba%ab%e6%8c%87%e9%92%88%e7%9a%84%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c%e6%94%af%e6%8c%81></a></h1><p>参考
<a href=/cpp-concurrency-in-action/5.1-libstdc++-%E5%AF%B9%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E6%94%AF%E6%8C%81/ title="libstdc++ 对共享指针原子操作的支持">libstdc++ 对共享指针原子操作的支持</a> 这一篇笔记 👀。</p><h1 id=为什么原子共享指针很难实现为无锁>为什么原子共享指针很难实现为无锁？
<a class=header-anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8e%9f%e5%ad%90%e5%85%b1%e4%ba%ab%e6%8c%87%e9%92%88%e5%be%88%e9%9a%be%e5%ae%9e%e7%8e%b0%e4%b8%ba%e6%97%a0%e9%94%81></a></h1><p><img src=/cppcon-talks/assets/Pasted%20image%2020250123213555.webp width=700></p><p>将共享指针拷贝出来需要将其控制块计数加 1，将新的共享指针存储进去需要将旧共享指针的控制块减 1。假设出现了如图所示的情况就会有 use-after-free。为此需要让 load / store 的过程都成为原子的，即<strong>同时加载控制块指针和修改引用计数</strong>，但是引用计数在控制块里面，两者并不独立，因此无锁实现很困难。</p><h1 id=方案-1the-split-reference-count>方案 1：The split reference count
<a class=header-anchor href=#%e6%96%b9%e6%a1%88-1the-split-reference-count></a></h1><p>如果想要在多个线程都可能引用同样的共享指针的情况下安全地给共享指针赋值，就得给共享指针再加一层原子操作。</p><p>首先容易想到、但是不能使用的是 <code>std::atomic&lt;std::shared_ptr&lt;T>></code>，因为这个类型不是无锁的，有造成阻塞的可能。上一节已经说过了。</p><p>然后可以考虑把控制块（control block）的指针和另外一个原子计数变量（记录 load count）合并在一起，形成新的计数控制块（counted control block），再把这个变量放在原子变量中。这个方法叫 split reference count。外部计数即这里的本地计数（这个 speech 中的说法和 C++ 并发实战中的内 / 外计数有差异），外部计数和内部计数的总和才是真正的引用数。</p><p><img src=/cppcon-talks/assets/Pasted%20image%2020240828224242.webp width=400></p><p>这个实现支持了 <code>load()</code> 和 <code>store()</code> 两个操作。给的代码是伪代码。<strong>我感觉他这里的实现像是将对象指针放在了 control_block 里面</strong>。</p><p><img alt=900 src=/cppcon-talks/assets/Pasted%20image%2020250123225421.webp></p><p><code>load()</code> 操作：访问 <code>load()</code> 出来的控制块不安全，所以要先增加外部计数，由外部计数来保护内部的控制块。一旦通过 CAS 将外部计数增加后，就可以安全增加内部计数并构建返回值。最后应该减去一个刚刚增加的外部计数，但是也可能遇到控制块变化的情况，这里的处理留到 <code>store()</code> 操作再说明。</p><p><img src=/cppcon-talks/assets/Pasted%20image%2020250123230132.webp width=900></p><p><code>store()</code> 操作：如果直接减少内部计数的话，那么可能会出现计数归零，然后控制块被回收，<code>load()</code> 就不能安全访问控制块了。因此<strong>需要先把外部计数加到内部计数上来</strong>再减少内部计数（因为旧控制块已经被换出来了，所以外部计数在加到内部计数上之后就被舍弃了，没必要将其置为 0）。如果其他线程正在使用这个控制块，那么这里减少计数之后计数不可能归零，因而控制块不被回收；如果其他线程没读到这个控制块，因为 <code>exchange</code> 操作放了一个新的控制块进去，其他线程不可能再读到旧的控制块了。</p><p><code>load()</code> 操作中减少内部计数：如果在修改外部计数时发现控制块改变了，这说明有 <code>store()</code> 操作在中途发生，本线程刚进来时往外部计数上加的 1 个被 <code>store()</code> 操作加到内部计数上去了。因此，本线程应该去把旧控制块的内部计数减 1。</p><p>这依赖了硬件对 16 字节原子操作的支持（大多数情况下能支持），还有一种替代方式是使用 48 位指针和 16 位计数共用 8 字节空间来保证原子操作的支持（Folly 就是这样做的）。</p><div class="markdown-alert markdown-alert-note"><p class=markdown-alert-title><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>Note</p><p>这里的实现看起来比 C++ 并发实战中实现无锁队列要简单很多，其实还有很多复杂的实现在控制块内部，没有展示出来。</p></div><h1 id=方案-2hazard-pointer风险指针和共享指针结合>方案 2：Hazard pointer（风险指针）和共享指针结合
<a class=header-anchor href=#%e6%96%b9%e6%a1%88-2hazard-pointer%e9%a3%8e%e9%99%a9%e6%8c%87%e9%92%88%e5%92%8c%e5%85%b1%e4%ba%ab%e6%8c%87%e9%92%88%e7%bb%93%e5%90%88></a></h1><p>然后 lecture 的重点是介绍 hazard pointer。Hazard pointer 有一点垃圾回收的性质，它将内存的回收延后以使得内存访问安全。Daniel 将 <code>std::shared_ptr</code> 和 hazard pointer 结合起来实现了原子的共享指针。要理解为什么可以这么做，就要理解方案 1 的 split reference count 中增减 load count 的本质是<strong>延迟回收</strong>。</p><p>回顾刚刚的问题：</p><p><img src=/cppcon-talks/assets/Pasted%20image%2020250123213555.webp width=700></p><p>用 hazard pointer 就能实现延迟回收。</p><p><img src=/cppcon-talks/assets/Pasted%20image%2020250123234006.webp width=800></p><p><img src=/cppcon-talks/assets/Pasted%20image%2020250123234909.webp width=800></p><p>左边代码错误的原因：hazard pointer 只保护了控制块不被释放，但是没有保护控制块里面的计数不归零。如果控制块计数归零，对象指针仍会被清理，而之后对控制块计数加 1 会导致对象诈尸：控制块仍然有效，但是保护的指针成为了野指针。方案 1 没有出现这个问题，是因为它通过增加引用计数连同控制块和内部对象一起保护了 <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。</p><p><img src=/cppcon-talks/assets/Pasted%20image%2020250124094309.webp width=800></p><p>Daniel 用不同的原子共享指针实现无锁栈并给出了 benchmark 的结果，展示了自己的实现性能更优。</p><h1 id=补充介绍风险指针>补充：介绍风险指针
<a class=header-anchor href=#%e8%a1%a5%e5%85%85%e4%bb%8b%e7%bb%8d%e9%a3%8e%e9%99%a9%e6%8c%87%e9%92%88></a></h1><p>使用 hazard pointer 保护对象时，不是靠控制块引用计数归零时删掉对象，而是使用 <code>retire()</code> 方法将指针加入到 retiring 单向链表中，随后适时调用 <code>reclaim()</code> 来清理不再使用的指针。相关实现：Folly 库有 hazard pointer 的实现，C++26 有头文件 <code>&lt;hazard_pointer></code>。还可以参考 <a href=https://sf-zhou.github.io/programming/hazard_pointer.html title=https://sf-zhou.github.io/programming/hazard_pointer.html rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://sf-zhou.github.io/programming/hazard_pointer.html<i class="fa fa-external-link-alt"></i></a> 的讲解。</p><p>这篇讲解也很有用： <a href=http://blog.kongfy.com/2017/02/hazard-pointer/ title=http://blog.kongfy.com/2017/02/hazard-pointer/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>http://blog.kongfy.com/2017/02/hazard-pointer/<i class="fa fa-external-link-alt"></i></a> 。概括来说：</p><ol><li>每个线程都有局部的保护指针列表（正在使用、不希望其他线程删除）和退休指针列表（此线程不再需要了）。</li><li>使用者想要安全使用指针，首先要用 hazard pointer 去保护<strong>装着指针的原子变量</strong>以获得<strong>裸指针值</strong>。保护完成之后再次检查原子变量装的是不是之前保护的指针，如果还是就说明保护成功，可以安全访问指针指向对象的内存。<strong>这就有点像持有了 <code>std::weak_ptr</code>，先尝试获取 <code>std::shared_ptr</code>，成功了再继续操作</strong>。<u>2025 年 1 月 23 日</u>：实际上是告知其他线程这个指针正在被使用，不能清理。</li><li>删除者认为指针不再被需要时，将指针放在自己的退休列表中。之后以某种方式去检查退休列表中想要删除的指针是否在任意一个线程的受保护指针列表中，如果都不在就可以删除这个指针。<u>2025 年 1 月 23 日</u>：C++ 并发实战中是先立即检查指针是否可删除，但是也提出来一些优化手段，比如当队列长度达到 <code>2*num_threads</code> 的时候再去尝试回收，这样可以保证至少可以回收 <code>num_threads</code> 个指针。</li></ol><p>共享指针需要在指针传递时反复修改原子引用计数，以计数值来判断指针是否被需要。Hazard pointer（风险指针）模型通过显式地调用 <code>protect()</code> 方法来告知协作者指针还被需要、不能被回收，使用者若有意回收也需要显式调用 <code>retire()</code>。</p><h1 id=阅读代码>阅读代码
<a class=header-anchor href=#%e9%98%85%e8%af%bb%e4%bb%a3%e7%a0%81></a></h1><p>Daniel 在实现无锁栈时需要用 CAS，但是在 speech 中没有展示 CAS 的实现，这部分代码需要去 <a href=https://github.com/DanielLiamAnderson/atomic_shared_ptr title=他分享的代码仓库 rel="noopener external nofollow noreferrer" target=_blank class=exturl>他分享的代码仓库<i class="fa fa-external-link-alt"></i></a> 查看。这份代码重新实现了共享指针，并实现了与其配套的原子共享指针。</p><p>这个实现里，<strong>共享指针包含的裸指针用虚函数 <code>get_ptr()</code> 获取，这是简化实现的关键点</strong>。该代码为 <code>get_ptr()</code> 提供了两种实现： <a href=https://github.com/DanielLiamAnderson/atomic_shared_ptr/blob/3c213ef8a437b419171f901e640ddfdd6056d905/include/parlay/shared_ptr.hpp#L156 title=将对象直接嵌入控制块 rel="noopener external nofollow noreferrer" target=_blank class=exturl>将<strong>对象</strong>直接嵌入控制块<i class="fa fa-external-link-alt"></i></a>（原地存放）或 <a href=https://github.com/DanielLiamAnderson/atomic_shared_ptr/blob/3c213ef8a437b419171f901e640ddfdd6056d905/include/parlay/shared_ptr.hpp#L258 title=将对象指针嵌入控制块 rel="noopener external nofollow noreferrer" target=_blank class=exturl>将<strong>对象指针</strong>嵌入控制块<i class="fa fa-external-link-alt"></i></a>，分别对应了 <code>std::make_shared</code> 和 <code>shared_ptr::shared_ptr</code>。设计虚函数 <code>get_ptr()</code> 的好处：</p><ol start=4><li>CAS 只需要考虑对一个原子控制块的指针做原子化的访问控制，用 <code>std::atomic&lt;T*></code> 即可，不需要硬件的 CX16 支持。</li><li>只要拿到控制块就能拿到共享指针的全部信息，不需要再去获取对象指针。</li></ol><p>为了<strong>保证解引用的高效</strong>，和 <code>std::shared_ptr</code> 一样，Daniel 的实现也是胖指针。尽管能通过控制块访问内部对象，<code>parlay::smart_ptr_base</code>（共享指针的基类）中仍有控制块指针和对象指针两部分。</p><h1 id=思考>思考
<a class=header-anchor href=#%e6%80%9d%e8%80%83></a></h1><p>原子共享指针固然是好的抽象（用户无需关心内存的回收），使得很多无锁算法的实现变得简单，但是能直接用 hazard pointer 的地方（比如无锁栈 / 队列）套一层原子共享指针会不会降低效率？有没有什么原子共享指针能做到但是冒险指针做不到的事情？</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>libstdc++ 共享指针内部有两个计数，一个是 <code>#shared</code>（强引用计数），一个是 <code>#weak + (#shared != 0)</code>，强引用计数归零就可以删除内部对象（如果使用 <code>std::make_shared</code> 分配空间，控制块和对象会紧靠在一起，此时内部对象只析构不删除），强弱引用计数同时归零才能删除控制块。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><div class=post-tags><a href=/tags/cpp>cpp
</a><a href=/tags/cppcon>cppcon</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/cppcon-talks/CppCon-2018-105-STL-Algorithms-in-Less-Than-an-Hour/ rel=next title="(CppCon 2018) 105 STL Algorithms in Less Than an Hour"><i class="fa fa-chevron-left"></i> (CppCon 2018) 105 STL Algorithms in Less Than an Hour</a></div><div class="post-nav-prev post-nav-item"></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>