<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="📌 非自动变量初始化"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content="cpp,inside-the-cpp-object-model"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"%E9%9D%9E%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96","permalink":"https://hxhue.github.io/inside-the-cpp-object-model/%E9%9D%9E%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/","title":"📌 非自动变量初始化","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>📌 非自动变量初始化 - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#c-和-c-thread_local-的区别>C++ 和 C <code>thread_local</code> 的区别</a></li><li><a href=#从代价上来看-c-的几种变量初始化>从代价上来看 C++ 的几种变量初始化</a></li><li><a href=#全局-和-static-变量>全局 (和 static) 变量</a><ul><li><a href=#不支持非常量初始化表达式c-模型>不支持非常量初始化表达式（C 模型）</a></li><li><a href=#支持非常量初始化表达式但只对对象生效cfront-10-模型><del>支持非常量初始化表达式，但只对对象生效</del>（Cfront 1.0 模型）</a></li><li><a href=#所有类型支持非常量初始化表达式现在的-c-模型>所有类型支持非常量初始化表达式（现在的 C++ 模型）</a><ul><li><a href=#gpt-对于书中说法的解释>GPT 对于书中说法的解释</a></li></ul></li></ul></li><li><a href=#局部-static-变量>局部 static 变量</a></li><li><a href=#全局--局部-thread_local-变量>全局 / 局部 thread_local 变量</a><ul><li><a href=#c11-thread_local>C++11 thread_local</a></li><li><a href=#c11-_thread_local>C11 _Thread_local</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/inside-the-cpp-object-model/%E9%9D%9E%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="📌 非自动变量初始化"><meta itemprop=description content="C++ 和 C thread_local 的区别


C++ 支持使用非常量表达式对全局或静态变量初始化 1。对于 static local 2 / thread_local 变量而言，这项功能需要在访问前检查变量是否已经完成初始化，thread_local 初始化不需要线程间同步，而 static local 变量的访问过程需要线程间的同步（__cxa_guard_acquire 和 __cxa_guard_release）。
C++ 的 thread_local 变量在函数作用域中自动具有 static 属性 3，而 C 要手动加。在 C 语言中，函数中的 thread_local 必须和 extern 或者 static 之一一起使用，例子为 https://godbolt.org/z/eKz71xh7a 。
C 的 thread_local 在 C23 之前是个宏。

从代价上来看 C++ 的几种变量初始化


首先，不需要函数初始化的在编译期间就能完成工作，没有代价。所以以下讨论的都是通过函数或构造函数来初始化的变量。
其次，函数内 (static) thread_local 变量只需要在使用前检查一下，构造和使用都不用同步，代价很小。函数内 static 变量的构造和使用则需要线程之间同步。
函数外定义的普通变量和 thread_local 变量都不需要任何同步就能在静态初始化阶段完成初始化，使用时也不需要检查。
函数外定义的 inline 变量（C++17）在使用时不需要同步，但是在初始化的时候要检查是否已经初始化完成（为此有个 guard variable 标记）。见 https://godbolt.org/z/hYMjdbsxj ，这可能是因为 inline 变量可能被多个地方使用，每个地方都要提防重复初始化。

全局 (和 static) 变量

最外围定义域定义的变量，可以具有 static 属性也可以没有。"></span><header class=post-header><h1 class=post-title itemprop="name headline">📌 非自动变量初始化</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-03-18T00:00:00+08:00 itemprop=dateModified datetime=2025-03-18T00:00:00+08:00>2025-03-18</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/inside-the-cpp-object-model itemprop=url rel=index><span itemprop=name>inside-the-cpp-object-model</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>2547</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>6分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=c-和-c-thread_local-的区别>C++ 和 C <code>thread_local</code> 的区别
<a class=header-anchor href=#c-%e5%92%8c-c-thread_local-%e7%9a%84%e5%8c%ba%e5%88%ab></a></h1><ol><li>C++ 支持使用非常量表达式对全局或静态变量初始化 <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。对于 <code>static</code> local <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> / <code>thread_local</code> 变量而言，这项功能需要在访问前检查变量是否已经完成初始化，<strong><code>thread_local</code> 初始化不需要线程间同步，而 <code>static</code> local 变量的访问过程需要线程间的同步（<code>__cxa_guard_acquire</code> 和 <code>__cxa_guard_release</code>）</strong>。</li><li>C++ 的 <code>thread_local</code> 变量<strong>在函数作用域中</strong>自动具有 <code>static</code> 属性 <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>，而 C 要手动加。在 C 语言中，函数中的 <code>thread_local</code> 必须和 <code>extern</code> 或者 <code>static</code> 之一一起使用，例子为 <a href=https://godbolt.org/z/eKz71xh7a title=https://godbolt.org/z/eKz71xh7a rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://godbolt.org/z/eKz71xh7a<i class="fa fa-external-link-alt"></i></a> 。</li><li>C 的 <code>thread_local</code> 在 C23 之前是个宏。</li></ol><h1 id=从代价上来看-c-的几种变量初始化>从代价上来看 C++ 的几种变量初始化
<a class=header-anchor href=#%e4%bb%8e%e4%bb%a3%e4%bb%b7%e4%b8%8a%e6%9d%a5%e7%9c%8b-c-%e7%9a%84%e5%87%a0%e7%a7%8d%e5%8f%98%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96></a></h1><ul><li>首先，不需要函数初始化的在编译期间就能完成工作，没有代价。<strong>所以以下讨论的都是通过函数或构造函数来初始化的变量</strong>。</li><li>其次，函数内 (static) thread_local 变量只需要在使用前检查一下，构造和使用都不用同步，代价很小。函数内 static 变量的构造和使用则需要线程之间同步。</li><li>函数外定义的普通变量和 thread_local 变量都不需要任何同步就能在静态初始化阶段完成初始化，使用时也不需要检查。</li><li>函数外定义的 inline 变量（C++17）在使用时不需要同步，但是在初始化的时候要检查是否已经初始化完成（为此有个 guard variable 标记）。见 <a href=https://godbolt.org/z/hYMjdbsxj title=https://godbolt.org/z/hYMjdbsxj rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://godbolt.org/z/hYMjdbsxj<i class="fa fa-external-link-alt"></i></a> ，这可能是因为 inline 变量可能被多个地方使用，每个地方都要提防重复初始化。</li></ul><h1 id=全局-和-static-变量>全局 (和 static) 变量
<a class=header-anchor href=#%e5%85%a8%e5%b1%80-%e5%92%8c-static-%e5%8f%98%e9%87%8f></a></h1><p>最外围定义域定义的变量，可以具有 static 属性也可以没有。</p><h2 id=不支持非常量初始化表达式c-模型>不支持非常量初始化表达式（C 模型）
<a class=header-anchor href=#%e4%b8%8d%e6%94%af%e6%8c%81%e9%9d%9e%e5%b8%b8%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96%e8%a1%a8%e8%be%be%e5%bc%8fc-%e6%a8%a1%e5%9e%8b></a></h2><p>编译器会抱怨：initializer element is not constant。</p><h2 id=支持非常量初始化表达式但只对对象生效cfront-10-模型><del>支持非常量初始化表达式，但只对对象生效</del>（Cfront 1.0 模型）
<a class=header-anchor href=#%e6%94%af%e6%8c%81%e9%9d%9e%e5%b8%b8%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96%e8%a1%a8%e8%be%be%e5%bc%8f%e4%bd%86%e5%8f%aa%e5%af%b9%e5%af%b9%e8%b1%a1%e7%94%9f%e6%95%88cfront-10-%e6%a8%a1%e5%9e%8b></a></h2><p>在用户程序真正运行前插入一段<strong>静态变量初始化代码。</strong></p><p>Cfront 早期对 class object 支持了<strong>非常量的静态初始化</strong>，但<strong>标准类型</strong>（整数、指针等）的静态支持和 C 一样。</p><p><img src=/assets/dd4139cc4c1f5af8a382e9708ca348b5.webp></p><p>考虑下面的代码：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>struct</span> <span style=color:#268bd2>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>double</span> x;
</span></span><span style=display:flex><span>    <span style=color:#dc322f>double</span> y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>struct</span> <span style=color:#268bd2>Point</span> point <span style=color:#719e07>=</span> {<span style=color:#2aa198>2.4</span>, <span style=color:#2aa198>0.1</span>};
</span></span></code></pre></div><p>此代码是合法的 C 或 C++ 代码。它的数据值直接写到 data section 里，不需要静态初始化代码（也就是不需要用非常量表达式对变量初始化）。</p><p>修改这段代码之后就不能作为 C 语言编译了，但是可以作为 C++ 编译：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>struct</span> <span style=color:#268bd2>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>double</span> x;
</span></span><span style=display:flex><span>    <span style=color:#dc322f>double</span> y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>struct</span> <span style=color:#268bd2>Point</span> point <span style=color:#719e07>=</span> {<span style=color:#2aa198>2.4</span>, <span style=color:#2aa198>0.1</span>};
</span></span><span style=display:flex><span><span style=color:#719e07>struct</span> <span style=color:#268bd2>Point</span> another_point <span style=color:#719e07>=</span> point;
</span></span></code></pre></div><p>初始化 <code>another_point</code> 需要用到 <code>point</code>，这产生了全局变量之间的依赖关系，在编译器看来不是常量表达式，所以这个过程会被放到<strong>静态变量初始化代码</strong>中进行。</p><h2 id=所有类型支持非常量初始化表达式现在的-c-模型>所有类型支持非常量初始化表达式（现在的 C++ 模型）
<a class=header-anchor href=#%e6%89%80%e6%9c%89%e7%b1%bb%e5%9e%8b%e6%94%af%e6%8c%81%e9%9d%9e%e5%b8%b8%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96%e8%a1%a8%e8%be%be%e5%bc%8f%e7%8e%b0%e5%9c%a8%e7%9a%84-c-%e6%a8%a1%e5%9e%8b></a></h2><p>后来 C++ 对所有类型都支持非常量静态初始化了。这可能是支持虚基类的副产品，因为虚基类和子类之间的指针转换需要知道 offset，而 offset 只能在编译全部完成之后才能确定。</p><p>可以参考：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>Base</span> {};
</span></span><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>VirtualBase</span><span style=color:#719e07>:</span> <span style=color:#719e07>public</span> <span style=color:#719e07>virtual</span> Base {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// 不需要静态初始化代码
</span></span></span><span style=display:flex><span><span style=color:#586e75>// Base *pbase = (Base *)0x1000;
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#586e75>// 从 VirtualBase* 转换成 Base*，需要静态初始化代码
</span></span></span><span style=display:flex><span><span style=color:#586e75>// 如果把虚继承改成具体继承，也不再会需要静态初始化代码
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>Base <span style=color:#719e07>*</span>pbase2 <span style=color:#719e07>=</span> (VirtualBase <span style=color:#719e07>*</span>)<span style=color:#2aa198>0x1000</span>;
</span></span></code></pre></div><h3 id=gpt-对于书中说法的解释>GPT 对于书中说法的解释
<a class=header-anchor href=#gpt-%e5%af%b9%e4%ba%8e%e4%b9%a6%e4%b8%ad%e8%af%b4%e6%b3%95%e7%9a%84%e8%a7%a3%e9%87%8a></a></h3><p>Consider the following example:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>Base</span> {};
</span></span><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>VirtualBase</span><span style=color:#719e07>:</span> <span style=color:#719e07>public</span> <span style=color:#719e07>virtual</span> Base {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>Derived1</span><span style=color:#719e07>:</span> <span style=color:#719e07>public</span> VirtualBase {};
</span></span><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>Derived2</span><span style=color:#719e07>:</span> <span style=color:#719e07>public</span> VirtualBase {};
</span></span></code></pre></div><p>In this example, we have two separate derived classes, <strong><code>Derived1</code></strong> and <strong><code>Derived2</code></strong>, both inheriting from the same virtual base class <strong><code>VirtualBase</code></strong>.</p><p>Now, when the compiler encounters the definition of <strong><code>Derived1</code></strong> or <strong><code>Derived2</code></strong> in a given translation unit, it doesn&rsquo;t have information about other derived classes. As a result, the exact offset of the <strong><code>VirtualBase</code></strong> subobject within <strong><code>Derived1</code></strong> or <strong><code>Derived2</code></strong> cannot be determined at that point.</p><p>To handle this situation, the compiler employs static initialization. It generates code that initializes static variables associated with the virtual base class. These static variables store the offset information needed to access the virtual base class subobject. The initialization of these static variables happens at runtime before any objects of the derived classes are created.</p><p>By utilizing static initialization, the compiler ensures that the correct offset information is available at runtime, allowing proper access to the virtual base class subobject.</p><h1 id=局部-static-变量>局部 static 变量
<a class=header-anchor href=#%e5%b1%80%e9%83%a8-static-%e5%8f%98%e9%87%8f></a></h1><p>这里只讨论 C++，C 没有非常量初始化的功能。</p><p>C++ 保证函数中的静态对象只在其对应函数被调用时初始化，而且仅初始化一次。如果是常量初始化表达式，则在编译时可以初始化，函数中也不需要同步措施；<strong>但如果是非常量初始化表达式，则有同步代价！</strong></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;cstdio&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#719e07>struct</span> <span style=color:#268bd2>Echo</span> {
</span></span><span style=display:flex><span>    Echo(<span style=color:#719e07>const</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>s) {
</span></span><span style=display:flex><span>        puts(s);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#719e07>static</span> Echo <span style=color:#719e07>*</span>static_member;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// 初始化只能放到这里，如果放到上面 Echo 就不是完整对象不能创建
</span></span></span><span style=display:flex><span><span style=color:#586e75>// 前面声明不能加 inline 因为 inline 会让声明变成定义
</span></span></span><span style=display:flex><span><span style=color:#586e75>// 此处定义不能加 static 因为不能多次指定存储类型
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>inline</span> Echo <span style=color:#719e07>*</span>Echo<span style=color:#719e07>::</span>static_member <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Echo {<span style=color:#2aa198>&#34;Echo::static_member&#34;</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>test_echo</span>() {
</span></span><span style=display:flex><span>    <span style=color:#719e07>static</span> Echo hidden(<span style=color:#2aa198>&#34;local static&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Echo <span style=color:#268bd2>global_echo</span>(<span style=color:#2aa198>&#34;global&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#719e07>static</span> Echo <span style=color:#268bd2>static_echo</span>(<span style=color:#2aa198>&#34;static echo&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>struct</span> <span style=color:#268bd2>Foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#719e07>static</span> <span style=color:#268bd2>inline</span> Echo <span style=color:#719e07>*</span>static_member <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Echo {<span style=color:#2aa198>&#34;Foo::static_member&#34;</span>};
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 试试调用 0/1/2 次
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    test_echo();
</span></span><span style=display:flex><span>    test_echo();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>打印结果：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>Echo::static_member
</span></span><span style=display:flex><span>global
</span></span><span style=display:flex><span>static echo
</span></span><span style=display:flex><span>Foo::static_member
</span></span><span style=display:flex><span>local static
</span></span></code></pre></div><p>上面的代码中如果注释掉 main 函数中的两次调用，则 <code>hidden("local static")</code> 不会被初始化！看下面的汇编代码，有了同步措施后复杂了不少：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#268bd2>test_echo</span>():
</span></span><span style=display:flex><span>        <span style=color:#268bd2>push</span>    <span style=color:#b58900>rbp</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>rbp</span>, <span style=color:#b58900>rsp</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>push</span>    <span style=color:#268bd2>r12</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>push</span>    <span style=color:#b58900>rbx</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>movzx</span>   <span style=color:#b58900>eax</span>, <span style=color:#dc322f>BYTE</span> <span style=color:#268bd2>PTR</span> <span style=color:#268bd2>guard</span> <span style=color:#268bd2>variable</span> <span style=color:#268bd2>for</span> <span style=color:#268bd2>test_echo</span>()::<span style=color:#268bd2>hidden</span>[<span style=color:#268bd2>rip</span>]
</span></span><span style=display:flex><span>        <span style=color:#268bd2>test</span>    <span style=color:#b58900>al</span>, <span style=color:#b58900>al</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>sete</span>    <span style=color:#b58900>al</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>test</span>    <span style=color:#b58900>al</span>, <span style=color:#b58900>al</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>je</span>      <span style=color:#268bd2>.L7</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>edi</span>, <span style=color:#268bd2>OFFSET</span> <span style=color:#268bd2>FLAT</span>:<span style=color:#268bd2>guard</span> <span style=color:#268bd2>variable</span> <span style=color:#268bd2>for</span> <span style=color:#268bd2>test_echo</span>()::<span style=color:#268bd2>hidden</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>call</span>    <span style=color:#268bd2>__cxa_guard_acquire</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>test</span>    <span style=color:#b58900>eax</span>, <span style=color:#b58900>eax</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>setne</span>   <span style=color:#b58900>al</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>test</span>    <span style=color:#b58900>al</span>, <span style=color:#b58900>al</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>je</span>      <span style=color:#268bd2>.L7</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>r12d</span>, <span style=color:#2aa198>0</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>esi</span>, <span style=color:#268bd2>OFFSET</span> <span style=color:#268bd2>FLAT</span>:<span style=color:#268bd2>.LC0</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>edi</span>, <span style=color:#268bd2>OFFSET</span> <span style=color:#268bd2>FLAT</span>:<span style=color:#268bd2>_ZZ9test_echovE6hidden</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>call</span>    <span style=color:#268bd2>Echo</span>::<span style=color:#268bd2>Echo</span>(<span style=color:#b58900>ch</span><span style=color:#268bd2>ar</span> <span style=color:#268bd2>const</span><span style=color:#719e07>*</span>) [<span style=color:#268bd2>complete</span> <span style=color:#268bd2>object</span> <span style=color:#268bd2>constructor</span>]
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>edi</span>, <span style=color:#268bd2>OFFSET</span> <span style=color:#268bd2>FLAT</span>:<span style=color:#268bd2>guard</span> <span style=color:#268bd2>variable</span> <span style=color:#268bd2>for</span> <span style=color:#268bd2>test_echo</span>()::<span style=color:#268bd2>hidden</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>call</span>    <span style=color:#268bd2>__cxa_guard_release</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>jmp</span>     <span style=color:#268bd2>.L7</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>rbx</span>, <span style=color:#b58900>rax</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>test</span>    <span style=color:#b58900>r12b</span>, <span style=color:#b58900>r12b</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>jne</span>     <span style=color:#268bd2>.L5</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>edi</span>, <span style=color:#268bd2>OFFSET</span> <span style=color:#268bd2>FLAT</span>:<span style=color:#268bd2>guard</span> <span style=color:#268bd2>variable</span> <span style=color:#268bd2>for</span> <span style=color:#268bd2>test_echo</span>()::<span style=color:#268bd2>hidden</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>call</span>    <span style=color:#268bd2>__cxa_guard_abort</span>
</span></span><span style=display:flex><span>.L5:
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>rax</span>, <span style=color:#b58900>rbx</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>rdi</span>, <span style=color:#b58900>rax</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>call</span>    <span style=color:#268bd2>_Unwind_Resume</span>
</span></span><span style=display:flex><span>.L7:
</span></span><span style=display:flex><span>        <span style=color:#268bd2>nop</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>pop</span>     <span style=color:#b58900>rbx</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>pop</span>     <span style=color:#268bd2>r12</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>pop</span>     <span style=color:#b58900>rbp</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>ret</span>
</span></span></code></pre></div><h1 id=全局--局部-thread_local-变量>全局 / 局部 thread_local 变量
<a class=header-anchor href=#%e5%85%a8%e5%b1%80--%e5%b1%80%e9%83%a8-thread_local-%e5%8f%98%e9%87%8f></a></h1><h2 id=c11-thread_local>C++11 thread_local
<a class=header-anchor href=#c11-thread_local></a></h2><p>访问变量需要使用一个<strong>和线程相关的段寄存器</strong>和固定的变量偏移得到变量的地址，这样不同线程访问的变量地址肯定不同。</p><p>对于全局的 <code>thread_local</code> 变量，每次访问 <code>thread_local</code> 变量 <code>i</code> 会先调用 <code>TLS wrapper function for i</code>，然后该函数调用 <code>TLS init function for i</code>（在 Compiler Explorer 过滤的汇编中是 <code>__tls_init</code>）确保变量只被初始化一次，最后返回变量的<strong>地址</strong>。</p><p><a href=https://godbolt.org/z/Y8a7s4Msz title=https://godbolt.org/z/Y8a7s4Msz rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://godbolt.org/z/Y8a7s4Msz<i class="fa fa-external-link-alt"></i></a></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;iostream&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;thread&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#719e07>thread_local</span> <span style=color:#dc322f>int</span> i <span style=color:#719e07>=</span> time(<span style=color:#2aa198>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    i <span style=color:#719e07>=</span> <span style=color:#2aa198>7</span>;
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span><span style=color:#268bd2>thread</span> t{[<span style=color:#719e07>&amp;</span>](){ i <span style=color:#719e07>=</span> <span style=color:#2aa198>9</span>; }};
</span></span><span style=display:flex><span>    t.join();
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> i <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#34;</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对于局部的 thread_local 变量：</p><p><a href=https://godbolt.org/z/xdePfv3eM title=https://godbolt.org/z/xdePfv3eM rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://godbolt.org/z/xdePfv3eM<i class="fa fa-external-link-alt"></i></a></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;iostream&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;thread&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#586e75>// 因为 main 入口肯定只有一个，所以尝试把 thread_local 放到其他函数中试试
</span></span></span><span style=display:flex><span><span style=color:#586e75>// 实际上和把 thread_local 变量放在 main 中的效果一样
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#dc322f>int</span> <span style=color:#719e07>&amp;</span>get_i() {
</span></span><span style=display:flex><span>    <span style=color:#719e07>thread_local</span> <span style=color:#dc322f>int</span> i <span style=color:#719e07>=</span> time(<span style=color:#2aa198>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> i;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    get_i() <span style=color:#719e07>=</span> <span style=color:#2aa198>7</span>;
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span><span style=color:#268bd2>thread</span> t{[<span style=color:#719e07>&amp;</span>](){ get_i() <span style=color:#719e07>=</span> <span style=color:#2aa198>9</span>; }};
</span></span><span style=display:flex><span>    t.join();
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> get_i() <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#34;</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>get_i()</code> 中也有确保变量仅仅初始化一次的逻辑。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#268bd2>get_i</span>()::<span style=color:#268bd2>i</span>:
</span></span><span style=display:flex><span>        <span style=color:#268bd2>.zero</span>   <span style=color:#2aa198>4</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>guard</span> <span style=color:#268bd2>variable</span> <span style=color:#268bd2>for</span> <span style=color:#268bd2>get_i</span>()::<span style=color:#268bd2>i</span>:
</span></span><span style=display:flex><span>        <span style=color:#268bd2>.zero</span>   <span style=color:#2aa198>8</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>get_i</span>():
</span></span><span style=display:flex><span>        <span style=color:#268bd2>push</span>    <span style=color:#b58900>rbp</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>rbp</span>, <span style=color:#b58900>rsp</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>rax</span>, <span style=color:#dc322f>QWORD</span> <span style=color:#268bd2>PTR</span> <span style=color:#b58900>fs</span>:<span style=color:#2aa198>0</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>add</span>     <span style=color:#b58900>rax</span>, <span style=color:#268bd2>OFFSET</span> <span style=color:#268bd2>FLAT</span>:<span style=color:#268bd2>guard</span> <span style=color:#268bd2>variable</span> <span style=color:#268bd2>for</span> <span style=color:#268bd2>get_i</span>()::<span style=color:#268bd2>i@tpoff</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>movzx</span>   <span style=color:#b58900>eax</span>, <span style=color:#dc322f>BYTE</span> <span style=color:#268bd2>PTR</span> [<span style=color:#b58900>rax</span>]
</span></span><span style=display:flex><span>        <span style=color:#268bd2>test</span>    <span style=color:#b58900>al</span>, <span style=color:#b58900>al</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>jne</span>     <span style=color:#268bd2>.L11</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>edi</span>, <span style=color:#2aa198>0</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>call</span>    <span style=color:#268bd2>time</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#dc322f>DWORD</span> <span style=color:#268bd2>PTR</span> <span style=color:#b58900>fs</span>:<span style=color:#268bd2>get_i</span>()::<span style=color:#268bd2>i@tpoff</span>, <span style=color:#b58900>eax</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>rax</span>, <span style=color:#dc322f>QWORD</span> <span style=color:#268bd2>PTR</span> <span style=color:#b58900>fs</span>:<span style=color:#2aa198>0</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>add</span>     <span style=color:#b58900>rax</span>, <span style=color:#268bd2>OFFSET</span> <span style=color:#268bd2>FLAT</span>:<span style=color:#268bd2>guard</span> <span style=color:#268bd2>variable</span> <span style=color:#268bd2>for</span> <span style=color:#268bd2>get_i</span>()::<span style=color:#268bd2>i@tpoff</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#dc322f>BYTE</span> <span style=color:#268bd2>PTR</span> [<span style=color:#b58900>rax</span>], <span style=color:#2aa198>1</span>
</span></span><span style=display:flex><span>.L11:
</span></span><span style=display:flex><span>        <span style=color:#268bd2>mov</span>     <span style=color:#b58900>rax</span>, <span style=color:#dc322f>QWORD</span> <span style=color:#268bd2>PTR</span> <span style=color:#b58900>fs</span>:<span style=color:#2aa198>0</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>add</span>     <span style=color:#b58900>rax</span>, <span style=color:#268bd2>OFFSET</span> <span style=color:#268bd2>FLAT</span>:<span style=color:#268bd2>get_i</span>()::<span style=color:#268bd2>i@tpoff</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>pop</span>     <span style=color:#b58900>rbp</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>ret</span>
</span></span></code></pre></div><p>所以，全局和局部的 <code>thread_local</code> 变量访问的代价是一样的。只不过如果 <code>thread_local</code> 是局部的，<strong>检查是否需要初始化</strong>的逻辑就直接放在函数中；如果是全局的，这个逻辑用一个生成的函数实现而已。<code>thread_local static</code> 和 <code>static</code> 局部变量相比，</p><p>接下来尝试把 <code>time(0)</code> 这种初始化表达式换成一个常量，比如说 2，则访问 <code>thread_local</code> 时不会有同步措施，只是创建线程的时候要复制一份变量而已。</p><h2 id=c11-_thread_local>C11 _Thread_local
<a class=header-anchor href=#c11-_thread_local></a></h2><p>C11 的头文件 threads.h 中有下面定义：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#define thread_local _Thread_local
</span></span></span></code></pre></div><p>这就和以前的 <code>bool</code> 宏需要引入一样。在 C23 之后，<code>thread_local</code> 就是一个单独的关键字了。</p><p>C11 的 <code>thread_local</code> 是不具备 <code>static</code> 属性的，在函数中使用时要用 <code>thread_local static</code>，而 C++ 中的 <code>thread_local</code> 在函数中自动具备 <code>static</code> 属性，加不加 <code>static</code> 都行。</p><p>C++ 标准：</p><blockquote><p>When thread_local is applied to a variable of block scope the storage-class-specifier static <strong>is implied</strong> if it does not appear explicitly.</p></blockquote><p>2023 年 6 月 15 日：C11 的 threads.h 在 Windows 上没有实现，而且也没有提供像 C++ 的 mutex 一样的同步功能，写 C 语言用线程还是 pthreads.h / Win32 API 会比较好一点。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>像 C 一样用常量表达式初始化就不会有访问开销。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Static local 指的是在函数作用域中被 <code>static</code> 修饰的局部变量。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>对于全局变量来说，无论是 C++ 还是 C，<code>static</code> 和 <code>thread_local</code> 是正交的，<code>static</code> 表示是否对外链接，<code>thread_local</code> 表示是否线程本地。&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><div class=post-tags><a href=/tags/cpp>cpp
</a><a href=/tags/inside-the-cpp-object-model>inside-the-cpp-object-model</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/inside-the-cpp-object-model/vtable/ rel=next title="📌 vtable"><i class="fa fa-chevron-left"></i> 📌 vtable</a></div><div class="post-nav-prev post-nav-item"><a href=/inside-the-cpp-object-model/Cfront-%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/ rel=prev title="Cfront 如何插入构造函数">Cfront 如何插入构造函数
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>