<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on Bluegill</title><link>https://hxhue.github.io/tags/docker/</link><description>Recent content in Docker on Bluegill</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sat, 26 Apr 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://hxhue.github.io/tags/docker/rss.xml" rel="self" type="application/rss+xml"/><item><title>添加用户到 docker 组</title><link>https://hxhue.github.io/posts/cli/docker/%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%88%B0-docker-%E7%BB%84/</link><pubDate>Sun, 13 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%88%B0-docker-%E7%BB%84/</guid><description>&lt;p>通过 &lt;code>sudo usermod -aG docker xx&lt;/code> 把 xx 加到 docker 组之后，需要先退出当前登录才能生效。&lt;/p></description></item><item><title>Docker 升级之后 docker-compose 无法正常启动使用 GPU 的容器</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E5%8D%87%E7%BA%A7%E4%B9%8B%E5%90%8E-docker-compose-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8%E4%BD%BF%E7%94%A8-GPU-%E7%9A%84%E5%AE%B9%E5%99%A8/</link><pubDate>Sat, 21 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E5%8D%87%E7%BA%A7%E4%B9%8B%E5%90%8E-docker-compose-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8%E4%BD%BF%E7%94%A8-GPU-%E7%9A%84%E5%AE%B9%E5%99%A8/</guid><description>&lt;h1 id="解决-docker-compose-启动的容器无法使用-gpu">解决 docker-compose 启动的容器无法使用 GPU
&lt;a class="header-anchor" href="#%e8%a7%a3%e5%86%b3-docker-compose-%e5%90%af%e5%8a%a8%e7%9a%84%e5%ae%b9%e5%99%a8%e6%97%a0%e6%b3%95%e4%bd%bf%e7%94%a8-gpu">&lt;/a>
&lt;/h1>&lt;p>最近有人升级了服务器的 docker，我们创建容器有点问题。症状是这样：在命令行用 &lt;code>--gpus all&lt;/code> 参数启动的都能正常使用 GPU（可以通过运行 &lt;code>nvidia-smi&lt;/code> 命令测试），但是在 docker-compose.yml 文件中指定要使用 GPU 就不行。&lt;/p></description></item><item><title>Docker 的 seccomp 选项</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E7%9A%84-seccomp-%E9%80%89%E9%A1%B9/</link><pubDate>Sun, 08 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E7%9A%84-seccomp-%E9%80%89%E9%A1%B9/</guid><description>&lt;p>&lt;a href="https://docs.docker.com/engine/security/seccomp/" title="https://docs.docker.com/engine/security/seccomp/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://docs.docker.com/engine/security/seccomp/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>&lt;code>seccomp&lt;/code> 选项可以控制容器内可以执行的系统调用。可以用 &lt;code>--security-opt seccomp=/path/to/seccomp/profile.json&lt;/code>，也可以用 &lt;code>--security-opt seccomp=unconfined&lt;/code> 表示不受限。&lt;/p></description></item><item><title>以 zstd 压缩方式导出镜像</title><link>https://hxhue.github.io/posts/cli/docker/%E4%BB%A5-zstd-%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F%E5%AF%BC%E5%87%BA%E9%95%9C%E5%83%8F/</link><pubDate>Wed, 12 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/%E4%BB%A5-zstd-%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F%E5%AF%BC%E5%87%BA%E9%95%9C%E5%83%8F/</guid><description>&lt;h1 id="步骤">步骤
&lt;a class="header-anchor" href="#%e6%ad%a5%e9%aa%a4">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker save image:tag | zstd -o image.tar.zst
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>docker save&lt;/code> 是将镜像输出到标准输出流，&lt;code>docker save -o&lt;/code> 是将输出写入到文件。&lt;/li>
&lt;li>&lt;code>zstd -o&lt;/code> 是将压缩数据写入文件，而 &lt;code>zstd -c&lt;/code> 是将压缩的数据输出到标准输出流。&lt;/li>
&lt;/ul>
&lt;h1 id="为什么用-zstd-而不是-gzip-来压缩">为什么用 zstd 而不是 gzip 来压缩
&lt;a class="header-anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%94%a8-zstd-%e8%80%8c%e4%b8%8d%e6%98%af-gzip-%e6%9d%a5%e5%8e%8b%e7%bc%a9">&lt;/a>
&lt;/h1>&lt;ol>
&lt;li>zstd 在 ubuntu/debian 中有现成的包可以下载，安装非常轻松。&lt;/li>
&lt;li>压缩速度非常快，压缩比可以接受。&lt;/li>
&lt;li>&lt;strong>我的使用场景&lt;/strong>是在服务器之间传输文件，带宽很高，所以不想花太多时间在压缩和解压上。&lt;/li>
&lt;/ol></description></item><item><title>我们实验室的服务器曾如何处理 Docker 数据转移的问题？</title><link>https://hxhue.github.io/posts/systems/Linux/%E6%88%91%E4%BB%AC%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%BE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-Docker-%E6%95%B0%E6%8D%AE%E8%BD%AC%E7%A7%BB%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 15 May 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E6%88%91%E4%BB%AC%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%BE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-Docker-%E6%95%B0%E6%8D%AE%E8%BD%AC%E7%A7%BB%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="修改配置文件">修改配置文件
&lt;a class="header-anchor" href="#%e4%bf%ae%e6%94%b9%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6">&lt;/a>
&lt;/h1>&lt;p>网上一般推荐的做法是这种： &lt;a href="https://linuxiac.com/how-to-change-docker-data-directory/" title="https://linuxiac.com/how-to-change-docker-data-directory/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://linuxiac.com/how-to-change-docker-data-directory/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>修改 /etc/docker/daemon.json，向其中加入：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#268bd2">&amp;#34;data-root&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;/new/docker/root&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者在 systemd 的服务启动程序中指定数据的路径。&lt;/p></description></item><item><title>Docker 更改地址段</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E6%9B%B4%E6%94%B9%E5%9C%B0%E5%9D%80%E6%AE%B5/</link><pubDate>Wed, 17 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E6%9B%B4%E6%94%B9%E5%9C%B0%E5%9D%80%E6%AE%B5/</guid><description>&lt;h1 id="先说解决方案">先说解决方案
&lt;a class="header-anchor" href="#%e5%85%88%e8%af%b4%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88">&lt;/a>
&lt;/h1>&lt;p>参考 &lt;a href="https://stackoverflow.com/a/73287366/" title="Networking problems with WSL2 and Docker Desktop for windows" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Networking problems with WSL2 and Docker Desktop for windows&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>，编辑 /etc/docker/daemon.json，加入 &lt;code>&amp;quot;bip&amp;quot;: &amp;quot;192.168.200.1/24&amp;quot;&lt;/code>（根据实际情况替换），然后 &lt;code>systemctl&lt;/code> 重载配置、重启 Docker 一通操作后用 &lt;code>ip route&lt;/code> 和 &lt;code>ifconfig&lt;/code> 验证一下变化。&lt;/p></description></item><item><title>Docker 配置镜像源</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E6%BA%90/</link><pubDate>Tue, 09 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E6%BA%90/</guid><description>&lt;h1 id="资源">资源
&lt;a class="header-anchor" href="#%e8%b5%84%e6%ba%90">&lt;/a>
&lt;/h1>&lt;p>可用 Docker Hub 镜像加速器列表见 &lt;a href="https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6" title="Docker Hub 镜像加速器" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Docker Hub 镜像加速器&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>。&lt;/p>
&lt;h1 id="修改方式">修改方式
&lt;a class="header-anchor" href="#%e4%bf%ae%e6%94%b9%e6%96%b9%e5%bc%8f">&lt;/a>
&lt;/h1>&lt;p>网络上有不少教程是先修改 /etc/docker/daemon.json，然后：&lt;/p></description></item><item><title>Docker attach 之后不能退出</title><link>https://hxhue.github.io/posts/cli/docker/Docker-attach-%E4%B9%8B%E5%90%8E%E4%B8%8D%E8%83%BD%E9%80%80%E5%87%BA/</link><pubDate>Sat, 16 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-attach-%E4%B9%8B%E5%90%8E%E4%B8%8D%E8%83%BD%E9%80%80%E5%87%BA/</guid><description>&lt;p>Docker 不能用 &lt;kbd>CTRL&lt;/kbd> + &lt;kbd>p&lt;/kbd>，&lt;kbd>CTRL&lt;/kbd> + &lt;kbd>q&lt;/kbd> 退出的解决方案：登录后先用 &lt;code>tty&lt;/code> 看自己的终端。然后用另外一个连接 &lt;code>ps -af&lt;/code> 看想要终止的 &lt;code>docker&lt;/code> 命令的 pid 是多少，然后用 &lt;code>kill -9&lt;/code> 强杀。因为杀的是客户端而不是守护进程，所以不需要担心其他正在运行的容器受到影响。&lt;/p></description></item><item><title>Docker 查询和管理</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%AE%A1%E7%90%86/</link><pubDate>Sat, 16 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%AE%A1%E7%90%86/</guid><description>&lt;h1 id="查看所有容器的资源占用">查看所有容器的资源占用
&lt;a class="header-anchor" href="#%e6%9f%a5%e7%9c%8b%e6%89%80%e6%9c%89%e5%ae%b9%e5%99%a8%e7%9a%84%e8%b5%84%e6%ba%90%e5%8d%a0%e7%94%a8">&lt;/a>
&lt;/h1>&lt;p>&lt;code>docker stats&lt;/code> 可以实时刷新所有容器的占用情况。用 &lt;code>docker stats --no-stream&lt;/code> 只看最近一次，而不像 &lt;code>top&lt;/code> 一样刷新。不知道哪个容器占用多的时候可以使用这个命令。&lt;/p>
&lt;h1 id="找到进程属于哪一个容器">找到进程属于哪一个容器
&lt;a class="header-anchor" href="#%e6%89%be%e5%88%b0%e8%bf%9b%e7%a8%8b%e5%b1%9e%e4%ba%8e%e5%93%aa%e4%b8%80%e4%b8%aa%e5%ae%b9%e5%99%a8">&lt;/a>
&lt;/h1>&lt;p>我们实验室的不同学生使用不同的容器作为开发环境。现在的问题是，当我们从 &lt;code>htop&lt;/code> 或者 &lt;code>top&lt;/code> 中发现某个进程消耗了大量资源时，我们需要确定这个进程是由哪个容器启动的，怎么做呢？&lt;/p></description></item><item><title>创建内网 Overleaf</title><link>https://hxhue.github.io/posts/systems/Linux/%E5%88%9B%E5%BB%BA%E5%86%85%E7%BD%91-Overleaf/</link><pubDate>Thu, 14 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E5%88%9B%E5%BB%BA%E5%86%85%E7%BD%91-Overleaf/</guid><description>&lt;p>有两种方案，推荐第 2 种。&lt;/p>
&lt;h1 id="方案-1docker-compose">方案 1：docker-compose
&lt;a class="header-anchor" href="#%e6%96%b9%e6%a1%88-1docker-compose">&lt;/a>
&lt;/h1>&lt;p>截至 2024 年 3 月 14 日 最新的 docker-compose 文件是 &lt;a href="https://raw.githubusercontent.com/overleaf/overleaf/408e1dccd7c0cb58fe02c5eb9ef983312ad9b244/docker-compose.yml" title="https://raw.githubusercontent.com/overleaf/overleaf/408e1dccd7c0cb58fe02c5eb9ef983312ad9b244/docker-compose.yml" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://raw.githubusercontent.com/overleaf/overleaf/408e1dccd7c0cb58fe02c5eb9ef983312ad9b244/docker-compose.yml&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>首先把 docker-compose 配置文件下载下来修改好 sharelatex 的端口、sharelatex/redis/mongo 的映射路径。&lt;/p></description></item><item><title>限制 Docker 容器使用的 CPU</title><link>https://hxhue.github.io/posts/cli/docker/%E9%99%90%E5%88%B6-Docker-%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84-CPU/</link><pubDate>Tue, 30 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/%E9%99%90%E5%88%B6-Docker-%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84-CPU/</guid><description>&lt;p>在 &lt;code>docker run&lt;/code> 创建容器的时候用 &lt;code>--cpuset-cpus 0-3&lt;/code> 可以限制 CPU 在 0-3 这四个核心上，实测 &lt;code>nproc&lt;/code> 的结果已经改变了。&lt;/p>
&lt;p>在 &lt;code>docker build&lt;/code> 的时候也可以用同样的参数，比如 &lt;code>docker build . --cpuset-cpus 0-3&lt;/code>，这能够被正常识别，但是 &lt;code>nproc&lt;/code> 的结果没有改变，也不知道是否正常限制了。&lt;/p></description></item><item><title>在 Dockerfile 中合并两个目录</title><link>https://hxhue.github.io/posts/cli/docker/%E5%9C%A8-Dockerfile-%E4%B8%AD%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E7%9B%AE%E5%BD%95/</link><pubDate>Sun, 21 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/%E5%9C%A8-Dockerfile-%E4%B8%AD%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E7%9B%AE%E5%BD%95/</guid><description>&lt;p>dockerfile 中合并两个目录：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">COPY&lt;/span> folderA folderB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不要在文件夹后面加 &lt;code>/&lt;/code>。&lt;/p></description></item><item><title>Docker 配置代理</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</guid><description>&lt;h1 id="docker-pull">&lt;code>docker pull&lt;/code>
&lt;a class="header-anchor" href="#docker-pull">&lt;/a>
&lt;/h1>&lt;p>&lt;code>docker pull&lt;/code> 不会读取 &lt;code>http_proxy&lt;/code> 环境变量，因为拉取请求是发给守护进程的（不清楚守护进程是否是经典的 listen-fork 模式），环境变量早就在启动时读入，需要专门配置 docker 守护进程并让它重新加载配置。可以参考： &lt;a href="https://stackoverflow.com/a/71036185" title="https://stackoverflow.com/a/71036185" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/71036185&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p></description></item><item><title>Docker 按容器 A 的启动参数创建新容器 B</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E6%8C%89%E5%AE%B9%E5%99%A8-A-%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E5%88%9B%E5%BB%BA%E6%96%B0%E5%AE%B9%E5%99%A8-B/</link><pubDate>Thu, 30 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E6%8C%89%E5%AE%B9%E5%99%A8-A-%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E5%88%9B%E5%BB%BA%E6%96%B0%E5%AE%B9%E5%99%A8-B/</guid><description>&lt;p>&lt;a href="https://stackoverflow.com/questions/32758793/how-to-show-the-run-command-of-a-docker-container" title="How to show the run command of a docker container - Stack Overflow" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >How to show the run command of a docker container - Stack Overflow&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker inspect --format &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#719e07">$(&lt;/span>curl -s &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> https://gist.githubusercontent.com/efrecon/8ce9c75d518b6eb863f667442d7bc679/raw/run.tpl&lt;span style="color:#719e07">)&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> &lt;span style="color:#719e07">{&lt;/span>your_container&lt;span style="color:#719e07">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>得到的结果样例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --name &lt;span style="color:#2aa198">&amp;#34;/gitlab-runner-4&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --runtime &lt;span style="color:#2aa198">&amp;#34;runc&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --volume &lt;span style="color:#2aa198">&amp;#34;/srv/gitlab-runner/config:/etc/gitlab-runner&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --volume &lt;span style="color:#2aa198">&amp;#34;/var/run/docker.sock:/var/run/docker.sock&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --log-driver &lt;span style="color:#2aa198">&amp;#34;json-file&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --restart &lt;span style="color:#2aa198">&amp;#34;always&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --network &lt;span style="color:#2aa198">&amp;#34;bridge&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --env &lt;span style="color:#2aa198">&amp;#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --detach &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> &lt;span style="color:#2aa198">&amp;#34;gitlab/gitlab-runner:latest&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> &lt;span style="color:#2aa198">&amp;#34;run&amp;#34;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;--user=gitlab-runner&amp;#34;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;--working-directory=/home/gitlab-runner&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还有一种方法是使用 &lt;a href="https://github.com/lavie/runlike" title="https://github.com/lavie/runlike" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://github.com/lavie/runlike&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 提供的 pip 包 &lt;code>runlike&lt;/code>。使用起来也比较方便，但是输出的结果里面有些参数还得再检查和调整一下。&lt;/p></description></item><item><title>Docker GPU 支持</title><link>https://hxhue.github.io/posts/cli/docker/Docker-GPU-%E6%94%AF%E6%8C%81/</link><pubDate>Thu, 02 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-GPU-%E6%94%AF%E6%8C%81/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">distribution&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#719e07">$(&lt;/span>. /etc/os-release; &lt;span style="color:#b58900">echo&lt;/span> &lt;span style="color:#268bd2">$ID$VERSION_ID&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># 如果 debian12 不支持可以改成 debian11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -s -L nvidia.github.io/nvidia-docker/&lt;span style="color:#268bd2">$distribution&lt;/span>/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install -y nvidia-docker2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># 必须重启 docker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl restart docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>