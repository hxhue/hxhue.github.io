<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cppreference on Bluegill</title><link>https://hxhue.github.io/tags/cppreference/</link><description>Recent content in Cppreference on Bluegill</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Tue, 10 Sep 2024 00:00:00 +0800</lastBuildDate><atom:link href="https://hxhue.github.io/tags/cppreference/rss.xml" rel="self" type="application/rss+xml"/><item><title>为什么我不推荐用 enum class 作为强类型的整数？</title><link>https://hxhue.github.io/posts/programming/cpp/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%94%A8-enum-class-%E4%BD%9C%E4%B8%BA%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B4%E6%95%B0/</link><pubDate>Sat, 27 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%94%A8-enum-class-%E4%BD%9C%E4%B8%BA%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B4%E6%95%B0/</guid><description>&lt;h1 id="c11-之后-enum-的新增功能">C++11 之后 enum 的新增功能
&lt;a class="header-anchor" href="#c11-%e4%b9%8b%e5%90%8e-enum-%e7%9a%84%e6%96%b0%e5%a2%9e%e5%8a%9f%e8%83%bd">&lt;/a>
&lt;/h1>&lt;p>enum class 是 C++11 提供的功能，为了更好理解后文的内容，我们先看看 C++11 之后 enum 有什么变化。参考资料见 &lt;a href="https://en.cppreference.com/w/cpp/language/enum" title="https://en.cppreference.com/w/cpp/language/enum" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/language/enum&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 。&lt;/p>
&lt;h2 id="有作用域枚举">有作用域枚举
&lt;a class="header-anchor" href="#%e6%9c%89%e4%bd%9c%e7%94%a8%e5%9f%9f%e6%9e%9a%e4%b8%be">&lt;/a>
&lt;/h2>&lt;p>有作用域枚举（Scoped enumerations）使用 &lt;code>enum class|struct ClassName&lt;/code> 声明，以区别于原来的无作用域枚举。无作用域枚举的枚举量可以直接在外围名字空间中访问，当枚举类有名字且 C++ 版本至少为 C++11 时，可以通过 &lt;code>枚举名::枚举量&lt;/code> 访问；有作用域枚举只能通过 &lt;code>枚举名::枚举量&lt;/code> 访问。&lt;/p></description></item><item><title>language/implicit_conversion 限定性类型转换</title><link>https://hxhue.github.io/posts/programming/cpp/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E6%80%A7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link><pubDate>Sun, 07 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E6%80%A7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid><description>&lt;h1 id="写在前面">写在前面
&lt;a class="header-anchor" href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2">&lt;/a>
&lt;/h1>&lt;p>内容见 &lt;a href="https://en.cppreference.com/w/cpp/language/implicit_conversion" title="implicit conversion" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >implicit conversion&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>。&lt;/p>
&lt;p>限定性转换指的是和 cv 属性有关的类型转换，它的发生必须满足一定的条件。&lt;/p>
&lt;h1 id="相似类型">相似类型
&lt;a class="header-anchor" href="#%e7%9b%b8%e4%bc%bc%e7%b1%bb%e5%9e%8b">&lt;/a>
&lt;/h1>&lt;p>忽略掉各层的 cv 属性，如果两个类型形式相同，就是相似类型。比如 &lt;code>const int* volatile *&lt;/code> 和 &lt;code>int** const&lt;/code>。&lt;/p></description></item><item><title>Copy elision</title><link>https://hxhue.github.io/posts/programming/cpp/Copy-elision/</link><pubDate>Tue, 02 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Copy-elision/</guid><description>&lt;h1 id="参考">参考
&lt;a class="header-anchor" href="#%e5%8f%82%e8%80%83">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>&lt;a href="https://en.cppreference.com/w/cpp/language/copy_elision" title="https://en.cppreference.com/w/cpp/language/copy_elision" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/language/copy_elision&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=PTCFddZfnXc" title="https://www.youtube.com/watch?v=PTCFddZfnXc" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://www.youtube.com/watch?v=PTCFddZfnXc&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 2024 年 6 月 26 日：这个视频讲了 GCC 的新 &lt;code>-Wnrvo&lt;/code> 编译参数。&lt;/li>
&lt;/ul>
&lt;h1 id="c17-prvalue-semantics-guaranteed-copy-elision">C++17 prvalue semantics (&amp;ldquo;guaranteed copy elision&amp;rdquo;)
&lt;a class="header-anchor" href="#c17-prvalue-semantics-guaranteed-copy-elision">&lt;/a>
&lt;/h1>&lt;p>返回值（或函数参数）的位置，如果表达式是纯右值，且返回值（或函数参数）需要的也是同一类型的纯右值，那么标准就要求省略复制和移动。不过，为了让语义检查通过，&lt;strong>要构造对象的析构函数必须在此处可以访问&lt;/strong>，尽管在完成优化之后并不会用到析构函数。&lt;/p></description></item><item><title>C++20 之前向下转换到有符号数无法表示时是实现定义</title><link>https://hxhue.github.io/posts/programming/cpp/C++20-%E4%B9%8B%E5%89%8D%E5%90%91%E4%B8%8B%E8%BD%AC%E6%8D%A2%E5%88%B0%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%97%A0%E6%B3%95%E8%A1%A8%E7%A4%BA%E6%97%B6%E6%98%AF%E5%AE%9E%E7%8E%B0%E5%AE%9A%E4%B9%89/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++20-%E4%B9%8B%E5%89%8D%E5%90%91%E4%B8%8B%E8%BD%AC%E6%8D%A2%E5%88%B0%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%97%A0%E6%B3%95%E8%A1%A8%E7%A4%BA%E6%97%B6%E6%98%AF%E5%AE%9E%E7%8E%B0%E5%AE%9A%E4%B9%89/</guid><description>&lt;h1 id="什么是向下转换">什么是向下转换
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%90%91%e4%b8%8b%e8%bd%ac%e6%8d%a2">&lt;/a>
&lt;/h1>&lt;p>向下转换是可能出现溢出的转换。检查是否为向下转换：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> To, &lt;span style="color:#719e07">typename&lt;/span> From, &lt;span style="color:#719e07">typename&lt;/span> &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#dc322f">void&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">NotNarrowing&lt;/span>&lt;span style="color:#719e07">:&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>false_type {};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> To, &lt;span style="color:#719e07">typename&lt;/span> From&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">NotNarrowing&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>To, From, std&lt;span style="color:#719e07">::&lt;/span>void_t&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">decltype&lt;/span>(To{std&lt;span style="color:#719e07">::&lt;/span>declval&lt;span style="color:#719e07">&amp;lt;&lt;/span>From&lt;span style="color:#719e07">&amp;gt;&lt;/span>()})&lt;span style="color:#719e07">&amp;gt;&amp;gt;:&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>true_type {};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>To{std::declval&amp;lt;From&amp;gt;()}&lt;/code> 这一步如果用在具体的类型上（比如说 int 和 unsigned），编译器是只给警告，不会报错。如果能够在编译期推导出来数值，则会根据数值来选择通过或报错。比如 &lt;code>char{'a'};&lt;/code> 是正常编译的，但是 &lt;code>char{300};&lt;/code> 是会报错的。&lt;/p></description></item></channel></rss>