<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on Bluegill</title><link>https://hxhue.github.io/tags/c/</link><description>Recent content in C on Bluegill</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Tue, 18 Mar 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://hxhue.github.io/tags/c/rss.xml" rel="self" type="application/rss+xml"/><item><title>为什么用 tar.gz 安装的共享库 gcc 找不到？</title><link>https://hxhue.github.io/posts/systems/Linux/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-tar.gz-%E5%AE%89%E8%A3%85%E7%9A%84%E5%85%B1%E4%BA%AB%E5%BA%93-gcc-%E6%89%BE%E4%B8%8D%E5%88%B0/</link><pubDate>Fri, 28 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-tar.gz-%E5%AE%89%E8%A3%85%E7%9A%84%E5%85%B1%E4%BA%AB%E5%BA%93-gcc-%E6%89%BE%E4%B8%8D%E5%88%B0/</guid><description>&lt;h1 id="情况">情况
&lt;a class="header-anchor" href="#%e6%83%85%e5%86%b5">&lt;/a>
&lt;/h1>&lt;p>项目是由 CMake 构建的动态库，用 CPack 我们打包得到了一个 deb 包版本和一个 tar.gz 的压缩包版本。前者安装之后 demo 能够正常编译运行，但是在换用压缩包安装共享库后编译 demo 则出现了找不到库的错误（这里讨论的是非标准路径的情况，即安装路径不在 &lt;code>/&lt;/code>、&lt;code>/usr&lt;/code> 和 &lt;code>/usr/local&lt;/code> 下）。&lt;/p></description></item><item><title>模除运算</title><link>https://hxhue.github.io/posts/programming/cpp/%E6%A8%A1%E9%99%A4%E8%BF%90%E7%AE%97/</link><pubDate>Sun, 16 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E6%A8%A1%E9%99%A4%E8%BF%90%E7%AE%97/</guid><description>&lt;p>C++ 中两数相除（假设被除数和除数都不是 0），同号则结果为正，异号则结果为负。模除运算则定义为：&lt;/p>
&lt;blockquote>
 &lt;p>If $a~/~b$ is representable in the result type, $(a~/~b)*b + a~\%~b == a$.（来自 &lt;a href="https://en.cppreference.com/w/cpp/language/operator_arithmetic" title="https://en.cppreference.com/w/cpp/language/operator_arithmetic" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/language/operator_arithmetic&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> ）&lt;/p>
&lt;/blockquote>&lt;p>实践起来则是：在被除数不是 0 的情况下，模除运算的结果总是和除数同正负。&lt;/p></description></item><item><title>UNIX 中 printf 指定参数绑定顺序</title><link>https://hxhue.github.io/posts/programming/cpp/UNIX-%E4%B8%AD-printf-%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E9%A1%BA%E5%BA%8F/</link><pubDate>Thu, 16 May 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/UNIX-%E4%B8%AD-printf-%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E9%A1%BA%E5%BA%8F/</guid><description>&lt;h1 id="unix-中的-printf">UNIX 中的 &lt;code>printf&lt;/code>
&lt;a class="header-anchor" href="#unix-%e4%b8%ad%e7%9a%84-printf">&lt;/a>
&lt;/h1>&lt;p>Single UNIX Specification 中允许 &lt;code>printf&lt;/code> 使用 &lt;code>%m$&lt;/code> 和 &lt;code>*m$&lt;/code> 的形式来绑定第 m 个参数，其中 m 从 1 开始计数。如果使用了这种表达方式，则所有参数都要指定序号，而且不能遗漏参数。这样做的好处是：可以多次使用同一个参数。&lt;/p></description></item><item><title>inline 函数不对外链接？gnu89 和 c99 恐怖的语义对换！</title><link>https://hxhue.github.io/posts/programming/cpp/inline-%E5%87%BD%E6%95%B0%E4%B8%8D%E5%AF%B9%E5%A4%96%E9%93%BE%E6%8E%A5gnu89-%E5%92%8C-c99-%E6%81%90%E6%80%96%E7%9A%84%E8%AF%AD%E4%B9%89%E5%AF%B9%E6%8D%A2/</link><pubDate>Thu, 25 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/inline-%E5%87%BD%E6%95%B0%E4%B8%8D%E5%AF%B9%E5%A4%96%E9%93%BE%E6%8E%A5gnu89-%E5%92%8C-c99-%E6%81%90%E6%80%96%E7%9A%84%E8%AF%AD%E4%B9%89%E5%AF%B9%E6%8D%A2/</guid><description>&lt;h1 id="经过">经过
&lt;a class="header-anchor" href="#%e7%bb%8f%e8%bf%87">&lt;/a>
&lt;/h1>&lt;p>遇到过一个坑：为共享库写函数，但是又需要从头文件隐藏实现时，不要将函数声明为内联。否则编译器会认为它未被使用并忽略它，链接的时候就找不到这个函数。&lt;/p></description></item><item><title>GCC optimize-sibling-calls 的反向优化</title><link>https://hxhue.github.io/compiler-explorer-experiments/2024-04-20-GCC-optimize-sibling-calls-%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%98%E5%8C%96/</link><pubDate>Sat, 20 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/compiler-explorer-experiments/2024-04-20-GCC-optimize-sibling-calls-%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%98%E5%8C%96/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;benchmark/benchmark.h&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>&lt;span style="color:#719e07">static&lt;/span> &lt;span style="color:#268bd2">inline&lt;/span> &lt;span style="color:#719e07">constexpr&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> FIBONACCI_N &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">fib&lt;/span>(&lt;span style="color:#dc322f">int&lt;/span> n) { &lt;span style="color:#719e07">return&lt;/span> n &lt;span style="color:#719e07">&amp;lt;&lt;/span> &lt;span style="color:#2aa198">2&lt;/span> &lt;span style="color:#719e07">?&lt;/span> n : fib(n &lt;span style="color:#719e07">-&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>) &lt;span style="color:#719e07">+&lt;/span> fib(n &lt;span style="color:#719e07">-&lt;/span> &lt;span style="color:#2aa198">2&lt;/span>); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">BM_fib&lt;/span>(benchmark&lt;span style="color:#719e07">::&lt;/span>State &lt;span style="color:#719e07">&amp;amp;&lt;/span>state) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (&lt;span style="color:#719e07">auto&lt;/span> _ : state) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> res &lt;span style="color:#719e07">=&lt;/span> fib(FIBONACCI_N);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> benchmark&lt;span style="color:#719e07">::&lt;/span>DoNotOptimize(res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BENCHMARK(BM_fib);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> x; &lt;span style="color:#586e75">// Magic line.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// clang does not use DP anymore: much slower.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// gcc chooses a different optimizing approach: much faster.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">fib_x&lt;/span>(&lt;span style="color:#dc322f">int&lt;/span> n) { &lt;span style="color:#719e07">return&lt;/span> n &lt;span style="color:#719e07">&amp;lt;&lt;/span> &lt;span style="color:#2aa198">2&lt;/span> &lt;span style="color:#719e07">?&lt;/span> n : fib_x(n &lt;span style="color:#719e07">-&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>) &lt;span style="color:#719e07">+&lt;/span> fib_x(n &lt;span style="color:#719e07">-&lt;/span> &lt;span style="color:#2aa198">2&lt;/span>) &lt;span style="color:#719e07">+&lt;/span> x; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">BM_fib_x&lt;/span>(benchmark&lt;span style="color:#719e07">::&lt;/span>State &lt;span style="color:#719e07">&amp;amp;&lt;/span>state) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (&lt;span style="color:#719e07">auto&lt;/span> _ : state) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> res &lt;span style="color:#719e07">=&lt;/span> fib_x(FIBONACCI_N);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> benchmark&lt;span style="color:#719e07">::&lt;/span>DoNotOptimize(res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BENCHMARK(BM_fib_x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BENCHMARK_MAIN();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译条件：GCC 13.2 -O2 -std=c++17&lt;/p></description></item><item><title>不同编译器如何处理 C 语言函数名？</title><link>https://hxhue.github.io/posts/programming/cpp/%E4%B8%8D%E5%90%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-C-%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%90%8D/</link><pubDate>Sat, 16 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E4%B8%8D%E5%90%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-C-%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%90%8D/</guid><description>&lt;p>&lt;a href="https://godbolt.org/z/YrzsWbMh8" title="https://godbolt.org/z/YrzsWbMh8" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://godbolt.org/z/YrzsWbMh8&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>在以下几种编译器上都尝试了：&lt;/p>
&lt;ol>
&lt;li>x86-64 gcc 13.2&lt;/li>
&lt;li>x86-64 clang 18.1.0&lt;/li>
&lt;li>x64 msvc v19.38&lt;/li>
&lt;li>x86 msvc v19.38&lt;/li>
&lt;/ol>
&lt;p>发现只有 &lt;strong>x86 msvc v19.38&lt;/strong> 给函数名前面加了下划线，其他几种编译器都是尊重函数定义的名字。以前做川合秀实的 30 天自制操作系统时，还以为所有编译器都会固定地给 C 语言函数名前面加上下划线，所以汇编中引用时有一些区别。现在看来只是因为平台不同，所以编译器处理方式也不同。&lt;/p></description></item></channel></rss>