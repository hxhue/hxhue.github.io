<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cpp on Bluegill</title><link>https://hxhue.github.io/tags/cpp/</link><description>Recent content in Cpp on Bluegill</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 14 Sep 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://hxhue.github.io/tags/cpp/rss.xml" rel="self" type="application/rss+xml"/><item><title>libstdc++ 和 libc++ 中字符串倍增比较</title><link>https://hxhue.github.io/posts/programming/cpp/libstdc++-%E5%92%8C-libc++-%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%8D%E5%A2%9E%E6%AF%94%E8%BE%83/</link><pubDate>Sun, 06 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libstdc++-%E5%92%8C-libc++-%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%8D%E5%A2%9E%E6%AF%94%E8%BE%83/</guid><description>&lt;p>&lt;a href="https://godbolt.org/z/n8hns47M8" title="https://godbolt.org/z/n8hns47M8" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://godbolt.org/z/n8hns47M8&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>string str &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;hello&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;String: &lt;/span>&lt;span style="color:#cb4b16">\&amp;#34;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#cb4b16">\&amp;#34;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Length: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str.&lt;span style="color:#268bd2">length&lt;/span>() &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Capacity: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str.&lt;span style="color:#268bd2">capacity&lt;/span>() &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Size: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#719e07">sizeof&lt;/span>(str) &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> str &lt;span style="color:#719e07">+=&lt;/span> &lt;span style="color:#2aa198">&amp;#34; world!。。。。&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">String: &lt;/span>&lt;span style="color:#cb4b16">\&amp;#34;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#cb4b16">\&amp;#34;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Length: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str.&lt;span style="color:#268bd2">length&lt;/span>() &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Capacity: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str.&lt;span style="color:#268bd2">capacity&lt;/span>() &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Size: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#719e07">sizeof&lt;/span>(str) &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> str &lt;span style="color:#719e07">+=&lt;/span> str;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">String: &lt;/span>&lt;span style="color:#cb4b16">\&amp;#34;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#cb4b16">\&amp;#34;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Length: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str.&lt;span style="color:#268bd2">length&lt;/span>() &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Capacity: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str.&lt;span style="color:#268bd2">capacity&lt;/span>() &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Size: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#719e07">sizeof&lt;/span>(str) &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到 libstdc++ 中的 capacity 的增长方式是 15 → 30 → 60。一开始 SSO 缓冲区只能容纳 16 个字符，最后一个字符是 &lt;code>'\0'&lt;/code>，因此初始状态下只能容纳 15 个非空字符，capacity 为 15。而后面倍增的时候会直接按照非 &lt;code>'\0'&lt;/code> 字符的最大容量来做倍增，而非按照实际缓冲区容量做倍增（即 15 → 31 → 63 这样的路径）。&lt;/p></description></item><item><title>C++ 中哪些 STL 类型可以作为 map 或 unordered_map 的键？</title><link>https://hxhue.github.io/posts/programming/cpp/C++-%E4%B8%AD%E5%93%AA%E4%BA%9B-STL-%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA-map-%E6%88%96-unordered_map-%E7%9A%84%E9%94%AE/</link><pubDate>Sat, 22 Feb 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++-%E4%B8%AD%E5%93%AA%E4%BA%9B-STL-%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA-map-%E6%88%96-unordered_map-%E7%9A%84%E9%94%AE/</guid><description>&lt;p>其实是在问哪些类型有 hash 函数和重载了 &lt;code>&amp;lt;&lt;/code> 比较操作符。因为说的是 STL，所以不考虑内建类型。&lt;/p>
&lt;h1 id="可哈希和--比较">可哈希和 &lt;code>==&lt;/code> 比较
&lt;a class="header-anchor" href="#%e5%8f%af%e5%93%88%e5%b8%8c%e5%92%8c--%e6%af%94%e8%be%83">&lt;/a>
&lt;/h1>&lt;p>常见的可以哈希和 &lt;code>==&lt;/code> 比较的集合类型有（以下省略 &lt;code>std&lt;/code> 命名空间）：&lt;/p></description></item><item><title>libstdc++ enable_shared_from_this 源码分析</title><link>https://hxhue.github.io/posts/programming/cpp/libstdc++-enable_shared_from_this-%E6%BA%90%E7%A0%81/</link><pubDate>Fri, 07 Feb 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libstdc++-enable_shared_from_this-%E6%BA%90%E7%A0%81/</guid><description>&lt;p>继承 &lt;code>std::enable_shared_from_this&lt;/code> 模板类之后就多了一个弱指针（&lt;code>_M_weak_this&lt;/code>）。同时还多了一个 &lt;code>__enable_shared_from_this_base&lt;/code> 方法，创建共享指针时该方法能被 ADL 找到，以关联和共享控制块。该方法是私有的，不过 &lt;code>__shared_ptr&amp;lt;typename, typename&amp;gt;&lt;/code> 是友元类，因此能访问它。&lt;/p></description></item><item><title>5.0.2 阅读 libstdc++ 中原子变量 wait 和 notify 接口</title><link>https://hxhue.github.io/cpp-concurrency-in-action/5.0.2-%E9%98%85%E8%AF%BB-libstdc++-%E4%B8%AD%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F-wait-%E5%92%8C-notify-%E6%8E%A5%E5%8F%A3/</link><pubDate>Fri, 24 Jan 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/5.0.2-%E9%98%85%E8%AF%BB-libstdc++-%E4%B8%AD%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F-wait-%E5%92%8C-notify-%E6%8E%A5%E5%8F%A3/</guid><description>&lt;h1 id="wait-和-notify-接口介绍">Wait 和 notify 接口介绍
&lt;a class="header-anchor" href="#wait-%e5%92%8c-notify-%e6%8e%a5%e5%8f%a3%e4%bb%8b%e7%bb%8d">&lt;/a>
&lt;/h1>&lt;p>&lt;code>std::atomic&amp;lt;T&amp;gt;::wait&lt;/code> 用来等待原子变量值的改变，如果原子变量值和给定的参数 old 相同则阻塞，直到被 &lt;code>notify_all()&lt;/code> 或者 &lt;code>notify_one()&lt;/code> 通知，或者&lt;strong>自发地解除阻塞&lt;/strong>。因此用 &lt;code>wait&lt;/code> 要在循环中使用。&lt;/p></description></item><item><title>10. Parallel algorithms</title><link>https://hxhue.github.io/cpp-concurrency-in-action/10.-Parallel-algorithms/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/10.-Parallel-algorithms/</guid><description>&lt;h1 id="执行策略c17">执行策略（C++17）
&lt;a class="header-anchor" href="#%e6%89%a7%e8%a1%8c%e7%ad%96%e7%95%a5c17">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>std::execution::seq
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std::execution::par
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std::execution::par_unseq
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std::execution::unseq (C++20)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它们分别属于以下类型，但是使用的时候不要自己创建类型，应该直接使用标准库中提供的执行策略对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>std::execution::sequenced_policy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std::execution::parallel_policy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std::execution::parallel_unsequenced_policy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std::execution::unsequenced_policy (C++20)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中的并行策略仅仅是允许算法这样做，但不能强制算法按要求做。&lt;/p></description></item><item><title>11. 测试和调试多线程应用</title><link>https://hxhue.github.io/cpp-concurrency-in-action/11.-%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/11.-%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8/</guid><description>&lt;h1 id="unwanted-blocking">Unwanted blocking
&lt;a class="header-anchor" href="#unwanted-blocking">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>Deadlock&lt;/li>
&lt;li>Livelock，和死锁的区别是在循环中积极检查条件，比如自旋锁，线程一直消耗 CPU 但始终无法前进&lt;/li>
&lt;li>Blocking on I/O or other external input，线程在等待一个不定期的、可能永远不会到来的操作&lt;/li>
&lt;/ul>
&lt;h1 id="race-conditions">Race conditions
&lt;a class="header-anchor" href="#race-conditions">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>Data races&lt;/li>
&lt;li>Broken invariants&lt;/li>
&lt;li>Lifetime issues&lt;/li>
&lt;/ul>
&lt;h1 id="code-review">Code review
&lt;a class="header-anchor" href="#code-review">&lt;/a>
&lt;/h1>&lt;ol>
&lt;li>在并发访问下，&lt;strong>哪些数据需要保护&lt;/strong>？&lt;/li>
&lt;li>如何确保数据受到保护？&lt;/li>
&lt;li>此时其他线程可能位于代码的哪个部分？&lt;/li>
&lt;li>当前线程持有哪些互斥锁？&lt;/li>
&lt;li>其他线程可能持有哪些互斥锁？&lt;/li>
&lt;li>在当前线程中执行的操作与在其他线程中执行的操作之间是否存在顺序要求？如何确保这些要求得到满足？&lt;/li>
&lt;li>&lt;strong>当前线程加载的数据是否仍然有效&lt;/strong>？是否可能已被其他线程修改？（比如 CAS、双重校验锁）&lt;/li>
&lt;li>如果假设其他线程可能正在修改数据，这意味着什么？如何确保这种情况永远不会发生？&lt;/li>
&lt;/ol>
&lt;h1 id="testing">Testing
&lt;a class="header-anchor" href="#testing">&lt;/a>
&lt;/h1>&lt;p>书 P345 给出了一些对线程安全队列进行测试的测试点。&lt;/p></description></item><item><title>9. Advanced thread management</title><link>https://hxhue.github.io/cpp-concurrency-in-action/9.-Advanced-thread-management/</link><pubDate>Sat, 18 Jan 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/9.-Advanced-thread-management/</guid><description>&lt;h1 id="线程池">线程池
&lt;a class="header-anchor" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0">&lt;/a>
&lt;/h1>&lt;h2 id="实现可以-submit-任务并获取-future-的线程池">实现可以 submit 任务并获取 future 的线程池
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0%e5%8f%af%e4%bb%a5-submit-%e4%bb%bb%e5%8a%a1%e5%b9%b6%e8%8e%b7%e5%8f%96-future-%e7%9a%84%e7%ba%bf%e7%a8%8b%e6%b1%a0">&lt;/a>
&lt;/h2>&lt;p>有了 &lt;code>std::future&lt;/code> 就能对提交的任务做等待。&lt;/p>
&lt;p>线程池初始化时就创建指定数量的工作线程，每个线程的任务就是在循环中从线程安全队列上获取任务并运行。每个任务的类型是 &lt;code>std::packaged_task&amp;lt;result_type()&amp;gt; task&lt;/code>，每次有工作要提交都会包装到 &lt;code>std::packaged_task&lt;/code>，工作的提交者因而可以获取 &lt;code>std::future&lt;/code>。&lt;/p></description></item><item><title>8. Designing concurrent code</title><link>https://hxhue.github.io/cpp-concurrency-in-action/8.-Designing-concurrent-code/</link><pubDate>Thu, 16 Jan 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/8.-Designing-concurrent-code/</guid><description>&lt;h1 id="false-sharing">False sharing
&lt;a class="header-anchor" href="#false-sharing">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>Cache ping-pong&lt;/li>
&lt;/ul>
&lt;h2 id="stdhardware_destructive_interference_sizehttpsencppreferencecomwcppthreadhardware_destructive_interference_size">&lt;a href="https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size" title="std::hardware_destructive_interference_size" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >&lt;code>std::hardware_destructive_interference_size&lt;/code>&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>
&lt;a class="header-anchor" href="#stdhardware_destructive_interference_sizehttpsencppreferencecomwcppthreadhardware_destructive_interference_size">&lt;/a>
&lt;/h2>&lt;p>还有 &lt;code>std::hardware_constructive_interference_size&lt;/code>。在大多数情况下这两个值相等，而且都等于 cache line 的大小。&lt;/p></description></item><item><title>5.1 libstdc++ 对共享指针原子操作的支持</title><link>https://hxhue.github.io/cpp-concurrency-in-action/5.1-libstdc++-%E5%AF%B9%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E6%94%AF%E6%8C%81/</link><pubDate>Sun, 05 Jan 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/5.1-libstdc++-%E5%AF%B9%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E6%94%AF%E6%8C%81/</guid><description>&lt;h1 id="引言">引言
&lt;a class="header-anchor" href="#%e5%bc%95%e8%a8%80">&lt;/a>
&lt;/h1>&lt;p>这篇笔记是承接 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/cppcon-talks/CppCon-2023-Lock-free-Atomic-Shared-Pointers-Without-a-Split-Reference-Count/" title="CppCon 2023 Lock-free Atomic Shared Pointers Without a Split Reference Count" >CppCon 2023 Lock-free Atomic Shared Pointers Without a Split Reference Count&lt;/a> 和 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/cpp-concurrency-in-action/5.-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E6%A0%87%E5%87%86%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%87%AA%E6%97%8B%E9%94%81/" title="内存模型基础、标准原子类型、自旋锁" >内存模型基础、标准原子类型、自旋锁&lt;/a> 来写的。&lt;/p>
&lt;p>C++20 有 &lt;a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2" title="std::atomic&amp;lt;std::shared_ptr&amp;gt;" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >&lt;code>std::atomic&amp;lt;std::shared_ptr&amp;gt;&lt;/code>&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 和 &lt;a href="https://en.cppreference.com/w/cpp/memory/weak_ptr/atomic2" title="std::atomic&amp;lt;std::weak_ptr&amp;gt;" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >&lt;code>std::atomic&amp;lt;std::weak_ptr&amp;gt;&lt;/code>&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 的偏特化，之前连这两个偏特化都没有，因而会编译错误（&lt;code>std::atomic&lt;/code> requires a trivially copyable type），只能使用对共享指针提供的&lt;strong>原子操作自由函数&lt;/strong>（&lt;code>std::atomic_*&lt;/code>）。但是这样的类型并不是无锁的，可以通过 &lt;code>is_lock_free()&lt;/code> 的返回值看出来，见 &lt;a href="https://godbolt.org/z/b5P84jM9f" title="https://godbolt.org/z/b5P84jM9f" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://godbolt.org/z/b5P84jM9f&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 。根据 Daniel&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> 的幻灯片，MSVC 和 libstdc++ 中这两个类型都是有锁；根据我的查证，libc++ 截至 2025 年 1 月 5 日还没有实现这两个偏特化。&lt;/p></description></item><item><title>7. 设计无锁并发数据结构</title><link>https://hxhue.github.io/cpp-concurrency-in-action/7.-%E8%AE%BE%E8%AE%A1%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Thu, 02 Jan 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/7.-%E8%AE%BE%E8%AE%A1%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>&lt;h1 id="非阻塞数据结构的分类">非阻塞数据结构的分类
&lt;a class="header-anchor" href="#%e9%9d%9e%e9%98%bb%e5%a1%9e%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%9a%84%e5%88%86%e7%b1%bb">&lt;/a>
&lt;/h1>&lt;p>书上给出了一个用 &lt;code>std::atomic_flag&lt;/code> 实现自旋锁的代码片段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">spinlock_mutex&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>atomic_flag flag;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">public&lt;/span>&lt;span style="color:#719e07">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spinlock_mutex() &lt;span style="color:#719e07">:&lt;/span> flag(ATOMIC_FLAG_INIT) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">lock&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">while&lt;/span> (flag.test_and_set(std&lt;span style="color:#719e07">::&lt;/span>memory_order_acquire));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">unlock&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flag.clear(std&lt;span style="color:#719e07">::&lt;/span>memory_order_release);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>自旋锁是一个 nonblocking 的例子（书上认为它没有任何阻塞调用，因此是非阻塞的），但是却不是 lock-free 的。&lt;/p></description></item><item><title>6. 设计基于锁的并发数据结构</title><link>https://hxhue.github.io/cpp-concurrency-in-action/6.-%E8%AE%BE%E8%AE%A1%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Tue, 31 Dec 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/6.-%E8%AE%BE%E8%AE%A1%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>&lt;h1 id="引入部分">引入部分
&lt;a class="header-anchor" href="#%e5%bc%95%e5%85%a5%e9%83%a8%e5%88%86">&lt;/a>
&lt;/h1>&lt;p>设计并发数据结构需要考虑两类问题：&lt;/p>
&lt;ol>
&lt;li>如何保护数据？&lt;/li>
&lt;li>如何实现真正的并发？&lt;/li>
&lt;/ol>
&lt;p>本章实现线程安全的&lt;strong>栈&lt;/strong>（1 个全局互斥量）、&lt;strong>队列&lt;/strong>（2 个全局互斥量，头尾各用一个）、&lt;strong>哈希表&lt;/strong>（每个 slot 一个互斥量）、&lt;strong>链表&lt;/strong>（每个结点一个互斥量）。&lt;/p></description></item><item><title>5.1 原子操作的内存顺序</title><link>https://hxhue.github.io/cpp-concurrency-in-action/5.1-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F/</link><pubDate>Sun, 29 Dec 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/5.1-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F/</guid><description>&lt;h1 id="c-内存模型概念">C++ 内存模型概念
&lt;a class="header-anchor" href="#c-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e6%a6%82%e5%bf%b5">&lt;/a>
&lt;/h1>&lt;p>书上着重介绍了 synchronizes-with 和 happens-with 两个关系（relationship）。&lt;/p>
&lt;h2 id="synchronizes-with">Synchronizes-with
&lt;a class="header-anchor" href="#synchronizes-with">&lt;/a>
&lt;/h2>&lt;blockquote>
 &lt;p>The synchronizes-with relationship is something that you can get only between operations on atomic types.&lt;/p>
&lt;/blockquote>&lt;p>书上还说：一些操作的内部实现会使用原子操作（比如对 mutex 上锁），因此也能达到同步关系，但是同步关系从根本上是由原子操作提供的。&lt;/p></description></item><item><title>GCC7 `std::atomic::is_lock_free` 的变化</title><link>https://hxhue.github.io/cpp-concurrency-in-action/5.0.1-GCC7-std-atomic-is_lock_free-%E7%9A%84%E5%8F%98%E5%8C%96/</link><pubDate>Sun, 29 Dec 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/5.0.1-GCC7-std-atomic-is_lock_free-%E7%9A%84%E5%8F%98%E5%8C%96/</guid><description>&lt;h1 id="gcc7-不再认为-x86-上的-16-字节原子变量无锁">GCC7 不再认为 x86 上的 16 字节原子变量无锁
&lt;a class="header-anchor" href="#gcc7-%e4%b8%8d%e5%86%8d%e8%ae%a4%e4%b8%ba-x86-%e4%b8%8a%e7%9a%84-16-%e5%ad%97%e8%8a%82%e5%8e%9f%e5%ad%90%e5%8f%98%e9%87%8f%e6%97%a0%e9%94%81">&lt;/a>
&lt;/h1>&lt;p>原因：GCC7 开始在 &lt;code>std::atomic&amp;lt;T&amp;gt;::is_always_lock_free&lt;/code> 不满足时会调用 libatomic 的 &lt;code>__atomic_is_lock_free()&lt;/code> 函数，但是 libatomic 对无锁的内涵理解不同。&lt;/p>
&lt;p>&lt;a href="https://godbolt.org/z/nc34E716Y" title="https://godbolt.org/z/nc34E716Y" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://godbolt.org/z/nc34E716Y&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 这里表明 gcc7 处理 &lt;code>is_lock_free&lt;/code> 的行为发生了变化，即便有了 &lt;code>-mcx16&lt;/code> 编译选项，也不认为 16 字节原子变量是无锁的，gcc6 则认为 16 字节原子变量在对齐满足时是无锁的（无论 &lt;code>-mcx16&lt;/code> 标志是否存在）。Clang 则是在有无 &lt;code>-mcx16&lt;/code> 选项时呈现出不同的结果。GitHub 上有个相关的 &lt;a href="https://github.com/msys2/MINGW-packages/issues/13831" title="讨论" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >讨论&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 。简单来说是 gcc7 之后不会直接通过当前编译架构来直接决定一个类型是否无锁（clang 会），而是将这个逻辑转移到对 libatomic 的函数的调用上，而 libatomic 认为 16 字节原子变量在 x86 上不算无锁。&lt;/p></description></item><item><title>5. 内存模型基础、标准原子类型、自旋锁</title><link>https://hxhue.github.io/cpp-concurrency-in-action/5.-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E6%A0%87%E5%87%86%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%87%AA%E6%97%8B%E9%94%81/</link><pubDate>Mon, 09 Dec 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/5.-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E6%A0%87%E5%87%86%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%87%AA%E6%97%8B%E9%94%81/</guid><description>&lt;h1 id="内存模型基础对象和-内存位置httpsencppreferencecomwcpplanguagememory_modelmemory_location">内存模型基础：对象和 &lt;a href="https://en.cppreference.com/w/cpp/language/memory_model#Memory_location" title="内存位置" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >内存位置&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>
&lt;a class="header-anchor" href="#%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e5%9f%ba%e7%a1%80%e5%af%b9%e8%b1%a1%e5%92%8c-%e5%86%85%e5%ad%98%e4%bd%8d%e7%bd%aehttpsencppreferencecomwcpplanguagememory_modelmemory_location">&lt;/a>
&lt;/h1>&lt;p>书上给出了 4 点：&lt;/p>
&lt;ol>
&lt;li>每个变量都是对象，包括对象中的成员。&lt;/li>
&lt;li>每个对象有至少一个内存位置。&lt;/li>
&lt;li>每个基本类型（&lt;code>int&lt;/code> / &lt;code>char&lt;/code>, &amp;hellip;）刚好占用一个内存位置。&lt;/li>
&lt;li>连续位域是同一个内存位置的一部分。&lt;/li>
&lt;/ol>
&lt;p>一个标量类型，或者非 0 宽的连续位域构成一个 memory location。&lt;/p></description></item><item><title>How to call "friends" properly?</title><link>https://hxhue.github.io/posts/programming/cpp/How-to-call-friends-properly/</link><pubDate>Sun, 17 Nov 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/How-to-call-friends-properly/</guid><description>&lt;h1 id="开头">开头
&lt;a class="header-anchor" href="#%e5%bc%80%e5%a4%b4">&lt;/a>
&lt;/h1>&lt;p>有一天看到类似这样的代码（隐藏了业务逻辑，对函数签名进行了简化）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">Foo&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">friend&lt;/span> Foo &lt;span style="color:#268bd2">max&lt;/span>(Foo a, Foo b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Foo &lt;span style="color:#268bd2">max&lt;/span>(Foo a, Foo b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#2aa198">&amp;#34;friend max&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Foo &lt;span style="color:#268bd2">max&lt;/span>(Foo a, Foo b, &lt;span style="color:#dc322f">int&lt;/span> x &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#2aa198">&amp;#34;global max&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>(&lt;span style="color:#dc322f">int&lt;/span> argc, &lt;span style="color:#dc322f">char&lt;/span> &lt;span style="color:#719e07">**&lt;/span>argv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Foo a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Foo b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Foo c &lt;span style="color:#719e07">=&lt;/span> max(a, b); &lt;span style="color:#586e75">// ambiguous
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>很明显无法编译：&lt;/p></description></item><item><title>在 VS Code 中从 C++ 调试 pybind</title><link>https://hxhue.github.io/posts/programming/python/%E5%9C%A8-VS-Code-%E4%B8%AD%E4%BB%8E-C++-%E8%B0%83%E8%AF%95-pybind/</link><pubDate>Tue, 05 Nov 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/%E5%9C%A8-VS-Code-%E4%B8%AD%E4%BB%8E-C++-%E8%B0%83%E8%AF%95-pybind/</guid><description>&lt;h1 id="使用-debugpy-调试">使用 debugpy 调试
&lt;a class="header-anchor" href="#%e4%bd%bf%e7%94%a8-debugpy-%e8%b0%83%e8%af%95">&lt;/a>
&lt;/h1>&lt;p>在被 C++ 调用的 python 文件中加上这样的内容（端口可以随便选）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> debugpy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>debugpy&lt;span style="color:#719e07">.&lt;/span>listen(&lt;span style="color:#2aa198">5678&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>debugpy&lt;span style="color:#719e07">.&lt;/span>wait_for_client()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样在第一次加载这个 python 模块的时候，这行代码就会暂停等待调试器连接。我们可以创建这样的 Python 调试配置，随后连接正在监听端口的 python 程序。&lt;/p></description></item><item><title>用特定的 CUDA 版本构建 PyTorch</title><link>https://hxhue.github.io/posts/programming/python/%E7%94%A8%E7%89%B9%E5%AE%9A%E7%9A%84-CUDA-%E7%89%88%E6%9C%AC%E6%9E%84%E5%BB%BA-PyTorch-%E5%B9%B6%E6%89%93%E5%8C%85-Conda-%E7%8E%AF%E5%A2%83/</link><pubDate>Tue, 15 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/%E7%94%A8%E7%89%B9%E5%AE%9A%E7%9A%84-CUDA-%E7%89%88%E6%9C%AC%E6%9E%84%E5%BB%BA-PyTorch-%E5%B9%B6%E6%89%93%E5%8C%85-Conda-%E7%8E%AF%E5%A2%83/</guid><description>&lt;h1 id="说明">说明
&lt;a class="header-anchor" href="#%e8%af%b4%e6%98%8e">&lt;/a>
&lt;/h1>&lt;p>文章是按照我解决问题的过程来写的，不是一个一步式的教程，所以显得有点凌乱。如果要操作请务必先看完全文，以免跟着中间过程走了同样的弯路。&lt;strong>如果不想看前面的内容可以直接跳到 conda 打包这一节&lt;/strong>。&lt;/p></description></item><item><title>在 C++ 项目中使用 Pybind11</title><link>https://hxhue.github.io/posts/programming/cpp/%E5%9C%A8-C++-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Pybind11/</link><pubDate>Fri, 11 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E5%9C%A8-C++-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Pybind11/</guid><description>&lt;p>安装 pybind11：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install &lt;span style="color:#2aa198">&amp;#39;pybind11[global]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># add your executable
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#b58900">set&lt;/span>(&lt;span style="color:#2aa198">PYTHON_EXECUTABLE&lt;/span> &lt;span style="color:#2aa198">/opt/miniforge3/bin/python&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">find_package&lt;/span>(&lt;span style="color:#2aa198">pybind11&lt;/span> &lt;span style="color:#2aa198">REQUIRED&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">target_link_libraries&lt;/span>(&lt;span style="color:#2aa198">your_executable&lt;/span> &lt;span style="color:#2aa198">PRIVATE&lt;/span> &lt;span style="color:#2aa198">pybind11::pybind11&lt;/span> &lt;span style="color:#2aa198">pybind11::embed&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>设置 &lt;code>PYTHON_EXECUTABLE&lt;/code> 可以确保 pybind11 使用正确的 python 版本，这样才能在里面找到你安装好的其他的包。&lt;/p></description></item><item><title>4. Synchronizing concurrent operations</title><link>https://hxhue.github.io/cpp-concurrency-in-action/4.-Synchronizing-concurrent-operations/</link><pubDate>Wed, 02 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/4.-Synchronizing-concurrent-operations/</guid><description>&lt;p>这一章主要讲线程之间的同步和信息传递，包括条件变量（condition variable）、futures、latches/barries。&lt;/p>
&lt;h1 id="条件变量">条件变量
&lt;a class="header-anchor" href="#%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f">&lt;/a>
&lt;/h1>&lt;p>头文件是 &lt;code>&amp;lt;condition_variable&amp;gt;&lt;/code>。包含 &lt;code>std::condition_variable&lt;/code> 和 &lt;code>std::condition_variable_any&lt;/code>。前者只能在 &lt;code>std::mutex&lt;/code> 上使用，后者可以在所有满足 BasicLockable（&lt;code>lock()&lt;/code> + &lt;code>unlock()&lt;/code>，不需要 &lt;code>try_lock()&lt;/code>）的类型上使用。如果只需要使用 &lt;code>std::mutex&lt;/code>，那么就用前者，开销可能会比后者小一点。&lt;/p></description></item><item><title>3. Sharing data between threads</title><link>https://hxhue.github.io/cpp-concurrency-in-action/3.-Sharing-data-between-threads/</link><pubDate>Sun, 29 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/3.-Sharing-data-between-threads/</guid><description>&lt;h1 id="三种避免竞争情况的办法">三种避免竞争情况的办法
&lt;a class="header-anchor" href="#%e4%b8%89%e7%a7%8d%e9%81%bf%e5%85%8d%e7%ab%9e%e4%ba%89%e6%83%85%e5%86%b5%e7%9a%84%e5%8a%9e%e6%b3%95">&lt;/a>
&lt;/h1>&lt;ol>
&lt;li>上锁。&lt;/li>
&lt;li>无锁编程。通常通过修改数据结构和 invariants（数据结构要保持的约束）来完成。&lt;/li>
&lt;li>事务（software transactional memory, STM）。&lt;/li>
&lt;/ol>
&lt;h1 id="使用互斥量保护临界区">使用互斥量保护临界区
&lt;a class="header-anchor" href="#%e4%bd%bf%e7%94%a8%e4%ba%92%e6%96%a5%e9%87%8f%e4%bf%9d%e6%8a%a4%e4%b8%b4%e7%95%8c%e5%8c%ba">&lt;/a>
&lt;/h1>&lt;p>&lt;code>std::lock_guard&lt;/code>（可以用 CTAD）和 &lt;code>std::mutex&lt;/code> API。C++11 除了 &lt;code>std::mutex&lt;/code> 之外还有 &lt;code>std::timed_mutex&lt;/code>、&lt;code>std::recursive_mutex&lt;/code>、&lt;code>std::recursive_timed_mutex&lt;/code>。&lt;/p></description></item><item><title>C++ 结构化绑定过程</title><link>https://hxhue.github.io/posts/programming/cpp/C++-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B/</link><pubDate>Wed, 18 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B/</guid><description>&lt;h1 id="起因">起因
&lt;a class="header-anchor" href="#%e8%b5%b7%e5%9b%a0">&lt;/a>
&lt;/h1>&lt;p>同学给出如下代码，指出 &lt;code>std::forward_as_tuple()&lt;/code> 的返回值不能被 &lt;code>auto&lt;/code> 结构化绑定：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;tuple&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> t1 &lt;span style="color:#719e07">=&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>tuple{&lt;span style="color:#2aa198">0&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> [a0] &lt;span style="color:#719e07">=&lt;/span> t1; &lt;span style="color:#586e75">// ok
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">auto&lt;/span> t2 &lt;span style="color:#719e07">=&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>forward_as_tuple(&lt;span style="color:#2aa198">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> [a1] &lt;span style="color:#719e07">=&lt;/span> t2; &lt;span style="color:#586e75">// error
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改代码尝试了几次发现，&lt;code>t2&lt;/code> 只是不能被 &lt;code>auto&lt;/code> 结构化绑定，可以被 &lt;code>auto &amp;amp;&lt;/code> 和 &lt;code>auto &amp;amp;&amp;amp;&lt;/code>（万能引用）结构化绑定。查阅资料得知 &lt;code>std::forward_as_tuple()&lt;/code> 返回的 &lt;code>std::tuple&lt;/code> 的参数类型都是完美转发后的类型，&lt;code>t2&lt;/code> 的类型是 &lt;code>std::tuple&amp;lt;int &amp;amp;&amp;amp;&amp;gt;&lt;/code> 而不是 &lt;code>std::tuple&amp;lt;int&amp;gt;&lt;/code>。&lt;/p></description></item><item><title>简易的计时函数</title><link>https://hxhue.github.io/posts/programming/cpp/%E7%AE%80%E6%98%93%E7%9A%84%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0/</link><pubDate>Wed, 18 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E7%AE%80%E6%98%93%E7%9A%84%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> F&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> timed_execute(std&lt;span style="color:#719e07">::&lt;/span>string_view tag, F &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span>f) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> start &lt;span style="color:#719e07">=&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>chrono&lt;span style="color:#719e07">::&lt;/span>steady_clock&lt;span style="color:#719e07">::&lt;/span>now();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> end &lt;span style="color:#719e07">=&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>chrono&lt;span style="color:#719e07">::&lt;/span>steady_clock&lt;span style="color:#719e07">::&lt;/span>now();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> ns &lt;span style="color:#719e07">=&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>chrono&lt;span style="color:#719e07">::&lt;/span>duration_cast&lt;span style="color:#719e07">&amp;lt;&lt;/span>std&lt;span style="color:#719e07">::&lt;/span>chrono&lt;span style="color:#719e07">::&lt;/span>nanoseconds&lt;span style="color:#719e07">&amp;gt;&lt;/span>(end &lt;span style="color:#719e07">-&lt;/span> start).count();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>printf(&lt;span style="color:#2aa198">&amp;#34;%-20s: &amp;#34;&lt;/span>, tag.data());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ns &lt;span style="color:#719e07">&amp;gt;=&lt;/span> &lt;span style="color:#2aa198">1e6&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>printf(&lt;span style="color:#2aa198">&amp;#34;%.1fms&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>, ns &lt;span style="color:#719e07">/&lt;/span> &lt;span style="color:#2aa198">1e6&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#268bd2">if&lt;/span> (ns &lt;span style="color:#719e07">&amp;gt;=&lt;/span> &lt;span style="color:#2aa198">1e3&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>printf(&lt;span style="color:#2aa198">&amp;#34;%.1fus&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>, ns &lt;span style="color:#719e07">/&lt;/span> &lt;span style="color:#2aa198">1e3&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>printf(&lt;span style="color:#2aa198">&amp;#34;%zdns&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>, ns);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>timed_execute(&lt;span style="color:#2aa198">&amp;#34;reduce&amp;#34;&lt;/span>, [&lt;span style="color:#719e07">&amp;amp;&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> result &lt;span style="color:#719e07">=&lt;/span> reduce(v.begin(), v.end(), &lt;span style="color:#2aa198">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2024 年 10 月 2 日：其实 duration 的 &lt;code>count()&lt;/code> 不一定非得是整数。参考 &lt;a href="https://en.cppreference.com/w/cpp/chrono/duration" title="https://en.cppreference.com/w/cpp/chrono/duration" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/chrono/duration&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> ，可以自己定义数据类型为浮点数的 ratio（通用单位，在 &lt;code>std::chrono&lt;/code> 中自然就表示时间单位，比如 &lt;code>std::milli&lt;/code> 表示 1e-3 这个比例，而 &lt;code>std::chrono::milliseconds&lt;/code> 真正表示毫秒这个时间段）。例子：&lt;/p></description></item><item><title>2. Managing threads</title><link>https://hxhue.github.io/cpp-concurrency-in-action/2.-Managing-threads/</link><pubDate>Sat, 14 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-concurrency-in-action/2.-Managing-threads/</guid><description>&lt;h1 id="22-向线程传递参数">2.2 向线程传递参数
&lt;a class="header-anchor" href="#22-%e5%90%91%e7%ba%bf%e7%a8%8b%e4%bc%a0%e9%80%92%e5%8f%82%e6%95%b0">&lt;/a>
&lt;/h1>&lt;p>向线程传递参数时最好是都复制一份，而且&lt;strong>转换成线程启动函数期望的类型&lt;/strong>。举例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">foo&lt;/span>(std&lt;span style="color:#719e07">::&lt;/span>string) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#719e07">::&lt;/span>&lt;span style="color:#268bd2">thread&lt;/span> launch_thread() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">char&lt;/span> buf[&lt;span style="color:#2aa198">1024&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>&lt;span style="color:#268bd2">thread&lt;/span>{ foo, buf };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里 &lt;code>foo&lt;/code> 的参数是 &lt;code>std::string&lt;/code> 类型，而 &lt;code>std::thread&lt;/code> 在构造时复制的是 &lt;code>char *&lt;/code> 类型的参数。等线程创建好，真正开始执行的时候，复制过来的 &lt;code>buf&lt;/code> 就可能已经是悬挂引用了。&lt;/p></description></item><item><title>libstdc++ 中 std::shared_ptr 的内存开销</title><link>https://hxhue.github.io/posts/programming/cpp/libstdc++-%E4%B8%AD-shared_ptr-%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%80%E9%94%80/</link><pubDate>Tue, 27 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libstdc++-%E4%B8%AD-shared_ptr-%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%80%E9%94%80/</guid><description>&lt;h1 id="stdshared_ptrt-的内存开销">&lt;code>std::shared_ptr&amp;lt;T&amp;gt;&lt;/code> 的内存开销
&lt;a class="header-anchor" href="#stdshared_ptrt-%e7%9a%84%e5%86%85%e5%ad%98%e5%bc%80%e9%94%80">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#719e07">::&lt;/span>shared_ptr&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> element_type&lt;span style="color:#719e07">*&lt;/span>    _M_ptr; &lt;span style="color:#586e75">// Contained pointer. sizeof(intptr_t) 字节
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> __shared_count&lt;span style="color:#719e07">&amp;lt;&lt;/span>_Lp&lt;span style="color:#719e07">&amp;gt;&lt;/span>  _M_refcount; &lt;span style="color:#586e75">// Reference counter. sizeof(intptr_t) 字节
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> _Sp_counted_base&lt;span style="color:#719e07">&amp;lt;&lt;/span>_Lp&lt;span style="color:#719e07">&amp;gt;*&lt;/span>  _M_pi;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#719e07">::&lt;/span>_Sp_counted_base&lt;span style="color:#719e07">&amp;lt;&lt;/span>__default_lock_policy&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// vtable pointer // sizeof(intptr_t) 字节
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> _Atomic_word  _M_use_count;     &lt;span style="color:#586e75">// #shared 4 字节，实际上是 int 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> _Atomic_word  _M_weak_count;    &lt;span style="color:#586e75">// #weak + (#shared != 0) 4 字节
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，记录 use count 是为了判断什么时候可以释放共享指针指向的对象；记录 weak count 是为了判断什么时候可以安全释放控制块本身。即便是共享指针指向对象已经被释放（use count 归零），也可能有弱指针会尝试转换成共享指针，因此应该保证这些弱指针能安全查询控制块。还有一点，如果用 &lt;code>std::make_shared&lt;/code> 创建共享指针，use count 归零而 weak count 不归零时，共享对象只是被析构，其内存会等到 weak count 归零时一起被释放。可以参考 &lt;a href="https://stackoverflow.com/a/49585948/" title="https://stackoverflow.com/a/49585948/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/49585948/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 。&lt;/p></description></item><item><title>查找 malloc 和 free 是否配对</title><link>https://hxhue.github.io/posts/cli/bash/bash-%E6%9F%A5%E6%89%BE-malloc-%E5%92%8C-free-%E6%98%AF%E5%90%A6%E9%85%8D%E5%AF%B9/</link><pubDate>Tue, 27 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/bash-%E6%9F%A5%E6%89%BE-malloc-%E5%92%8C-free-%E6%98%AF%E5%90%A6%E9%85%8D%E5%AF%B9/</guid><description>&lt;h1 id="说明">说明
&lt;a class="header-anchor" href="#%e8%af%b4%e6%98%8e">&lt;/a>
&lt;/h1>&lt;p>因为项目有老代码所以才需要这样处理，一般建议用 RAII 等技术避免裸露资源。&lt;/p>
&lt;h1 id="find_mallocsh">find_malloc.sh
&lt;a class="header-anchor" href="#find_mallocsh">&lt;/a>
&lt;/h1>&lt;p>要点：&lt;/p>
&lt;ol>
&lt;li>用 gcc 去除代码注释。&lt;/li>
&lt;li>用 awk 对正则表达式计数。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>check&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gcc -fpreprocessed -dD -E -P &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#268bd2">$1&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> 2&amp;gt;/dev/null | awk -v &lt;span style="color:#268bd2">file&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#268bd2">$1&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#2aa198">&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> BEGIN {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> malloc=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> free=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> queueCreate=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> queueDestroy=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> notifierCreate=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> notifierDestroy=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> handleCreate=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> handleDestroy=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtMalloc\(/ { malloc++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtFree\(/ { free++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtQueueCreate\(/ { queueCreate++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtCreateQueue\(/ { queueCreate++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtDestroyQueue\(/ { queueDestroy++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtQueueDestroy\(/ { queueDestroy++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtCreateNotifier\(/ { notifierCreate++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtDestroyNotifier\(/ { notifierDestroy++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnnlCreate\(/ { handleCreate++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnnlDestroy\(/ { handleDestroy++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> END {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> if (malloc != free) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> print &amp;#34;file: &amp;#34; file &amp;#34;, malloc: &amp;#34; malloc &amp;#34;, free: &amp;#34; free
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> if (queueCreate != queueDestroy) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> print &amp;#34;file: &amp;#34; file &amp;#34;, queueCreate: &amp;#34; queueCreate &amp;#34;, queueDestroy: &amp;#34; queueDestroy
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> if (notifierCreate != notifierDestroy) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> print &amp;#34;file: &amp;#34; file &amp;#34;, notifierCreate: &amp;#34; notifierCreate &amp;#34;, notifierDestroy: &amp;#34; notifierDestroy
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> if (handleCreate != handleDestroy) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> print &amp;#34;file: &amp;#34; file &amp;#34;, handleCreate: &amp;#34; handleCreate &amp;#34;, handleDestroy: &amp;#34; handleDestroy
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>check &lt;span style="color:#268bd2">$1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="find_malloc_allsh">find_malloc_all.sh
&lt;a class="header-anchor" href="#find_malloc_allsh">&lt;/a>
&lt;/h1>&lt;p>要点：使用 &lt;code>find&lt;/code> 匹配时应该选择正则表达式类型，同时和 Python 的 &lt;code>re&lt;/code> 模块一样要全字符串匹配（不能匹配只部分字符，因此想只匹配中间部分的时候，就要在两边加上 &lt;code>.*&lt;/code>）。&lt;/p></description></item><item><title>要小心 C++ 静态初始化顺序</title><link>https://hxhue.github.io/posts/programming/cpp/%E8%A6%81%E5%B0%8F%E5%BF%83-C++-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</link><pubDate>Tue, 06 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E8%A6%81%E5%B0%8F%E5%BF%83-C++-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</guid><description>&lt;p>&lt;a href="https://godbolt.org/z/n5bjMGcx3" title="https://godbolt.org/z/n5bjMGcx3" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://godbolt.org/z/n5bjMGcx3&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>编译器并不会自动根据代码的依赖关系去编排静态初始化顺序，示例代码中 &lt;code>vec&lt;/code> 在被推入两个元素之后又被初始化了一次（在 compiler explorer 中看汇编也能看出来）。&lt;/p></description></item><item><title>私有化构造函数</title><link>https://hxhue.github.io/posts/programming/cpp/%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 22 Jul 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid><description>&lt;p>有的时候我们希望私有化构造函数，然后要求用户只通过工厂方法访问我们的类型，在 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/cpp-templates-the-complete-guide/21-Templates-and-Inheritance/#std-enable_shared_from_this" title="std::enable_shared_from_this 的例子" >&lt;code>std::enable_shared_from_this&lt;/code> 的例子&lt;/a> 中就有使用。这个例子是从 cppreference 上面抄来的。但是今天我发现去年 11 月有人修改了网页上的例子，修订记录为 &lt;a href="https://en.cppreference.com/mwiki/index.php?title=cpp%2Fmemory%2Fenable_shared_from_this&amp;amp;diff=162885&amp;amp;oldid=153414" title="https://en.cppreference.com/mwiki/index.php?title=cpp%2Fmemory%2Fenable_shared_from_this&amp;diff=162885&amp;oldid=153414" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/mwiki/index.php?title=cpp%2Fmemory%2Fenable_shared_from_this&amp;diff=162885&amp;oldid=153414&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 。&lt;/p></description></item><item><title>为什么用 tar.gz 安装的共享库 gcc 找不到？</title><link>https://hxhue.github.io/posts/systems/Linux/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-tar.gz-%E5%AE%89%E8%A3%85%E7%9A%84%E5%85%B1%E4%BA%AB%E5%BA%93-gcc-%E6%89%BE%E4%B8%8D%E5%88%B0/</link><pubDate>Fri, 28 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-tar.gz-%E5%AE%89%E8%A3%85%E7%9A%84%E5%85%B1%E4%BA%AB%E5%BA%93-gcc-%E6%89%BE%E4%B8%8D%E5%88%B0/</guid><description>&lt;h1 id="情况">情况
&lt;a class="header-anchor" href="#%e6%83%85%e5%86%b5">&lt;/a>
&lt;/h1>&lt;p>项目是由 CMake 构建的动态库，用 CPack 我们打包得到了一个 deb 包版本和一个 tar.gz 的压缩包版本。前者安装之后 demo 能够正常编译运行，但是在换用压缩包安装共享库后编译 demo 则出现了找不到库的错误（这里讨论的是非标准路径的情况，即安装路径不在 &lt;code>/&lt;/code>、&lt;code>/usr&lt;/code> 和 &lt;code>/usr/local&lt;/code> 下）。&lt;/p></description></item><item><title>CUDA 中 SFINAE 的坑</title><link>https://hxhue.github.io/posts/programming/cuda/CUDA-%E4%B8%AD-SFINAE-%E7%9A%84%E5%9D%91/</link><pubDate>Sat, 22 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cuda/CUDA-%E4%B8%AD-SFINAE-%E7%9A%84%E5%9D%91/</guid><description>&lt;h1 id="tldr">TL;DR
&lt;a class="header-anchor" href="#tldr">&lt;/a>
&lt;/h1>&lt;p>如果想要写一些 traits，而且涉及到了函数和变量（而不是类型），则需要同时加上 &lt;code>__device__&lt;/code> 和 &lt;code>__host__&lt;/code> 以确保它在 device 侧和 host 侧都可见。否则会因为 SFINAE 不报错（实际上可能是在 device 侧找不到函数或变量），而且不知道为什么结果不对。&lt;/p></description></item><item><title>模除运算</title><link>https://hxhue.github.io/posts/programming/cpp/%E6%A8%A1%E9%99%A4%E8%BF%90%E7%AE%97/</link><pubDate>Sun, 16 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E6%A8%A1%E9%99%A4%E8%BF%90%E7%AE%97/</guid><description>&lt;p>C++ 中两数相除（假设被除数和除数都不是 0），同号则结果为正，异号则结果为负。模除运算则定义为：&lt;/p>
&lt;blockquote>
 &lt;p>If $a~/~b$ is representable in the result type, $(a~/~b)*b + a~\%~b == a$.（来自 &lt;a href="https://en.cppreference.com/w/cpp/language/operator_arithmetic" title="https://en.cppreference.com/w/cpp/language/operator_arithmetic" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/language/operator_arithmetic&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> ）&lt;/p>
&lt;/blockquote>&lt;p>实践起来则是：在被除数不是 0 的情况下，模除运算的结果总是和除数同正负。&lt;/p></description></item><item><title>std::lower_bound 是一种分区查找算法</title><link>https://hxhue.github.io/posts/programming/cpp/std__lower_bound-%E6%98%AF%E4%B8%80%E7%A7%8D%E5%88%86%E5%8C%BA%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 04 May 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/std__lower_bound-%E6%98%AF%E4%B8%80%E7%A7%8D%E5%88%86%E5%8C%BA%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="起因每日一题官解看不明白">起因：每日一题官解看不明白
&lt;a class="header-anchor" href="#%e8%b5%b7%e5%9b%a0%e6%af%8f%e6%97%a5%e4%b8%80%e9%a2%98%e5%ae%98%e8%a7%a3%e7%9c%8b%e4%b8%8d%e6%98%8e%e7%99%bd">&lt;/a>
&lt;/h1>&lt;p>今天（2024 年 5 月 4 日）做 Leetcode 每日一题又没有做出来，最后抄了答案。题目是这样的：&lt;a href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/" title="1235. 规划兼职工作" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >1235. 规划兼职工作&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>。&lt;/p>
&lt;p>思路是先按照 &lt;code>endTime&lt;/code> 排序，然后再 dp，然后 dp 中用二分查找求满足“自己的 &lt;code>endTime&lt;/code> 小于等于当前元素 &lt;code>startTime&lt;/code> ” 的元素数量。但是官方解答的 &lt;code>std::upper_bound&lt;/code> 传参实在是看迷糊了。&lt;/p></description></item><item><title>为什么我不推荐用 enum class 作为强类型的整数？</title><link>https://hxhue.github.io/posts/programming/cpp/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%94%A8-enum-class-%E4%BD%9C%E4%B8%BA%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B4%E6%95%B0/</link><pubDate>Sat, 27 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%94%A8-enum-class-%E4%BD%9C%E4%B8%BA%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B4%E6%95%B0/</guid><description>&lt;h1 id="c11-之后-enum-的新增功能">C++11 之后 enum 的新增功能
&lt;a class="header-anchor" href="#c11-%e4%b9%8b%e5%90%8e-enum-%e7%9a%84%e6%96%b0%e5%a2%9e%e5%8a%9f%e8%83%bd">&lt;/a>
&lt;/h1>&lt;p>enum class 是 C++11 提供的功能，为了更好理解后文的内容，我们先看看 C++11 之后 enum 有什么变化。参考资料见 &lt;a href="https://en.cppreference.com/w/cpp/language/enum" title="https://en.cppreference.com/w/cpp/language/enum" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/language/enum&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 。&lt;/p>
&lt;h2 id="有作用域枚举">有作用域枚举
&lt;a class="header-anchor" href="#%e6%9c%89%e4%bd%9c%e7%94%a8%e5%9f%9f%e6%9e%9a%e4%b8%be">&lt;/a>
&lt;/h2>&lt;p>有作用域枚举（Scoped enumerations）使用 &lt;code>enum class|struct ClassName&lt;/code> 声明，以区别于原来的无作用域枚举。无作用域枚举的枚举量可以直接在外围名字空间中访问，当枚举类有名字且 C++ 版本至少为 C++11 时，可以通过 &lt;code>枚举名::枚举量&lt;/code> 访问；有作用域枚举只能通过 &lt;code>枚举名::枚举量&lt;/code> 访问。&lt;/p></description></item><item><title>inline 函数不对外链接？gnu89 和 c99 恐怖的语义对换！</title><link>https://hxhue.github.io/posts/programming/cpp/inline-%E5%87%BD%E6%95%B0%E4%B8%8D%E5%AF%B9%E5%A4%96%E9%93%BE%E6%8E%A5gnu89-%E5%92%8C-c99-%E6%81%90%E6%80%96%E7%9A%84%E8%AF%AD%E4%B9%89%E5%AF%B9%E6%8D%A2/</link><pubDate>Thu, 25 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/inline-%E5%87%BD%E6%95%B0%E4%B8%8D%E5%AF%B9%E5%A4%96%E9%93%BE%E6%8E%A5gnu89-%E5%92%8C-c99-%E6%81%90%E6%80%96%E7%9A%84%E8%AF%AD%E4%B9%89%E5%AF%B9%E6%8D%A2/</guid><description>&lt;h1 id="经过">经过
&lt;a class="header-anchor" href="#%e7%bb%8f%e8%bf%87">&lt;/a>
&lt;/h1>&lt;p>遇到过一个坑：为共享库写函数，但是又需要从头文件隐藏实现时，不要将函数声明为内联。否则编译器会认为它未被使用并忽略它，链接的时候就找不到这个函数。&lt;/p></description></item><item><title>GCC optimize-sibling-calls 的反向优化</title><link>https://hxhue.github.io/compiler-explorer-experiments/2024-04-20-GCC-optimize-sibling-calls-%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%98%E5%8C%96/</link><pubDate>Sat, 20 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/compiler-explorer-experiments/2024-04-20-GCC-optimize-sibling-calls-%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%98%E5%8C%96/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;benchmark/benchmark.h&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>&lt;span style="color:#719e07">static&lt;/span> &lt;span style="color:#268bd2">inline&lt;/span> &lt;span style="color:#719e07">constexpr&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> FIBONACCI_N &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">fib&lt;/span>(&lt;span style="color:#dc322f">int&lt;/span> n) { &lt;span style="color:#719e07">return&lt;/span> n &lt;span style="color:#719e07">&amp;lt;&lt;/span> &lt;span style="color:#2aa198">2&lt;/span> &lt;span style="color:#719e07">?&lt;/span> n : fib(n &lt;span style="color:#719e07">-&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>) &lt;span style="color:#719e07">+&lt;/span> fib(n &lt;span style="color:#719e07">-&lt;/span> &lt;span style="color:#2aa198">2&lt;/span>); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">BM_fib&lt;/span>(benchmark&lt;span style="color:#719e07">::&lt;/span>State &lt;span style="color:#719e07">&amp;amp;&lt;/span>state) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (&lt;span style="color:#719e07">auto&lt;/span> _ : state) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> res &lt;span style="color:#719e07">=&lt;/span> fib(FIBONACCI_N);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> benchmark&lt;span style="color:#719e07">::&lt;/span>DoNotOptimize(res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BENCHMARK(BM_fib);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> x; &lt;span style="color:#586e75">// Magic line.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// clang does not use DP anymore: much slower.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// gcc chooses a different optimizing approach: much faster.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">fib_x&lt;/span>(&lt;span style="color:#dc322f">int&lt;/span> n) { &lt;span style="color:#719e07">return&lt;/span> n &lt;span style="color:#719e07">&amp;lt;&lt;/span> &lt;span style="color:#2aa198">2&lt;/span> &lt;span style="color:#719e07">?&lt;/span> n : fib_x(n &lt;span style="color:#719e07">-&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>) &lt;span style="color:#719e07">+&lt;/span> fib_x(n &lt;span style="color:#719e07">-&lt;/span> &lt;span style="color:#2aa198">2&lt;/span>) &lt;span style="color:#719e07">+&lt;/span> x; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">BM_fib_x&lt;/span>(benchmark&lt;span style="color:#719e07">::&lt;/span>State &lt;span style="color:#719e07">&amp;amp;&lt;/span>state) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (&lt;span style="color:#719e07">auto&lt;/span> _ : state) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> res &lt;span style="color:#719e07">=&lt;/span> fib_x(FIBONACCI_N);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> benchmark&lt;span style="color:#719e07">::&lt;/span>DoNotOptimize(res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BENCHMARK(BM_fib_x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BENCHMARK_MAIN();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译条件：GCC 13.2 -O2 -std=c++17&lt;/p></description></item><item><title>libc++ 和 libstdc++ 中 basic_string 的 SSO 比较</title><link>https://hxhue.github.io/posts/programming/cpp/libc++-%E5%92%8C-libstdc++-%E4%B8%AD-basic_string-%E7%9A%84-SSO-%E6%AF%94%E8%BE%83/</link><pubDate>Sat, 13 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libc++-%E5%92%8C-libstdc++-%E4%B8%AD-basic_string-%E7%9A%84-SSO-%E6%AF%94%E8%BE%83/</guid><description>&lt;h1 id="参考">参考
&lt;a class="header-anchor" href="#%e5%8f%82%e8%80%83">&lt;/a>
&lt;/h1>&lt;p>&lt;a href="https://joellaity.com/2020/01/31/string.html" title="https://joellaity.com/2020/01/31/string.html" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://joellaity.com/2020/01/31/string.html&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>&lt;code>std::string&lt;/code> 是 &lt;code>std::basic_string&amp;lt;&amp;gt;&lt;/code> 的一个特化，该类的 &lt;code>value_type&lt;/code> 是 char。本文虽然是讨论 &lt;code>std::basic_string&amp;lt;&amp;gt;&lt;/code> 的实现方式，但是为了方便，&lt;strong>假设 &lt;code>value_type&lt;/code> 是 &lt;code>char&lt;/code>、假设目标平台是 64 位&lt;/strong>，讨论时也将把 &lt;code>std::basic_string&amp;lt;&amp;gt;&lt;/code> 和 &lt;code>std::string&lt;/code> 互用。&lt;/p></description></item><item><title>language/implicit_conversion 限定性类型转换</title><link>https://hxhue.github.io/posts/programming/cpp/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E6%80%A7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link><pubDate>Sun, 07 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E6%80%A7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid><description>&lt;h1 id="写在前面">写在前面
&lt;a class="header-anchor" href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2">&lt;/a>
&lt;/h1>&lt;p>内容见 &lt;a href="https://en.cppreference.com/w/cpp/language/implicit_conversion" title="implicit conversion" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >implicit conversion&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>。&lt;/p>
&lt;p>限定性转换指的是和 cv 属性有关的类型转换，它的发生必须满足一定的条件。&lt;/p>
&lt;h1 id="相似类型">相似类型
&lt;a class="header-anchor" href="#%e7%9b%b8%e4%bc%bc%e7%b1%bb%e5%9e%8b">&lt;/a>
&lt;/h1>&lt;p>忽略掉各层的 cv 属性，如果两个类型形式相同，就是相似类型。比如 &lt;code>const int* volatile *&lt;/code> 和 &lt;code>int** const&lt;/code>。&lt;/p></description></item><item><title>(CppCon 2023) Great C++ is_trivial</title><link>https://hxhue.github.io/cppcon-talks/CppCon-2023-Great-C++-is_trivial/</link><pubDate>Fri, 05 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cppcon-talks/CppCon-2023-Great-C++-is_trivial/</guid><description>&lt;h1 id="写在前面">写在前面
&lt;a class="header-anchor" href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2">&lt;/a>
&lt;/h1>&lt;p>参考链接 &lt;a href="https://www.youtube.com/watch?v=bpF1LKQBgBQ" title="https://www.youtube.com/watch?v=bpF1LKQBgBQ" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://www.youtube.com/watch?v=bpF1LKQBgBQ&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>这篇演讲有关 C++ 中的 &lt;em>trivial&lt;/em> 概念。并且提到当对象 trivially copyable 时，参数传递和返回值都会变得更容易优化。&lt;/p>
&lt;h1 id="返回值优化">返回值优化
&lt;a class="header-anchor" href="#%e8%bf%94%e5%9b%9e%e5%80%bc%e4%bc%98%e5%8c%96">&lt;/a>
&lt;/h1>&lt;p>






&lt;img src="https://hxhue.github.io/assets/CppCon%202023%20Great%20C++%20is_trivial-20240408000238783.webp">&lt;/p>
&lt;p>第 2 段代码在 C++20 之前不能被优化是因为结构化绑定的分量是结构体的一部分，作为返回值时不能被直接建在调用者的栈上。&lt;/p></description></item><item><title>Empty Member Optimization with C++20's `[[no_unique_address]]`</title><link>https://hxhue.github.io/compiler-explorer-experiments/2024-04-03-Empty-Member-Optimization-with-no_unique_address/</link><pubDate>Wed, 03 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/compiler-explorer-experiments/2024-04-03-Empty-Member-Optimization-with-no_unique_address/</guid><description>&lt;p style="display: flex;">&lt;a style="display: flex; align-items: center; border-bottom: 0px; text-decoration: none; padding: 6px 8px 6px 6px; border-radius: 8px; border: solid 1px #555; background: #fff; color: #555555;" href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxBIArKQADqgKhE4MHt6%2BekkpjgJBIeEsUTFc8XaYDmlCBEzEBBk%2Bfly2mPZ5DDV1BAVhkdFxtrX1jVktCsM9wX3FA2UAlLaoXsTI7BwTxF4OANTYLAkEAJ5CXhGoEdqVBDsmAOxWdwAiJgDMVhoAgiZfm9s3ADFUKhbg8fp8dpDbrErDCGKgAPpeBh4ACOXkwCKY6HQxEwCgUJliL2JewOx1O50u1x2F20bw%2BEKhwRuEQZ4PuL3eHK%2B5leeCoWCoOwRAHUAJKhV5mcGMHygiw7ITigBa2DeTwAHKCuYy%2BW0lLKGPL7orlWqNZIdezeWZXq4BTzPhMmI5kFiCdECBAUgAvTCoKgQIGoea3V5cp5K1XYeY2z4cRa0TixXh%2BDhaUioThuazWHYKZarTC3O08UgETSJxYAaxAsQ0%2Bk4kl4LAkGkb6cz2Y4vAUIEblYzidIcFgMEQKFQBzo0XIlDQM/oMWAXGlfDoBGi/YgESrpAiwTqR045cPzGIRwA8tSHKfeIu2IIrwxaCfh6QsBEvMA3GJaP23C8FgLCGMA4gfvgeJVAAbvi%2B6YKolReFu97kIIbT7rQeARMQx4eFg%2B4EMQeBth%2BcHEOcShPJgoFGNhRhVosVAGMACgAGp4JgADuV4JIwaH8IIIhiOwUgyIIigqOoH66C0BiMaYljWPoOH9pAiyoIcaSAQAtBM6AakpViWGY3YUSRWDqRAiwVFUzgQK4ozNKQgTTEUJTZMkqQCM5Xm5GkvQeXMrTtNUkx%2BeMbTXOF3RBf0pRDN0kVJfU8WzKUtlFmsEhJimab7j2OyqJqABsumlVawDIMgOxrgAdGYOwQLghAkKWrxcPMvBDlo8y1vWjbJhwLakG2ryvPVpVmAAnK8kgzVwM0aDNsTLTNpBdrwPZ9gOFZMaOE4QEgi4JLOZAUBAp3nSgCmrpqXCNjQtBbsQO57h%2B57HmhX2XjeVx3kBpCPowBAvm%2B%2B5fj%2Bf60ABaEgWBEGZlBMVwYBmaIchqFAyymEfthuH4Rg6yZsRpH7hRVGYDRdHgcEoDDsxrEcVxvH8em5ZCcIojiOJXNSWo%2B66GY%2BhgSgeaWKpETWZp2kCHpBlGRLFhmdtFl4FZ8C2dF9l%2BI5DDuJ4TT%2BAb6WeS0OQ%2BekRtjIk3kdGbIV2R0XQjDbLnO7FaXuQlegum7mQe5MjuZUsKw5V1TYcKmm2FZwxVlRVVrIHddWavVXD1RozWtUQxAdV1PVMXlI2tiA0r1atrylbEkjSncGgNw98RbVmnC7YOB1jpO13LvOV3Tmdy4gDByAJAkCIwUtCKvJqCKqJVG4vdulAfZmv3vmeR5/beQ7liDz6vu%2ByOYN%2Bv7/oB5YI/RJPAXg0GOGjCFIcgKHrOWuPDZmBN4ZeBG3xWEiZFMyU2SNTWiiN6YHRYkwNinEeJ8QEkDLmIlebSH5koQWsly6i0UsrKWMssxywYIBAA9AZcWylTLmWiJZeCGlQoxQck5d2Jt0Ah38lbFKlsHY%2Bwyn7HWLsIqsKimFAQrspiFF9uMYRgc/bBz4ebLK4cxIlxjq3IqC8rQsAUKPHYU8Zr1VnjnfAecC7dX2ozEuo1xqTUkFwUqM0ZqVQejNBuK0W5x17LYPavVqykDrA2KOrwCofh2pYvqJczChO7O3CJ/iKIpGcJIIAA%3D%3D">&lt;img src="https://godbolt.org/favicon.ico" style="height: 32px; margin: 0 4px 0 0;"/>Open in Compiler Explorer&lt;/a>&lt;/p>
&lt;p>






&lt;img alt="image" src="https://hxhue.github.io/assets/image4u78iye4w35y6j6.webp">&lt;/p>
&lt;p>&lt;code>[[no_unique_address]]&lt;/code> makes the empty subobject (of type &lt;code>EmptySubobject&lt;/code>) potentially overlapping. It&amp;rsquo;s implementation-defined whether its size should be 0 (see &lt;a href="https://en.cppreference.com/w/cpp/language/object" title="https://en.cppreference.com/w/cpp/language/object" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/language/object&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>, section &lt;em>size&lt;/em>). Apparently, x64 MSVC v19.38 hasn&amp;rsquo;t implemented the optimization.&lt;/p></description></item><item><title>Copy elision</title><link>https://hxhue.github.io/posts/programming/cpp/Copy-elision/</link><pubDate>Tue, 02 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Copy-elision/</guid><description>&lt;h1 id="参考">参考
&lt;a class="header-anchor" href="#%e5%8f%82%e8%80%83">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>&lt;a href="https://en.cppreference.com/w/cpp/language/copy_elision" title="https://en.cppreference.com/w/cpp/language/copy_elision" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/language/copy_elision&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=PTCFddZfnXc" title="https://www.youtube.com/watch?v=PTCFddZfnXc" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://www.youtube.com/watch?v=PTCFddZfnXc&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 2024 年 6 月 26 日：这个视频讲了 GCC 的新 &lt;code>-Wnrvo&lt;/code> 编译参数。&lt;/li>
&lt;/ul>
&lt;h1 id="c17-prvalue-semantics-guaranteed-copy-elision">C++17 prvalue semantics (&amp;ldquo;guaranteed copy elision&amp;rdquo;)
&lt;a class="header-anchor" href="#c17-prvalue-semantics-guaranteed-copy-elision">&lt;/a>
&lt;/h1>&lt;p>返回值（或函数参数）的位置，如果表达式是纯右值，且返回值（或函数参数）需要的也是同一类型的纯右值，那么标准就要求省略复制和移动。不过，为了让语义检查通过，&lt;strong>要构造对象的析构函数必须在此处可以访问&lt;/strong>，尽管在完成优化之后并不会用到析构函数。&lt;/p></description></item><item><title>C++: Rule of 3/5/0</title><link>https://hxhue.github.io/posts/programming/cpp/C++-Rule-of-3-5-0/</link><pubDate>Sun, 24 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++-Rule-of-3-5-0/</guid><description>&lt;p>&lt;a href="https://en.cppreference.com/w/cpp/language/rule_of_three" title="https://en.cppreference.com/w/cpp/language/rule_of_three" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/language/rule_of_three&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;h1 id="rule-of-3">Rule of 3
&lt;a class="header-anchor" href="#rule-of-3">&lt;/a>
&lt;/h1>&lt;p>析构函数、拷贝构造、拷贝赋值三者要是定义了其一，最好把其他两个都补上，因为编译生成的很可能不是我们想要的。此外，&lt;strong>定义三者之一会导致移动构造、移动赋值被删除&lt;/strong>。&lt;/p>
&lt;div class="markdown-alert markdown-alert-note">
 &lt;p class="markdown-alert-title">&lt;svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16"
 aria-hidden="true">
 &lt;path
 d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
 &lt;/path>
 &lt;/svg>Note&lt;/p>
 &lt;p>显式删除拷贝构造函数（&lt;code>MyClass(const MyClass&amp;amp;) = delete;&lt;/code>）也是一种声明，这样会导致移动构造函数被删除，如果有移动尝试则会匹配上（被删除的）拷贝构造函数，从而编译失败。&lt;/p>
&lt;/div>&lt;div class="markdown-alert markdown-alert-tip">
 &lt;p class="markdown-alert-title">
 &lt;svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true">
 &lt;path
 d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z">
 &lt;/path>
 &lt;/svg>Tip&lt;/p>
 &lt;p>复制 / 移动赋值操作符可以用复制 / 移动构造函数 + &lt;code>std::swap&lt;/code> 实现。&lt;/p>
&lt;/div></description></item><item><title>(CppCon 2023) C++ Memory Model - from C++11 to C++23 - Alex Dathskovsky</title><link>https://hxhue.github.io/cppcon-talks/CppCon-2023-C++-Memory-Model-from-C++11-to-C++23-Alex-Dathskovsky/</link><pubDate>Fri, 22 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cppcon-talks/CppCon-2023-C++-Memory-Model-from-C++11-to-C++23-Alex-Dathskovsky/</guid><description>&lt;p>视频链接 &lt;a href="https://www.youtube.com/watch?v=SVEYNEWZLo4" title="https://www.youtube.com/watch?v=SVEYNEWZLo4" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://www.youtube.com/watch?v=SVEYNEWZLo4&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;h1 id="不要用-volatile-来同步">不要用 Volatile 来同步
&lt;a class="header-anchor" href="#%e4%b8%8d%e8%a6%81%e7%94%a8-volatile-%e6%9d%a5%e5%90%8c%e6%ad%a5">&lt;/a>
&lt;/h1>&lt;div class="markdown-alert markdown-alert-note">
 &lt;p class="markdown-alert-title">&lt;svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16"
 aria-hidden="true">
 &lt;path
 d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
 &lt;/path>
 &lt;/svg>Note&lt;/p></description></item><item><title>C++20 之前向下转换到有符号数无法表示时是实现定义</title><link>https://hxhue.github.io/posts/programming/cpp/C++20-%E4%B9%8B%E5%89%8D%E5%90%91%E4%B8%8B%E8%BD%AC%E6%8D%A2%E5%88%B0%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%97%A0%E6%B3%95%E8%A1%A8%E7%A4%BA%E6%97%B6%E6%98%AF%E5%AE%9E%E7%8E%B0%E5%AE%9A%E4%B9%89/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++20-%E4%B9%8B%E5%89%8D%E5%90%91%E4%B8%8B%E8%BD%AC%E6%8D%A2%E5%88%B0%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%97%A0%E6%B3%95%E8%A1%A8%E7%A4%BA%E6%97%B6%E6%98%AF%E5%AE%9E%E7%8E%B0%E5%AE%9A%E4%B9%89/</guid><description>&lt;h1 id="什么是向下转换">什么是向下转换
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%90%91%e4%b8%8b%e8%bd%ac%e6%8d%a2">&lt;/a>
&lt;/h1>&lt;p>向下转换是可能出现溢出的转换。检查是否为向下转换：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> To, &lt;span style="color:#719e07">typename&lt;/span> From, &lt;span style="color:#719e07">typename&lt;/span> &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#dc322f">void&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">NotNarrowing&lt;/span>&lt;span style="color:#719e07">:&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>false_type {};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> To, &lt;span style="color:#719e07">typename&lt;/span> From&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">NotNarrowing&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>To, From, std&lt;span style="color:#719e07">::&lt;/span>void_t&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">decltype&lt;/span>(To{std&lt;span style="color:#719e07">::&lt;/span>declval&lt;span style="color:#719e07">&amp;lt;&lt;/span>From&lt;span style="color:#719e07">&amp;gt;&lt;/span>()})&lt;span style="color:#719e07">&amp;gt;&amp;gt;:&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>true_type {};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>To{std::declval&amp;lt;From&amp;gt;()}&lt;/code> 这一步如果用在具体的类型上（比如说 int 和 unsigned），编译器是只给警告，不会报错。如果能够在编译期推导出来数值，则会根据数值来选择通过或报错。比如 &lt;code>char{'a'};&lt;/code> 是正常编译的，但是 &lt;code>char{300};&lt;/code> 是会报错的。&lt;/p></description></item><item><title>自定义 ostream</title><link>https://hxhue.github.io/posts/programming/cpp/%E8%87%AA%E5%AE%9A%E4%B9%89-ostream/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E8%87%AA%E5%AE%9A%E4%B9%89-ostream/</guid><description>&lt;p>下面的代码继承了 &lt;code>std::streambuf&lt;/code> 改变了 &lt;code>ostream&lt;/code> 的行为，并自定义了打印操作将结果送到 &lt;code>stdout&lt;/code>，而不是 &lt;code>std::cout&lt;/code> 中（当然也可以更改逻辑修改打印的细节）。&lt;/p>
&lt;p>其中的 &lt;code>print&lt;/code> 函数是仿 C++23 &lt;code>std::print&lt;/code> 的，功能仅仅是打印参数，在笔记 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/posts/programming/cpp/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%8A%B1%E6%8B%AC%E5%8F%B7%E6%8F%92%E5%80%BC%E6%89%93%E5%8D%B0/" title="实现简单的花括号插值打印" >实现简单的花括号插值打印&lt;/a> 中实现。&lt;/p></description></item><item><title>(CppCon 2018) 105 STL Algorithms in Less Than an Hour</title><link>https://hxhue.github.io/cppcon-talks/CppCon-2018-105-STL-Algorithms-in-Less-Than-an-Hour/</link><pubDate>Tue, 05 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cppcon-talks/CppCon-2018-105-STL-Algorithms-in-Less-Than-an-Hour/</guid><description>&lt;ol>
&lt;li>为了简单，下面都不用 &lt;code>std&lt;/code> 名字空间了。而且实际上 &lt;code>begin&lt;/code> 和 &lt;code>end&lt;/code> 是有 ADL 的。&lt;/li>
&lt;li>有一些算法是在 &lt;code>numeric&lt;/code> 头文件中的。&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=2olsGf6JIkU" title="https://www.youtube.com/watch?v=2olsGf6JIkU" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://www.youtube.com/watch?v=2olsGf6JIkU&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;h1 id="1-not-classified-2">1 Not Classified (2)
&lt;a class="header-anchor" href="#1-not-classified-2">&lt;/a>
&lt;/h1>&lt;pre>&lt;code>1. transform
&lt;/code>&lt;/pre>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/84fcaeff404297d9e7af540b6eb1f8fc.webp">&lt;/p>
&lt;p>下面这种重载有点像先 zip 再 transform，但是没有 zip 灵活。&lt;/p></description></item><item><title>(CppCon 2023) Lock-free Atomic Shared Pointers Without a Split Reference Count</title><link>https://hxhue.github.io/cppcon-talks/CppCon-2023-Lock-free-Atomic-Shared-Pointers-Without-a-Split-Reference-Count/</link><pubDate>Tue, 05 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cppcon-talks/CppCon-2023-Lock-free-Atomic-Shared-Pointers-Without-a-Split-Reference-Count/</guid><description>&lt;p>&lt;a href="https://youtu.be/lNPZV9Iqo3U?si=lS1hf2ND4SS-6ELB" title="https://youtu.be/lNPZV9Iqo3U?si=lS1hf2ND4SS-6ELB" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://youtu.be/lNPZV9Iqo3U?si=lS1hf2ND4SS-6ELB&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> by Daniel Anderson&lt;/p>
&lt;p>幻灯片链接： &lt;a href="https://raw.githubusercontent.com/CppCon/CppCon2023/main/Presentations/lock_free_atomic_shared_ptr_cppcon2023.pptx" title="https://raw.githubusercontent.com/CppCon/CppCon2023/main/Presentations/lock_free_atomic_shared_ptr_cppcon2023.pptx" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://raw.githubusercontent.com/CppCon/CppCon2023/main/Presentations/lock_free_atomic_shared_ptr_cppcon2023.pptx&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;h1 id="共享指针是线程安全的吗">共享指针是线程安全的吗？
&lt;a class="header-anchor" href="#%e5%85%b1%e4%ba%ab%e6%8c%87%e9%92%88%e6%98%af%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e5%90%97">&lt;/a>
&lt;/h1>&lt;p>&lt;code>std::shared_ptr&lt;/code> 的控制块是线程安全的（其实也就是析构是线程安全的， &lt;a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2" title="https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 中有 “&lt;em>Note that the control block of a &lt;code>shared_ptr&lt;/code> is thread-safe&amp;hellip;&lt;/em>” 这句话），但是：&lt;/p></description></item><item><title>chapter01 - basic</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter01-basic/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter01-basic/</guid><description>&lt;p>三个 stages：配置、生成、构建。&lt;/p>
&lt;p>配置会生成 CMakeCache。生成是用它去生成 build tree 的其他内容。&lt;/p>
&lt;h1 id="generating-a-build-system">Generating a Build System
&lt;a class="header-anchor" href="#generating-a-build-system">&lt;/a>
&lt;/h1>&lt;p>&lt;strong>生成 build tree&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cmake -B build/ -S source/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最好不要使用无参数的 cmake。&lt;/p></description></item><item><title>chapter02 - cmake language</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter02-cmake-language/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter02-cmake-language/</guid><description>&lt;h1 id="comments">Comments
&lt;a class="header-anchor" href="#comments">&lt;/a>
&lt;/h1>&lt;ol>
&lt;li>使用 &lt;code>#&lt;/code>&lt;/li>
&lt;li>使用 &lt;code>#[=[&lt;/code> 和 &lt;code>#]=]&lt;/code>（&lt;strong>这种块注释是可以嵌套的&lt;/strong>）&lt;/li>
&lt;/ol>
&lt;p>如果 &lt;code>#[=[&lt;/code> 前面还有 &lt;code>#&lt;/code>，那么块注释开始标志本身被注释了。后续的块注释结束标志被认为是普通的单行注释。&lt;/p></description></item><item><title>chapter02.a - 总结常用的 CMake 变量</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter02.a-%E6%80%BB%E7%BB%93%E5%B8%B8%E7%94%A8%E7%9A%84-CMake-%E5%8F%98%E9%87%8F/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter02.a-%E6%80%BB%E7%BB%93%E5%B8%B8%E7%94%A8%E7%9A%84-CMake-%E5%8F%98%E9%87%8F/</guid><description>&lt;h1 id="project_">&lt;code>PROJECT_*&lt;/code>
&lt;a class="header-anchor" href="#project_">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>PROJECT_SOURCE_DIR
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PROJECT_BINARY_DIR
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
 &lt;p>不存在 &lt;code>PROJECT_LIST_DIR&lt;/code>。&lt;/p>
&lt;/blockquote>&lt;p>&lt;code>PROJECT_*&lt;/code> 变量会随着 &lt;code>project&lt;/code> 命令的出现而变更。&lt;/p>
&lt;h1 id="cmake_">&lt;code>CMAKE_*&lt;/code>
&lt;a class="header-anchor" href="#cmake_">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>CMAKE_SOURCE_DIR
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CMAKE_BINARY_DIR
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
 &lt;p>也不存在 &lt;code>CMAKE_LIST_DIR&lt;/code>。&lt;/p>
&lt;/blockquote>&lt;p>和本次 cmake 命令有关。&lt;/p>
&lt;h1 id="cmake_current_">&lt;code>CMAKE_CURRENT_*&lt;/code>
&lt;a class="header-anchor" href="#cmake_current_">&lt;/a>
&lt;/h1>&lt;p>通过 VS Code 补全可以看到有很多变量：&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/c2942a998b7d4d905c57a2b327ae58ab.webp">&lt;/p>
&lt;p>其中 &lt;code>LIST&lt;/code> 和 &lt;code>SOURCE&lt;/code> 的区别是：&lt;code>include&lt;/code> 会直接将 cmake 文件插入进来，这个时候不会改变 &lt;code>SOURCE&lt;/code>，但是会改变 &lt;code>LIST&lt;/code>。所以为了表示文件的相对位置一般还是用 LIST 吧？&lt;/p></description></item><item><title>chapter03 - first cmake project</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter03-first-cmake-project/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter03-first-cmake-project/</guid><description>&lt;h1 id="cmake_minimal_required">cmake_minimal_required
&lt;a class="header-anchor" href="#cmake_minimal_required">&lt;/a>
&lt;/h1>&lt;p>&lt;code>cmake_minimal_required(VERSION xxx)&lt;/code> 是项目都应该有的说明。因为它指定了最小的版本，而且还会隐式去调用 &lt;code>cmake_policy&lt;/code>，这样即便 cmake 版本更新了，policy 没变，旧项目仍然可以正常构建。&lt;/p></description></item><item><title>chapter04 - targets</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter04-targets/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter04-targets/</guid><description>&lt;h1 id="创建-target">创建 target
&lt;a class="header-anchor" href="#%e5%88%9b%e5%bb%ba-target">&lt;/a>
&lt;/h1>&lt;p>三种方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>add_executable &lt;span style="color:#586e75"># 默认在 ALL 中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>add_library &lt;span style="color:#586e75"># 默认在 ALL 中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>add_custom_target &lt;span style="color:#586e75"># 默认不在 ALL 中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># add_custom_command 是创建文件的方式，但是不是创建 target
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>add_library&lt;/code>: &lt;a href="https://cmake.org/cmake/help/latest/command/add_library.html#object-libraries" title="https://cmake.org/cmake/help/latest/command/add_library.html#object-libraries" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://cmake.org/cmake/help/latest/command/add_library.html#object-libraries&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Normal library: 如果不指定 &lt;code>STATIC&lt;/code>/&lt;code>SHARED&lt;/code>/&lt;code>MODULE&lt;/code>，&lt;code>add_library&lt;/code> 会根据 &lt;code>BUILD_SHARED_LIBS&lt;/code> 变量去决定是否使用 &lt;code>SHARED&lt;/code> 还是 &lt;code>STATIC&lt;/code>。&lt;/li>
&lt;li>Object library: 生成目标文件。&lt;/li>
&lt;li>Interface library：不生成文件。用来打包传播属性。&lt;/li>
&lt;li>Imported library：&lt;code>IMPORTED&lt;/code> 属性和 &lt;code>STATIC&lt;/code> 等是可以叠加的。&lt;code>IMPORTED&lt;/code> 库是&lt;strong>已经被编译好的库&lt;/strong>，不需要另外编译，但是需要用 &lt;code>set_target_property&lt;/code> 来设置其位置。&lt;/li>
&lt;li>Alias library&lt;/li>
&lt;/ul>
&lt;p>&lt;code>add_custom_target&lt;/code> 可以有多条命令，而且不一定有产物。&lt;code>add_custom_target&lt;/code> 创建的 target 是默认不 ALL 的！和 &lt;code>add_custom_command&lt;/code> 的对比看后文。&lt;/p></description></item><item><title>chapter04.a - 梳理依赖是如何创建的</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter04.a-%E6%A2%B3%E7%90%86%E4%BE%9D%E8%B5%96%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%9A%84/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter04.a-%E6%A2%B3%E7%90%86%E4%BE%9D%E8%B5%96%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%9A%84/</guid><description>&lt;p>我认为的依赖有两种：&lt;/p>
&lt;ol>
&lt;li>文件依赖（sources）既有同级依赖（比如 &lt;code>add_custom_command&lt;/code> 的 &lt;code>DEPENDS&lt;/code> 参数），又有 targets 到 sources 的依赖。&lt;/li>
&lt;li>target 依赖是一种 targets 之间的同级依赖关系。&lt;/li>
&lt;/ol>
&lt;h1 id="target-依赖">Target 依赖
&lt;a class="header-anchor" href="#target-%e4%be%9d%e8%b5%96">&lt;/a>
&lt;/h1>&lt;p>创建 target 可以用 &lt;code>add_executable&lt;/code>/&lt;code>add_library&lt;/code>/&lt;code>add_custom_target&lt;/code>。前面两个都默认包含在 all 中，而最后一个默认不包含在 all 中。此外，&lt;code>add_custom_target&lt;/code> 如果给的是命令，而不是依赖文件，则创建的 targets 永远处于“需要被构建”的状态；如果给的是文件，则就只是文件依赖。&lt;/p></description></item><item><title>chapter05 - compiling c++ sources</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter05-compiling-c++-sources/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter05-compiling-c++-sources/</guid><description>&lt;h1 id="initial-configuration">Initial configuration
&lt;a class="header-anchor" href="#initial-configuration">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>target_sources &lt;span style="color:#586e75"># 追加源码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>target_include_directories
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>target_compile_definitions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>target_compile_options &lt;span style="color:#586e75"># 不能跨平台
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>target_compile_features &lt;span style="color:#586e75"># 对编译器要求某种特性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>target_precompile_headers
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>用 &lt;code>target_sources&lt;/code> 中添加了头文件是会被过滤掉的，会形成依赖，但是不会真正被编译。&lt;/li>
&lt;li>&lt;code>target_compile_features&lt;/code> 的特性非常多。一般也就只用 &lt;code>cxx_std_{98,11,14,17,20,23}&lt;/code> 这种语言标准，而不是具体的标准。&lt;/li>
&lt;/ul>
&lt;h1 id="preprocessor-configuration">Preprocessor configuration
&lt;a class="header-anchor" href="#preprocessor-configuration">&lt;/a>
&lt;/h1>&lt;p>&lt;code>target_compile_definitions&lt;/code> 能够自动去除多加的 &lt;code>-D&lt;/code>，不过最好还是不要加，因为这个命令本来就是用于跨平台的，不加风格更统一。&lt;/p></description></item><item><title>chapter06 - linking</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter06-linking/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter06-linking/</guid><description>&lt;h1 id="程序分段">程序分段
&lt;a class="header-anchor" href="#%e7%a8%8b%e5%ba%8f%e5%88%86%e6%ae%b5">&lt;/a>
&lt;/h1>&lt;p>






&lt;img src="https://hxhue.github.io/assets/64c742277ee1ef7f3cdf8b9122b1f754.webp">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>.text section: Machine code, with all the instructions to be executed by the processor&lt;/p>
&lt;/li>
&lt;li>
&lt;p>.data section: All values of the initialized global and static objects (variables)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>.bss section: All values of the uninitialized global and static objects (variables), which will be initialized to zero on program start&lt;/p>
&lt;/li>
&lt;li>
&lt;p>.rodata section: All values of the constants (read-only data)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>.strtab section: 常量字符串的表&lt;/p>
&lt;/li>
&lt;li>
&lt;p>.shstrtab section: 每个 section 的名称字符串的表&lt;/p></description></item><item><title>chapter07 - managing dependencies</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter07-managing-dependencies/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter07-managing-dependencies/</guid><description>&lt;h1 id="best-option-find_package">Best option: &lt;code>find_package&lt;/code>
&lt;a class="header-anchor" href="#best-option-find_package">&lt;/a>
&lt;/h1>&lt;p>&lt;a href="https://cmake.org/cmake/help/latest/command/find_package.html" title="https://cmake.org/cmake/help/latest/command/find_package.html" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://cmake.org/cmake/help/latest/command/find_package.html&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>有三种工作模式。&lt;/p>
&lt;h2 id="module-mode">Module mode
&lt;a class="header-anchor" href="#module-mode">&lt;/a>
&lt;/h2>&lt;p>&lt;code>Find&amp;lt;PackageName&amp;gt;.cmake&lt;/code>&lt;/p>
&lt;p>主要是包外提供，比如 CMake、操作系统、或者写当前工程的人提供的试探性地去搜索库的方式。先找 &lt;code>CMAKE_MODULE_PATH&lt;/code>，然后就是 cmake 的安装目录。&lt;/p></description></item><item><title>chapter08 - testing</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter08-testing/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter08-testing/</guid><description>&lt;h1 id="ctest">CTest
&lt;a class="header-anchor" href="#ctest">&lt;/a>
&lt;/h1>&lt;h2 id="基本用法">基本用法
&lt;a class="header-anchor" href="#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95">&lt;/a>
&lt;/h2>&lt;p>&lt;mark>要使用 CTest 和相关的东西需要调用 &lt;code>enable_testing&lt;/code>。&lt;/mark>&lt;/p>
&lt;p>ctest 是要在 build tree 执行的。&lt;/p>
&lt;p>ctest 也能直接编译和运行（两步合为一步），但是要手动提供测试命令（有点奇怪）。&lt;/p></description></item><item><title>chapter09 - program analysis tools</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter09-program-analysis-tools/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter09-program-analysis-tools/</guid><description>&lt;h1 id="说明">说明
&lt;a class="header-anchor" href="#%e8%af%b4%e6%98%8e">&lt;/a>
&lt;/h1>&lt;p>这一章节是作者将一些分析工具以函数或内置支持的形式自动化地加入到了 CMake 构建工程的过程中了。&lt;/p>
&lt;h1 id="格式化">格式化
&lt;a class="header-anchor" href="#%e6%a0%bc%e5%bc%8f%e5%8c%96">&lt;/a>
&lt;/h1>&lt;p>clang-format&lt;/p>
&lt;h1 id="静态检查">静态检查
&lt;a class="header-anchor" href="#%e9%9d%99%e6%80%81%e6%a3%80%e6%9f%a5">&lt;/a>
&lt;/h1>&lt;ol>
&lt;li>clang-tidy&lt;/li>
&lt;li>cpplint（按照 Google Coding Style 检查）&lt;/li>
&lt;li>cppcheck&lt;/li>
&lt;li>include-what-you-use&lt;/li>
&lt;li>link what you use（CMake 内置）&lt;/li>
&lt;/ol>
&lt;p>静态检查受到 CMake 的直接支持：&lt;/p></description></item><item><title>chapter10 - documents</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter10-documents/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter10-documents/</guid><description>&lt;h1 id="adding-doxygen-to-your-project">Adding Doxygen to your project
&lt;a class="header-anchor" href="#adding-doxygen-to-your-project">&lt;/a>
&lt;/h1>&lt;p>安装必要软件包：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>apt-get install doxygen graphviz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后就能在 CMake 中引入 Doxygen 包并使用 &lt;code>doxygen_add_docs&lt;/code>。&lt;/p>
&lt;blockquote>
 &lt;p>Since CMake 3.9, we can use the &lt;code>doxygen_add_docs()&lt;/code> function from &lt;code>FindDoxygen&lt;/code> find-module, which sets the documentation target up.&lt;/p>
&lt;p>注意 FindDoxygen module 推荐使用方式是 find_package，虽然可以 include 但是不推荐。&lt;/p></description></item><item><title>chapter11 - installing and packaging</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter11-installing-and-packaging/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter11-installing-and-packaging/</guid><description>&lt;h1 id="exporting-without-installation">Exporting without installation
&lt;a class="header-anchor" href="#exporting-without-installation">&lt;/a>
&lt;/h1>&lt;p>使用 &lt;code>export&lt;/code> 命令可以创建导出文件，然后其他工程只要 include 这个导出文件就能使用当前这个包中的 target，而不需要先将这个包用 &lt;code>install&lt;/code> 安装在系统里。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">export&lt;/span>(&lt;span style="color:#2aa198">TARGETS&lt;/span> &lt;span style="color:#2aa198">[target1&lt;/span> &lt;span style="color:#2aa198">[target2&lt;/span> &lt;span style="color:#2aa198">[...]]]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">[NAMESPACE&lt;/span> &lt;span style="color:#2aa198">&amp;lt;namespace&amp;gt;]&lt;/span> &lt;span style="color:#2aa198">[APPEND]&lt;/span> &lt;span style="color:#2aa198">FILE&lt;/span> &lt;span style="color:#2aa198">&amp;lt;path&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">[EXPORT_LINK_INTERFACE_LIBRARIES]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
 &lt;p>&lt;code>NAMESPACE&lt;/code> is recommended as a hint, stating that the target has been imported from other projects.&lt;/p></description></item><item><title>chapter11.a - 对比 export 和 install 命令</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter11.a-%E5%AF%B9%E6%AF%94-export-%E5%92%8C-install-%E5%91%BD%E4%BB%A4/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter11.a-%E5%AF%B9%E6%AF%94-export-%E5%92%8C-install-%E5%91%BD%E4%BB%A4/</guid><description>&lt;p>&lt;code>export&lt;/code> 和 &lt;code>install&lt;/code> 命令都有 &lt;code>TARGETS&lt;/code> 和 &lt;code>EXPORT&lt;/code> 两种参数形式，所以容易混淆：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">export&lt;/span> (&lt;span style="color:#2aa198">TARGETS&lt;/span> &lt;span style="color:#2aa198">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 将给定的 targets 导出到 target export file，不会创建 named export
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">install&lt;/span>(&lt;span style="color:#2aa198">TARGETS&lt;/span> &lt;span style="color:#2aa198">...&lt;/span> &lt;span style="color:#2aa198">[EXPORT]&lt;/span> &lt;span style="color:#2aa198">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 如果有 EXPORT，除了安装之外，还会顺便从 targets 创建 named export（有两个作用！！这个是我是检查了 cmake_install.cmake 的）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">export&lt;/span> (&lt;span style="color:#2aa198">EXPORT&lt;/span> &lt;span style="color:#2aa198">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 将 named export 导出到文件，可以指定名字空间
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">install&lt;/span>(&lt;span style="color:#2aa198">EXPORT&lt;/span> &lt;span style="color:#2aa198">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 将 named export 安装到系统，和 &lt;span style="color:#b58900">export&lt;/span>(&lt;span style="color:#2aa198">EXPORT&lt;/span> &lt;span style="color:#2aa198">...&lt;/span>) 有相似的参数，同样可以指定名字空间
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>export&lt;/code> 命令用来导出 target export file。&lt;code>install&lt;/code> 命令用来安装文件到系统。在 target export file 的场景下，两者都能用于“安装”，但是前者一般是用在安装在临时路径上（参考 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/modern-cmake-for-cpp/chapter11-installing-and-packaging/#exporting-without-installation" title="Exporting without installation" >Exporting without installation&lt;/a>），而后者是用来安装进系统的。&lt;/p></description></item><item><title>chapter12 - full project</title><link>https://hxhue.github.io/modern-cmake-for-cpp/chapter12-full-project/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/modern-cmake-for-cpp/chapter12-full-project/</guid><description>&lt;h1 id="总体结构">总体结构
&lt;a class="header-anchor" href="#%e6%80%bb%e4%bd%93%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h1>&lt;p>






&lt;img src="https://hxhue.github.io/assets/910d063161cd1f14c4743331743ba2d5.webp">&lt;/p>
&lt;h1 id="一些文件的分析">一些文件的分析
&lt;a class="header-anchor" href="#%e4%b8%80%e4%ba%9b%e6%96%87%e4%bb%b6%e7%9a%84%e5%88%86%e6%9e%90">&lt;/a>
&lt;/h1>&lt;p>chapter12/01-full-project/src/calc/CMakeLists.txt&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">add_library&lt;/span>(&lt;span style="color:#2aa198">calc_obj&lt;/span> &lt;span style="color:#2aa198">OBJECT&lt;/span> &lt;span style="color:#2aa198">calc.cpp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">target_include_directories&lt;/span>(&lt;span style="color:#2aa198">calc_obj&lt;/span> &lt;span style="color:#2aa198">INTERFACE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;$&amp;lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;$&amp;lt;INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">set_target_properties&lt;/span>(&lt;span style="color:#2aa198">calc_obj&lt;/span> &lt;span style="color:#2aa198">PROPERTIES&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">PUBLIC_HEADER&lt;/span> &lt;span style="color:#2aa198">src/calc/include/calc/calc.h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">POSITION_INDEPENDENT_CODE&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">add_library&lt;/span>(&lt;span style="color:#2aa198">calc_shared&lt;/span> &lt;span style="color:#2aa198">SHARED&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">target_link_libraries&lt;/span>(&lt;span style="color:#2aa198">calc_shared&lt;/span> &lt;span style="color:#2aa198">calc_obj&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">add_library&lt;/span>(&lt;span style="color:#2aa198">calc_static&lt;/span> &lt;span style="color:#2aa198">STATIC&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">target_link_libraries&lt;/span>(&lt;span style="color:#2aa198">calc_static&lt;/span> &lt;span style="color:#2aa198">calc_obj&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一些要点：&lt;/p>
&lt;ol>
&lt;li>target_include_directories 使用生成器表达式为 build 和 install 之后指定了不同的包含路径。导出 target export file 的话这个细节非常重要。&lt;/li>
&lt;li>然后是设置对象的属性。因为我们的库不是 SHARED 类型而是 OBJECT 类型，所以不是默认 PIC 的。需要正确设置 POSITION_INDEPENDENT_CODE 属性（我们实验室项目是在全局编译选项中加入 &lt;code>-fPIC&lt;/code> 保证这一点的）。&lt;/li>
&lt;/ol>
&lt;p>chapter12/01-full-project/cmake/GetFTXUI.cmake&lt;/p></description></item><item><title>C++ 模板显式实例化</title><link>https://hxhue.github.io/posts/programming/cpp/C++-%E6%A8%A1%E6%9D%BF%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++-%E6%A8%A1%E6%9D%BF%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96/</guid><description>&lt;p>头文件：template.hpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#ifndef TEMPLATE_HPP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#define TEMPLATE_HPP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> T&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> println(T t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>源文件：main.cpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;#34;template.hpp&amp;#34;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#2aa198">9&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">7&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>源文件：instantiation.cpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;#34;template.hpp&amp;#34;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> T&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> println(T t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> t &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 特化声明：失败，因为没有定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// template &amp;lt;&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// void println&amp;lt;int&amp;gt;(int);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 显式实例化：成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> println&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>(&lt;span style="color:#dc322f">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// template void println(int); // 如果能够从函数参数中推导出模板参数，也可以省略模板参数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 特化定义：成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// template &amp;lt;&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// void println&amp;lt;int&amp;gt;(int t) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// std::cout &amp;lt;&amp;lt; &amp;#34;instantiation.cpp: &amp;#34; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// }
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>翻译单元 A 要调用模板函数：&lt;/p></description></item><item><title>C++ 重定向输出的几种方案：iostream rdbuf、stdio freopen、unix fd</title><link>https://hxhue.github.io/posts/programming/cpp/C++-%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88iostream-rdbufstdio-freopenunix-fd/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++-%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88iostream-rdbufstdio-freopenunix-fd/</guid><description>&lt;p>在看 Modern CMake for C++ 的时候看到了这段代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">RunOutputsCorrectEquations&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string expected {&lt;span style="color:#2aa198">&amp;#34;2 + 2 = 4&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">3 * 3 = 9&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stringstream buffer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// redirect cout
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">auto&lt;/span> prevcoutbuf &lt;span style="color:#719e07">=&lt;/span> cout.rdbuf(buffer.rdbuf());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> output &lt;span style="color:#719e07">=&lt;/span> buffer.str();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// restore original buffer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> cout.rdbuf(prevcoutbuf);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (expected &lt;span style="color:#719e07">!=&lt;/span> output)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit(&lt;span style="color:#2aa198">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看起来 stdio 的 FILE 也能重定向（但是不能保存之前的关联，因而恢复到 stdout 不能跨平台）：&lt;/p></description></item><item><title>inttypes.h</title><link>https://hxhue.github.io/posts/programming/cpp/inttypes.h/</link><pubDate>Sun, 17 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/inttypes.h/</guid><description>&lt;p>包含了 &lt;code>stdint.h&lt;/code>，同时还有一些格式字符串宏帮助写可移植的 &lt;code>scanf&lt;/code>/&lt;code>printf&lt;/code> 代码。&lt;/p></description></item><item><title>C 语言算术运算的类型提升</title><link>https://hxhue.github.io/posts/programming/cpp/C-%E8%AF%AD%E8%A8%80%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87/</link><pubDate>Thu, 16 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C-%E8%AF%AD%E8%A8%80%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87/</guid><description>&lt;p>&lt;a href="https://stackoverflow.com/a/5563131/" title="https://stackoverflow.com/a/5563131/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/5563131/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">if&lt;/span>&lt;span style="color:#719e07">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">double&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">double&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">double&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">double&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">float&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">float&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">int&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Otherwise:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>both operands are promoted to &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>inline namespace</title><link>https://hxhue.github.io/posts/programming/cpp/inline-namespace/</link><pubDate>Sun, 12 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/inline-namespace/</guid><description>&lt;p>&lt;a href="https://en.cppreference.com/w/cpp/language/namespace" title="Namespaces - cppreference.com" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Namespaces - cppreference.com&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>inline namespace 既本身存在，又将所有内容引入外围（enclosing）名字空间中。相当于名字空间后面加了一句：&lt;code>using namespace X;&lt;/code>&lt;/p>
&lt;p>例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">inline&lt;/span> &lt;span style="color:#719e07">namespace&lt;/span> A {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">using&lt;/span> Int &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A&lt;span style="color:#719e07">::&lt;/span>Int a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Int b; &lt;span style="color:#586e75">// 也能成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>用 std::variant 的坑</title><link>https://hxhue.github.io/posts/programming/cpp/%E7%94%A8-variant-%E7%9A%84%E5%9D%91/</link><pubDate>Fri, 03 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E7%94%A8-variant-%E7%9A%84%E5%9D%91/</guid><description>&lt;h1 id="decltype-推导可能带有--属性">decltype 推导可能带有 &lt;code>&amp;amp;&lt;/code> 属性
&lt;a class="header-anchor" href="#decltype-%e6%8e%a8%e5%af%bc%e5%8f%af%e8%83%bd%e5%b8%a6%e6%9c%89--%e5%b1%9e%e6%80%a7">&lt;/a>
&lt;/h1>&lt;p>被 &lt;code>decltype&lt;/code> 坑了很多次。推导出来可能有引用类型，想要值类型时需要先去掉！&lt;/p>
&lt;h1 id="不同的-variant-在-visitor-的参数里必须独立">不同的 variant 在 visitor 的参数里必须独立
&lt;a class="header-anchor" href="#%e4%b8%8d%e5%90%8c%e7%9a%84-variant-%e5%9c%a8-visitor-%e7%9a%84%e5%8f%82%e6%95%b0%e9%87%8c%e5%bf%85%e9%a1%bb%e7%8b%ac%e7%ab%8b">&lt;/a>
&lt;/h1>&lt;p>&lt;code>std::visit&lt;/code> 的多个参数必须独立和模板参数匹配（或者 lambda 和 C++20 函数的 auto），所以即便是要求两个类型相等，也必须写成这样：&lt;/p></description></item><item><title>阻止一个模板类被实例化并给出错误信息</title><link>https://hxhue.github.io/posts/programming/cpp/%E9%98%BB%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%B9%B6%E7%BB%99%E5%87%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/</link><pubDate>Thu, 02 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E9%98%BB%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%B9%B6%E7%BB%99%E5%87%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/</guid><description>&lt;p>注意，这个类作为（不完整）类型出现在别的模板的参数中是可以的，只有访问成员才会出错。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> Target&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">FindValue&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>Target, TypeList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">static&lt;/span> &lt;span style="color:#268bd2">inline&lt;/span> &lt;span style="color:#719e07">constexpr&lt;/span> &lt;span style="color:#dc322f">bool&lt;/span> ALWAYS_FALSE &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">sizeof&lt;/span>(Target) &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">static_assert&lt;/span>(ALWAYS_FALSE, &lt;span style="color:#2aa198">&amp;#34;Unsupported type! Check `proj::detail::DataTypeList`.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://stackoverflow.com/a/40472836/" title="https://stackoverflow.com/a/40472836/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/40472836/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>任何类型要么是不完整类型，无法被 sizeof 评估（会报错），要么被评估为正整数（包括 void 也会被评估为 1）。用 -1 的话会有类型转换警告，所以用 0 就好了。&lt;/p></description></item><item><title>VS Code CMake 工程中 C++ 提示不正常</title><link>https://hxhue.github.io/posts/developer/vscode/VS-Code-CMake-%E5%B7%A5%E7%A8%8B%E4%B8%AD-C++-%E6%8F%90%E7%A4%BA%E4%B8%8D%E6%AD%A3%E5%B8%B8/</link><pubDate>Thu, 26 Oct 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/VS-Code-CMake-%E5%B7%A5%E7%A8%8B%E4%B8%AD-C++-%E6%8F%90%E7%A4%BA%E4%B8%8D%E6%AD%A3%E5%B8%B8/</guid><description>&lt;h1 id="如果用-intellisense">如果用 Intellisense
&lt;a class="header-anchor" href="#%e5%a6%82%e6%9e%9c%e7%94%a8-intellisense">&lt;/a>
&lt;/h1>&lt;p>以文件 &lt;code>.vscode/c_cpp_properties.json&lt;/code> 中 &lt;code>configuration&lt;/code> 的 &lt;code>configurationProvider&lt;/code> 的值来分类。&lt;/p>
&lt;h2 id="ms-vscodecmake-tools">ms-vscode.cmake-tools
&lt;a class="header-anchor" href="#ms-vscodecmake-tools">&lt;/a>
&lt;/h2>&lt;p>&lt;strong>缺点：文件不在编译数据库中时 include 路径不正确（对新文件不友好）&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>&lt;code>configurationProvider&lt;/code> 是 &lt;code>ms-vscode.cmake-tools&lt;/code> 时&lt;/strong>，&lt;code>compileCommands&lt;/code> 和 &lt;code>includePath&lt;/code> 设置是无效的。这个时候如果 &lt;code>compile_commands.json&lt;/code> （编译数据库）中没有这个文件（尤其是 &lt;code>CMakeLists.txt&lt;/code> 中可能尚未加入新编写的文件的情况），或者编译数据库尚未配置（需要先编译生成一次)，include 路径就不正确。&lt;/p></description></item><item><title>不同语言闭包的捕获方式</title><link>https://hxhue.github.io/posts/unsorted/%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%9A%84%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F/</link><pubDate>Thu, 12 Oct 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/unsorted/%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%9A%84%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F/</guid><description>&lt;h1 id="总览">总览
&lt;a class="header-anchor" href="#%e6%80%bb%e8%a7%88">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>C++ 根据在捕获列表中标注的方式进行捕获。&lt;/li>
&lt;li>Java 按照值捕获（而且 Java 在某些情况下还要求显式的 final 修饰符）。&lt;/li>
&lt;li>JavaScript：见 
 
 &lt;a href="https://hxhue.github.io/posts/unsorted/%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%9A%84%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F#javascript-%e6%8d%95%e8%8e%b7" title="JavaScript 捕获" >JavaScript 捕获&lt;/a>。
&lt;ul>
&lt;li>注意：捕获和传值是不同的！例如：JavaScript 在函数参数传递时仍然时按照值传递。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Python/Go 按照引用捕获，for 循环不会创造新的作用域。&lt;/li>
&lt;/ul>
&lt;h1 id="javascript-捕获">JavaScript 捕获
&lt;a class="header-anchor" href="#javascript-%e6%8d%95%e8%8e%b7">&lt;/a>
&lt;/h1>&lt;p>看上去是引用捕获，但是 for 循环的 let 和 const 绑定会创造新的作用域。&lt;/p></description></item><item><title>(libstdc++ vs libc++) std::tuple</title><link>https://hxhue.github.io/posts/programming/cpp/libstdc++-vs-libc++-std_tuple/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libstdc++-vs-libc++-std_tuple/</guid><description>&lt;h1 id="列表构造顺序">列表构造顺序
&lt;a class="header-anchor" href="#%e5%88%97%e8%a1%a8%e6%9e%84%e9%80%a0%e9%a1%ba%e5%ba%8f">&lt;/a>
&lt;/h1>&lt;p>&lt;code>libstdc++&lt;/code> 用的是递归反向构造，尾部的参数先构造。与之对应，&lt;code>libc++&lt;/code> 用的是 parameter pack 继承，是正向构造。&lt;/p>
&lt;h1 id="下标编号">下标编号
&lt;a class="header-anchor" href="#%e4%b8%8b%e6%a0%87%e7%bc%96%e5%8f%b7">&lt;/a>
&lt;/h1>&lt;p>两者都使用了下标编号。这样即便 &lt;code>std::tuple&lt;/code> 的某两个参数类型相同，也能通过不同的下标把两个元素区分开。&lt;/p></description></item><item><title>(libstdc++) std::function</title><link>https://hxhue.github.io/posts/programming/cpp/libstdc++-std_function/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libstdc++-std_function/</guid><description>&lt;p>涉及的 libstdc++ 源码文件：&lt;code>bits/std_function.h&lt;/code>。&lt;/p>
&lt;p>印象： &lt;code>std::function&lt;/code> 做了小对象优化，同时在避免使用虚函数（尽管它可以用继承和虚函数来实现）。&lt;/p>
&lt;p>关于成员指针，见 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/posts/programming/cpp/Pointer-to-Member/" title="Pointer to Member" >Pointer to Member&lt;/a>。&lt;/p></description></item><item><title>(libstdc++) std::set</title><link>https://hxhue.github.io/posts/programming/cpp/libstdc++-std_set/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libstdc++-std_set/</guid><description>&lt;p>相关文件：&lt;/p>
&lt;ul>
&lt;li>&lt;code>include/set&lt;/code> 头文件按顺序引入了 &lt;code>include/bits/stl_tree.h&lt;/code> 和 &lt;code>include/bits/stl_set.h&lt;/code>。&lt;/li>
&lt;li>&lt;code>include/bits/stl_set.h&lt;/code> 定义了 &lt;code>std::set&lt;/code>，依赖了 &lt;code>include/bits/stl_tree.h&lt;/code> 却没有明确包含它。&lt;/li>
&lt;li>&lt;code>include/bits/stl_tree.h&lt;/code> 定义了诸多类型，&lt;em>如未明确指出则默认下面提到的类型都是来自于这个头文件&lt;/em>。&lt;/li>
&lt;li>&lt;code>src/c++98/tree.cc&lt;/code> 实现了红黑树用到的非模板算法。这个文件只有 400 多行。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>std::set&lt;/code> 将实现转发给 &lt;code>_Rb_tree&lt;/code> 处理，而它又将实现转发给了 &lt;code>_Rb_tree_impl&lt;/code> 处理。&lt;/p></description></item><item><title>📌 C++ 对象模型开销总结</title><link>https://hxhue.github.io/inside-the-cpp-object-model/C++-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%BC%80%E9%94%80%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/C++-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%BC%80%E9%94%80%E6%80%BB%E7%BB%93/</guid><description>&lt;p>&lt;strong>下面都是在 Linux 上测试，处理器架构为 x86-64，用的 Itanium C++ ABI&lt;/strong>。&lt;/p>
&lt;div class="markdown-alert markdown-alert-caution">
 &lt;p class="markdown-alert-title">&lt;svg class="octicon octicon-stop mr-2" viewBox="0 0 16 16" width="16" height="16"
 aria-hidden="true">
 &lt;path
 d="M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
 &lt;/path>
 &lt;/svg>Caution&lt;/p></description></item><item><title>📌 vtable</title><link>https://hxhue.github.io/inside-the-cpp-object-model/vtable/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/vtable/</guid><description>&lt;h1 id="tldr-性能开销">TL;DR 性能开销
&lt;a class="header-anchor" href="#tldr-%e6%80%a7%e8%83%bd%e5%bc%80%e9%94%80">&lt;/a>
&lt;/h1>&lt;p>在不开启优化选项时编译：&lt;/p>
&lt;ol>
&lt;li>每次调用虚函数比普通函数多两次访存。&lt;/li>
&lt;li>每次动态类型转换（除非类型精确命中）都是耗时的图搜索算法。&lt;/li>
&lt;li>明确需要精确转换时用 &lt;code>std::type_index&lt;/code> 和 &lt;code>static_cast&lt;/code> 会更快。&lt;/li>
&lt;/ol>
&lt;p>相关代码下载：&lt;/p></description></item><item><title>📌 非自动变量初始化</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E9%9D%9E%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E9%9D%9E%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>&lt;h1 id="c-和-c-thread_local-的区别">C++ 和 C &lt;code>thread_local&lt;/code> 的区别
&lt;a class="header-anchor" href="#c-%e5%92%8c-c-thread_local-%e7%9a%84%e5%8c%ba%e5%88%ab">&lt;/a>
&lt;/h1>&lt;ol>
&lt;li>C++ 支持使用非常量表达式对全局或静态变量初始化 &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。对于 &lt;code>static&lt;/code> local &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> / &lt;code>thread_local&lt;/code> 变量而言，这项功能需要在访问前检查变量是否已经完成初始化，&lt;strong>&lt;code>thread_local&lt;/code> 初始化不需要线程间同步，而 &lt;code>static&lt;/code> local 变量的访问过程需要线程间的同步（&lt;code>__cxa_guard_acquire&lt;/code> 和 &lt;code>__cxa_guard_release&lt;/code>）&lt;/strong>。&lt;/li>
&lt;li>C++ 的 &lt;code>thread_local&lt;/code> 变量&lt;strong>在函数作用域中&lt;/strong>自动具有 &lt;code>static&lt;/code> 属性 &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>，而 C 要手动加。在 C 语言中，函数中的 &lt;code>thread_local&lt;/code> 必须和 &lt;code>extern&lt;/code> 或者 &lt;code>static&lt;/code> 之一一起使用，例子为 &lt;a href="https://godbolt.org/z/eKz71xh7a" title="https://godbolt.org/z/eKz71xh7a" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://godbolt.org/z/eKz71xh7a&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 。&lt;/li>
&lt;li>C 的 &lt;code>thread_local&lt;/code> 在 C23 之前是个宏。&lt;/li>
&lt;/ol>
&lt;h1 id="从代价上来看-c-的几种变量初始化">从代价上来看 C++ 的几种变量初始化
&lt;a class="header-anchor" href="#%e4%bb%8e%e4%bb%a3%e4%bb%b7%e4%b8%8a%e6%9d%a5%e7%9c%8b-c-%e7%9a%84%e5%87%a0%e7%a7%8d%e5%8f%98%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>首先，不需要函数初始化的在编译期间就能完成工作，没有代价。&lt;strong>所以以下讨论的都是通过函数或构造函数来初始化的变量&lt;/strong>。&lt;/li>
&lt;li>其次，函数内 (static) thread_local 变量只需要在使用前检查一下，构造和使用都不用同步，代价很小。函数内 static 变量的构造和使用则需要线程之间同步。&lt;/li>
&lt;li>函数外定义的普通变量和 thread_local 变量都不需要任何同步就能在静态初始化阶段完成初始化，使用时也不需要检查。&lt;/li>
&lt;li>函数外定义的 inline 变量（C++17）在使用时不需要同步，但是在初始化的时候要检查是否已经初始化完成（为此有个 guard variable 标记）。见 &lt;a href="https://godbolt.org/z/hYMjdbsxj" title="https://godbolt.org/z/hYMjdbsxj" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://godbolt.org/z/hYMjdbsxj&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> ，这可能是因为 inline 变量可能被多个地方使用，每个地方都要提防重复初始化。&lt;/li>
&lt;/ul>
&lt;h1 id="全局-和-static-变量">全局 (和 static) 变量
&lt;a class="header-anchor" href="#%e5%85%a8%e5%b1%80-%e5%92%8c-static-%e5%8f%98%e9%87%8f">&lt;/a>
&lt;/h1>&lt;p>最外围定义域定义的变量，可以具有 static 属性也可以没有。&lt;/p></description></item><item><title>Abominable Function</title><link>https://hxhue.github.io/posts/programming/cpp/Abominable-Function/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Abominable-Function/</guid><description>&lt;p>在 &lt;a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html" title="Abominable Function Types (open-std.org)" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Abominable Function Types (open-std.org)&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 中：&lt;/p>
&lt;blockquote>
 &lt;p>For the purposes of this paper, an &lt;em>abominable&lt;/em> function type is the type produced by writing a function type followed by a &lt;em>cv-ref&lt;/em> qualifier. Example:
&lt;code>using regular = void();&lt;/code>
&lt;code>using abominable = void() const volatile &amp;amp;&amp;amp;;&lt;/code>&lt;/p>
&lt;/blockquote>&lt;p>通过一些模板手段能把类中的成员函数转换成可憎函数（怎么翻译更合适？）。可憎函数形式复杂，模板匹配困难。C++23 explicit object parameter (deducing this) 可以一定程度上解决这个问题。&lt;/p></description></item><item><title>ADL</title><link>https://hxhue.github.io/posts/programming/cpp/ADL/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/ADL/</guid><description>&lt;p>例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;numeric&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    std&lt;span style="color:#719e07">::&lt;/span>vector v{&lt;span style="color:#2aa198">1&lt;/span>, &lt;span style="color:#2aa198">3&lt;/span>, &lt;span style="color:#2aa198">5&lt;/span>}; &lt;span style="color:#586e75">// 模板类参数推导：T=int
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>    std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>accumulate(begin(v), end(v), &lt;span style="color:#2aa198">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#586e75">// ^^ ^^ ^^ 都是ADL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>begin&lt;/code>、&lt;code>end&lt;/code>、&lt;code>swap&lt;/code> 等函数模板时，先引入其名字到当前空间中，然后再调用，有助于 ADL 查找到性能更优的函数实现：&lt;/p></description></item><item><title>Aggregate</title><link>https://hxhue.github.io/posts/programming/cpp/Aggregate/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Aggregate/</guid><description>&lt;p>






&lt;img src="https://hxhue.github.io/assets/06486f8b0865616fe9a68551e46d4412.webp">&lt;/p>
&lt;p>注意，有 &lt;strong>bit fields&lt;/strong> 或者 &lt;strong>有成员默认值&lt;/strong> 或者 &lt;strong>有匿名 union 成员&lt;/strong> 也可以是 aggregate。&lt;/p>
&lt;p>对含有 union 成员的聚合类使用 &lt;em>花括号&lt;/em> 或 &lt;em>默认的全参数构造函数&lt;/em> 初始化时，初始化的是 union 的第一个元素（不管 union 是不是匿名的）。&lt;/p></description></item><item><title>auto + decltype</title><link>https://hxhue.github.io/posts/programming/cpp/auto-+-decltype/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/auto-+-decltype/</guid><description>&lt;h1 id="用于标注函数返回值">用于标注函数返回值
&lt;a class="header-anchor" href="#%e7%94%a8%e4%ba%8e%e6%a0%87%e6%b3%a8%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e5%80%bc">&lt;/a>
&lt;/h1>&lt;p>令人意外的是：C++14 加入的返回值推导是一种特殊的类型，和前向声明并不兼容。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">known&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">auto&lt;/span> &lt;span style="color:#268bd2">known&lt;/span>() { &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">42&lt;/span>; } &lt;span style="color:#586e75">// 错误：类型不兼容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// int known() { return 42; } // ok
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// auto known() -&amp;gt; int { return 42; } // ok
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样：&lt;/p></description></item><item><title>C/C++ 全局定义应该放在 .bss 还是 .data</title><link>https://hxhue.github.io/posts/programming/cpp/C-%E5%92%8C-C++-%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8-.bss-%E8%BF%98%E6%98%AF-.data/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C-%E5%92%8C-C++-%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8-.bss-%E8%BF%98%E6%98%AF-.data/</guid><description>&lt;h1 id="cc-中全局定义声明的区别">C/C++ 中全局定义/声明的区别
&lt;a class="header-anchor" href="#cc-%e4%b8%ad%e5%85%a8%e5%b1%80%e5%ae%9a%e4%b9%89%e5%a3%b0%e6%98%8e%e7%9a%84%e5%8c%ba%e5%88%ab">&lt;/a>
&lt;/h1>&lt;p>无论在 C 还是 C++，想要仅声明而不在翻译单元中定义全局变量，都需要 extern。&lt;/p>
&lt;p>&lt;strong>C语言&lt;/strong>：（强弱是方便我叙述引出的概念）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> global &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>; &lt;span style="color:#586e75">// 强定义，和其他强定义互斥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#dc322f">int&lt;/span> global;     &lt;span style="color:#586e75">// 弱定义，可以和同文件其他定义兼容（最终只保留一份定义）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#dc322f">int&lt;/span> global;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>能编译！但是上面的代码和其他目标文件一起链接时，若出现多次定义同样会引发重复定义的错误。&lt;/p></description></item><item><title>C++ 几种新增类型转换的区别 + 标准库模板函数</title><link>https://hxhue.github.io/posts/programming/cpp/C++-%E5%87%A0%E7%A7%8D%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB-+-%E6%A0%87%E5%87%86%E5%BA%93%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++-%E5%87%A0%E7%A7%8D%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB-+-%E6%A0%87%E5%87%86%E5%BA%93%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</guid><description>&lt;h1 id="四大关键字">四大关键字
&lt;a class="header-anchor" href="#%e5%9b%9b%e5%a4%a7%e5%85%b3%e9%94%ae%e5%ad%97">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>&lt;code>static_cast&lt;/code> 大多数转换，包括左右值转换、&lt;strong>父子类指针/引用之间的转换&lt;/strong>（不进行安全检查，但会修正指针偏移）。&lt;/li>
&lt;li>&lt;code>const_cast&lt;/code> 也能进行 volatile 属性的修改！！&lt;/li>
&lt;li>&lt;code>dynamic_cast&lt;/code> 父子类指针/引用之间的转换。其中子类转向基类相当于使用 &lt;code>static_cast&lt;/code> ，没有运行时安全检查。而基类转向子类则有运行时安全检查，而且要求基类是多态类，否则无法编译。&lt;/li>
&lt;li>&lt;code>reinterpret_cast&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="标准库的共享指针转换模板">标准库的共享指针转换模板
&lt;a class="header-anchor" href="#%e6%a0%87%e5%87%86%e5%ba%93%e7%9a%84%e5%85%b1%e4%ba%ab%e6%8c%87%e9%92%88%e8%bd%ac%e6%8d%a2%e6%a8%a1%e6%9d%bf">&lt;/a>
&lt;/h1>&lt;p>标准库中还有针对于 &lt;code>std::shared_ptr&lt;/code> 的类型转换模板。转换后返回一个共享指针，但其包裹的类型被转换成了对应的类型：&lt;/p></description></item><item><title>C++23 std::forward_like</title><link>https://hxhue.github.io/posts/programming/cpp/C++23-std_forward_like/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++23-std_forward_like/</guid><description>&lt;p>&lt;code>std::forward&lt;/code> 需要我们提供一个模板参数，它能把同类型（不包括值类别）的参数转发出去。&lt;/p>
&lt;p>&lt;code>std::forward_like&lt;/code> 则有两个模板参数，第一个参数需要显式提供，第二个参数从实参中推导。它从模板参数中获得转发需要使用的引用类型，并将实参转发出去。&lt;strong>这意味着实参和模板参数的类型可以不一致！&lt;/strong>&lt;/p></description></item><item><title>Cfront 如何插入构造函数</title><link>https://hxhue.github.io/inside-the-cpp-object-model/Cfront-%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/Cfront-%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid><description>&lt;p>实际上复制构造函数的插入比较困难，比如在函数返回和传参的时候。由于 C 语言是按位复制（而不是按成员），cfront 会在函数调用前插入返回值变量声明，在函数中使用局部变量运算，并在返回时调用复制构造函数从局部变量复制成员到返回值处。&lt;/p></description></item><item><title>cppreference 协程例子理解</title><link>https://hxhue.github.io/posts/programming/cpp/cppreference-%E5%8D%8F%E7%A8%8B%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/cppreference-%E5%8D%8F%E7%A8%8B%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3/</guid><description>&lt;p>我的理解是：C++ 的协程是无栈的，这意味着协程只是计算任务，仅在运行时需要栈，在 suspend 之后就会保存状态并脱离栈。要想要跨线程转移计算任务（比如实现工作窃取池），只需要将离栈协程在另外一个线程上 resume 即可。&lt;/p></description></item><item><title>CTTCG 01 Function Templates</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/01-Function-Templates/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/01-Function-Templates/</guid><description>&lt;p>2023 年 5 月 7 日&lt;/p>
&lt;h1 id="两个-type-traits">两个 type traits
&lt;a class="header-anchor" href="#%e4%b8%a4%e4%b8%aa-type-traits">&lt;/a>
&lt;/h1>&lt;p>&lt;code>std::decay_t&lt;/code> 可以去引用、去限定符、函数/数组变指针；&lt;code>std::common_type_t&lt;/code> 用三元运算符获得更“宽泛”类型。&lt;/p>
&lt;h1 id="函数模板默认参数">函数模板默认参数
&lt;a class="header-anchor" href="#%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0">&lt;/a>
&lt;/h1>&lt;p>模板默认参数可以放在最前面，不像普通函数只能把带有默认值的参数放在最后。而且函数模板可以明确指定开头几个参数，让后面的参数由推导规则生成。&lt;/p></description></item><item><title>CTTCG 02 Class Templates</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/02-Class-Templates/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/02-Class-Templates/</guid><description>&lt;p>2023 年 5 月 7 日&lt;/p>
&lt;h1 id="定义位置">定义位置
&lt;a class="header-anchor" href="#%e5%ae%9a%e4%b9%89%e4%bd%8d%e7%bd%ae">&lt;/a>
&lt;/h1>&lt;p>类模板只能在全局或者类声明中定义，不能在块或者函数中定义。&lt;/p>
&lt;h1 id="类模板外函数定义的写法">类模板外函数定义的写法
&lt;a class="header-anchor" href="#%e7%b1%bb%e6%a8%a1%e6%9d%bf%e5%a4%96%e5%87%bd%e6%95%b0%e5%ae%9a%e4%b9%89%e7%9a%84%e5%86%99%e6%b3%95">&lt;/a>
&lt;/h1>&lt;p>类模板中定义函数，T 类型参数可以省略；在类模板中声明，但在外提供函数定义，就需要在定义处给出完整的类型参数：&lt;/p></description></item><item><title>CTTCG 03 Nontype Template Parameters</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/03-Nontype-Template-Parameters/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/03-Nontype-Template-Parameters/</guid><description>&lt;p>模板参数也可以不是类型，而是值。&lt;/p>
&lt;h1 id="非类型参数推导只对直接调用有效">非类型参数推导只对直接调用有效
&lt;a class="header-anchor" href="#%e9%9d%9e%e7%b1%bb%e5%9e%8b%e5%8f%82%e6%95%b0%e6%8e%a8%e5%af%bc%e5%8f%aa%e5%af%b9%e7%9b%b4%e6%8e%a5%e8%b0%83%e7%94%a8%e6%9c%89%e6%95%88">&lt;/a>
&lt;/h1>&lt;p>模板函数的类型推导只对立即调用有效，而对算法模板这类需要提前知道类型信息的场合无效。比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#719e07">::&lt;/span>transform (source.begin(), source.end(), &lt;span style="color:#586e75">// start and end of source
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> dest.begin(), &lt;span style="color:#586e75">// start of destination
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> addValue&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#2aa198">5&lt;/span>,&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>); &lt;span style="color:#586e75">// operation
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码中尽管 &lt;code>addValue&lt;/code> 的参数可能可以推导出来，但由于 &lt;code>std::transform&lt;/code> 要求提前知道函数的类型，去掉参数之后代码无法编译。&lt;/p></description></item><item><title>CTTCG 04 Variadic Templates</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/04-Variadic-Templates/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/04-Variadic-Templates/</guid><description>&lt;blockquote>
 &lt;p>可变长表达式可以对参数包逐个处理。与折叠表达式（相当于函数式编程中的 &lt;strong>reduce&lt;/strong>，但如果用上逗号表达式就能表达 &lt;strong>foreach&lt;/strong>）不同，可变长表达式（相当于函数式编程中的 &lt;strong>map&lt;/strong>）不会改变参数数量，允许的形式也比折叠表达式宽松一点。&lt;/p></description></item><item><title>CTTCG 05 Tricky Basics</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/05-Tricky-Basics/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/05-Tricky-Basics/</guid><description>&lt;h1 id="1-使用关键字引导编译器了解成员类型">1 使用关键字引导编译器了解成员类型
&lt;a class="header-anchor" href="#1-%e4%bd%bf%e7%94%a8%e5%85%b3%e9%94%ae%e5%ad%97%e5%bc%95%e5%af%bc%e7%bc%96%e8%af%91%e5%99%a8%e4%ba%86%e8%a7%a3%e6%88%90%e5%91%98%e7%b1%bb%e5%9e%8b">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> T&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">public&lt;/span>&lt;span style="color:#719e07">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">void&lt;/span> foo() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">typename&lt;/span> T&lt;span style="color:#719e07">::&lt;/span>SubType&lt;span style="color:#719e07">*&lt;/span> ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的的代码中加了 &lt;code>typename&lt;/code> 关键字用来表示 &lt;code>SubType&lt;/code> 这个成员是一个类型。否则由于缺乏类型信息，编译器会认为该成员是某个数据域，从而构成了乘法表达式。&lt;/p></description></item><item><title>CTTCG 06 Move Semantics and enable_if</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/06-Move-Semantics-and-enable_if/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/06-Move-Semantics-and-enable_if/</guid><description>&lt;p>Perfect forwarding:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> T&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> f (T&lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> val) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> g(std&lt;span style="color:#719e07">::&lt;/span>forward&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>(val)); &lt;span style="color:#586e75">// perfect forward val to g()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，完美转发只对模板参数有效，对依赖于模板参数的类型也是无效的，比如：&lt;code>typename T::iterator&amp;amp;&amp;amp;&lt;/code> 是无效的，仍表示严格的右值引用。&lt;/p></description></item><item><title>CTTCG 07 By Value or by Reference</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/07-By-Value-or-by-Reference/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/07-By-Value-or-by-Reference/</guid><description>&lt;h1 id="传值t">传值：&lt;code>T&lt;/code>
&lt;a class="header-anchor" href="#%e4%bc%a0%e5%80%bct">&lt;/a>
&lt;/h1>&lt;p>有 decay。&lt;/p>
&lt;h1 id="传左值引用t-">传左值引用：&lt;code>T &amp;amp;&lt;/code>
&lt;a class="header-anchor" href="#%e4%bc%a0%e5%b7%a6%e5%80%bc%e5%bc%95%e7%94%a8t-">&lt;/a>
&lt;/h1>&lt;p>注意遇到数组时可能需要 decay。&lt;/p>
&lt;p>注意 &lt;code>T&lt;/code> 类型可能是常量，导致 &lt;code>T &amp;amp;&lt;/code> 其实是常引用。这样的参数不能被修改，因而不能作为传出参数。可以使用 concept 限定参数非常量：&lt;/p></description></item><item><title>CTTCG 08 Compile-Time Programming</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/08-Compile-Time-Programming/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/08-Compile-Time-Programming/</guid><description>&lt;h1 id="模板元编程">模板元编程
&lt;a class="header-anchor" href="#%e6%a8%a1%e6%9d%bf%e5%85%83%e7%bc%96%e7%a8%8b">&lt;/a>
&lt;/h1>&lt;p>略。&lt;/p>
&lt;h1 id="constexpr-函数">&lt;code>constexpr&lt;/code> 函数
&lt;a class="header-anchor" href="#constexpr-%e5%87%bd%e6%95%b0">&lt;/a>
&lt;/h1>&lt;p>在 C++11 中只能使用一条语句，而在 C++14 之后可以使用的语句变得丰富。&lt;code>constexpr&lt;/code> 函数允许编译期优化，但不阻止运行期使用。作为对比，C++20 &lt;code>consteval&lt;/code> 只能在编译期使用。&lt;/p></description></item><item><title>CTTCG 09 Using Templates in Practice</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/09-Using-Templates-in-Practice/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/09-Using-Templates-in-Practice/</guid><description>&lt;h1 id="包含模型---the-inclusion-model">包含模型 - The Inclusion Model
&lt;a class="header-anchor" href="#%e5%8c%85%e5%90%ab%e6%a8%a1%e5%9e%8b---the-inclusion-model">&lt;/a>
&lt;/h1>&lt;p>通常模板需要被包含在头文件中工作。&lt;/p>
&lt;p>注意：函数模板完全特化之后也需要 inline 才能够在头文件中使用，否则会出现不同的翻译单元有重复定义的情况。&lt;/p>
&lt;h1 id="改进一precompiled-headers">改进一：precompiled headers
&lt;a class="header-anchor" href="#%e6%94%b9%e8%bf%9b%e4%b8%80precompiled-headers">&lt;/a>
&lt;/h1>&lt;p>可以把 pch 理解为编译器中间工作状态的一个 dump。编译器可以在读取到某些源代码之后保存其状态，包括符号表等。如果两个文件中有公共的前缀代码（比如一个标准库的头文件就包含了数千行公共代码），编译器就可以读取预先保存的状态，从而跳过对于这些代码的处理。&lt;/p></description></item><item><title>CTTCG 10 Basic Template Terminology</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/10-Basic-Template-Terminology/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/10-Basic-Template-Terminology/</guid><description>&lt;h1 id="class-template-vs-template-class">Class Template v.s. Template Class
&lt;a class="header-anchor" href="#class-template-vs-template-class">&lt;/a>
&lt;/h1>&lt;p>前者是生成类的模板，后者既可以指模板，又可以指从模板生成的类。&lt;/p>
&lt;h1 id="substitution-instantiation-and-specialization">Substitution, Instantiation, and Specialization
&lt;a class="header-anchor" href="#substitution-instantiation-and-specialization">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>参数替代是模板生成相应对象（即实例化）的一个中间环节。&lt;/li>
&lt;li>实例化是从模板生成相应对象的动作。&lt;/li>
&lt;li>特化是和模板形式相似但匹配程度更高的对象。特化分为实例化（生成式特化）和显式特化（explicit specialization，即人为提供特化函数）。&lt;/li>
&lt;/ul>
&lt;h1 id="declarations-versus-definitions">Declarations versus Definitions
&lt;a class="header-anchor" href="#declarations-versus-definitions">&lt;/a>
&lt;/h1>&lt;p>函数、类或变量等有了名字，但是定义不完整，就算作声明。&lt;/p></description></item><item><title>CTTCG 11 Generic Libraries</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/11-Generic-Libraries/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/11-Generic-Libraries/</guid><description>&lt;h1 id="callables">Callables
&lt;a class="header-anchor" href="#callables">&lt;/a>
&lt;/h1>&lt;p>Callable 有很多：函数、函数指针、成员函数、lambda 表达式（函数对象特例）、函数对象（Functor）等。&lt;/p>
&lt;h2 id="lambda-表达式">lambda 表达式
&lt;a class="header-anchor" href="#lambda-%e8%a1%a8%e8%be%be%e5%bc%8f">&lt;/a>
&lt;/h2>&lt;p>lambda 是函数对象。当捕获列表没有参数的时候，lambda 还有一个转换成一般函数指针的隐式转换操作符。在无捕获列表的 lambda 前加上 &lt;code>+&lt;/code> 符号，能使得 lambda 变成函数指针也就是这个道理。&lt;/p></description></item><item><title>CTTCG 12 Fundamentals in Depth</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/12-Fundamentals-in-Depth/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/12-Fundamentals-in-Depth/</guid><description>&lt;h1 id="1-参数化声明">1 参数化声明
&lt;a class="header-anchor" href="#1-%e5%8f%82%e6%95%b0%e5%8c%96%e5%a3%b0%e6%98%8e">&lt;/a>
&lt;/h1>&lt;h2 id="模板分类">模板分类
&lt;a class="header-anchor" href="#%e6%a8%a1%e6%9d%bf%e5%88%86%e7%b1%bb">&lt;/a>
&lt;/h2>&lt;p>模板有四类：类模板、函数模板、变量模板、别名模板。其中别名模板是：&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/8be842c59c3eec8f5932e5043b2fd31f.webp">&lt;/p>
&lt;h2 id="变量模板其实可以不需要-inline但是最好加上">变量模板其实可以不需要 inline（但是最好加上）
&lt;a class="header-anchor" href="#%e5%8f%98%e9%87%8f%e6%a8%a1%e6%9d%bf%e5%85%b6%e5%ae%9e%e5%8f%af%e4%bb%a5%e4%b8%8d%e9%9c%80%e8%a6%81-inline%e4%bd%86%e6%98%af%e6%9c%80%e5%a5%bd%e5%8a%a0%e4%b8%8a">&lt;/a>
&lt;/h2>&lt;p>C++17 中静态和全局变量都能够用 inline 来修饰。这也意味着类中的静态变量不必在类中声明、类外初始化（非头文件），而是可以在类中直接写 inline。之前笔记里面提到的问题里，inline 加不加都没有关系，因为变量模板本身可以在多个翻译单元中出现。P179&lt;/p></description></item><item><title>CTTCG 13 Names in Templates</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/13-Names-in-Templates/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/13-Names-in-Templates/</guid><description>&lt;h1 id="名字查找普通查找和-adl">名字查找：普通查找和 ADL
&lt;a class="header-anchor" href="#%e5%90%8d%e5%ad%97%e6%9f%a5%e6%89%be%e6%99%ae%e9%80%9a%e6%9f%a5%e6%89%be%e5%92%8c-adl">&lt;/a>
&lt;/h1>&lt;p>普通查找和 ADL 是同时进行的，不存在优先级差异。这些被找到的函数被放在一起参与重载决议。如果没有因为一般性的重载决议规则决出优劣，则会引发 ambiguous 指代错误。&lt;/p></description></item><item><title>CTTCG 15 Template Argument Deduction</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/15-Template-Argument-Deduction/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/15-Template-Argument-Deduction/</guid><description>&lt;p>2023 年 5 月 17 日&lt;/p>
&lt;h1 id="推导上下文deduced-context">推导上下文：Deduced Context
&lt;a class="header-anchor" href="#%e6%8e%a8%e5%af%bc%e4%b8%8a%e4%b8%8b%e6%96%87deduced-context">&lt;/a>
&lt;/h1>&lt;p>P272 书上&lt;/p>
&lt;ul>
&lt;li>依赖于模板类型的子类型不是推导上下文。比如 &lt;code>typename X&amp;lt;N&amp;gt;::I&lt;/code> 不是。而 &lt;code>X&amp;lt;N&amp;gt;::*&lt;/code> 这样的指向成员的指针没有用到子类型，所以是推导上下文。&lt;/li>
&lt;li>非类型模板参数的非平凡表达式不是推导上下文。比如模板 &lt;code>S&lt;/code> 和参数 &lt;code>I&lt;/code>，&lt;code>S&amp;lt;I+1&amp;gt;&lt;/code> 无法提供推导信息。&lt;/li>
&lt;/ul>
&lt;h1 id="如何推导出模板参数">如何推导出模板参数
&lt;a class="header-anchor" href="#%e5%a6%82%e4%bd%95%e6%8e%a8%e5%af%bc%e5%87%ba%e6%a8%a1%e6%9d%bf%e5%8f%82%e6%95%b0">&lt;/a>
&lt;/h1>&lt;ol>
&lt;li>从参数列表中推导（推导能力是有限制的，比如不能从 &lt;code>typename T::iterator&lt;/code> 参数中推出 &lt;code>T&lt;/code> 的类型）&lt;/li>
&lt;li>函数模板被取地址时，可以从要求的返回值类型推导：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> T&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> f(T, T);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> (&lt;span style="color:#719e07">*&lt;/span>pf)(&lt;span style="color:#dc322f">char&lt;/span>, &lt;span style="color:#dc322f">char&lt;/span>) &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>f; &lt;span style="color:#586e75">// f的参数T由函数指针的类型确定
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>&lt;strong>隐式转换操作符模板&lt;/strong>的类型参数 T 由需要转换时所需的类型决定。&lt;/li>
&lt;/ol>
&lt;p>&lt;em>模板尝试匹配的时候不适用 common type。&lt;/em> 比如两个 T 类型分别被认为是 int 和 double 时，会导致模板替换失败，而不是把 T 认为是 double。比如&lt;/p></description></item><item><title>CTTCG 16 Specializations and Overloading</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/16-Specializations-and-Overloading/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/16-Specializations-and-Overloading/</guid><description>&lt;p>大部分都不需要专门总结，因此这一小节为空。&lt;/p></description></item><item><title>CTTCG 17 Future Directions</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/17-Future-Directions/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/17-Future-Directions/</guid><description>&lt;p>这一章讲的是对未来的展望。&lt;/p>
&lt;h1 id="浮点数和字符串作为模板参数">浮点数和字符串作为模板参数
&lt;a class="header-anchor" href="#%e6%b5%ae%e7%82%b9%e6%95%b0%e5%92%8c%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%bd%9c%e4%b8%ba%e6%a8%a1%e6%9d%bf%e5%8f%82%e6%95%b0">&lt;/a>
&lt;/h1>&lt;p>浮点数在 gcc C++20 是可以作为非类型模板参数（NTTP）的；clang 不支持。目前 &lt;a href="https://en.cppreference.com/w/cpp/compiler_support" title="C&amp;#43;&amp;#43; compiler support - cppreference.com" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >C++ compiler support - cppreference.com&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 上也看不到相关的支持项目。&lt;/p></description></item><item><title>CTTCG 18 The Polymorphic Power of Templates</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/18-The-Polymorphic-Power-of-Templates/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/18-The-Polymorphic-Power-of-Templates/</guid><description>&lt;p>C++ 的多态有两类：bounded &lt;strong>dynamic&lt;/strong> polymorphism 和 unbounded &lt;strong>static&lt;/strong> polymorphism。前者 bounded 指的是虚函数有基类的接口，其行为有一定约束；后者 unbounded 指的是模板采用类型替换的方式生成代码。为了给静态多态提供约束，可以使用 enable_if 或 concept。&lt;/p></description></item><item><title>CTTCG 19 Implementing Traits</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/19-Implementing-Traits/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/19-Implementing-Traits/</guid><description>&lt;h1 id="trait-分类">Trait 分类
&lt;a class="header-anchor" href="#trait-%e5%88%86%e7%b1%bb">&lt;/a>
&lt;/h1>&lt;p>不一定大家都这么叫，但是为了方便，我规定下面的术语：&lt;/p>
&lt;ul>
&lt;li>Type Trait：包含一个 type alias。&lt;/li>
&lt;li>Value Trait：包含一个 value 静态成员，可以是任何基本类型，含义和具体 Trait 相关。&lt;/li>
&lt;li>Predicate Trait：包含一个 value 静态成员，类型为 bool，含义为条件是否被满足。&lt;/li>
&lt;/ul>
&lt;p>书中有分为 property trait 和 policy trait 两大类。前者包含我所称的 type trait 和 value trait，含义是类型本身的固有信息；后者表示根据一个特定类型选择某种映射，其含义和要实现的行为有关，文中的例子是对 size 小的参数选择原类型，对 size 大的参数选择引用类型。&lt;/p></description></item><item><title>CTTCG 19.1 用 SFINAE 实现 Traits</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/19.1-%E7%94%A8-SFINAE-%E5%AE%9E%E7%8E%B0-Traits/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/19.1-%E7%94%A8-SFINAE-%E5%AE%9E%E7%8E%B0-Traits/</guid><description>&lt;p>原理是用 SFINAE 机制安全地匹配几个函数或函数模板，然后再通过函数匹配信息将结果（true or false）嵌入 Trait 类中。Trait 约束条件被包含在函数模板的声明中。&lt;/p></description></item><item><title>CTTCG 20 Overloading on Type Properties</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/20-Overloading-on-Type-Properties/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/20-Overloading-on-Type-Properties/</guid><description>&lt;h1 id="tldr几种-sfinae-的模式">TLDR：几种 SFINAE 的模式
&lt;a class="header-anchor" href="#tldr%e5%87%a0%e7%a7%8d-sfinae-%e7%9a%84%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h1>&lt;ol>
&lt;li>对于&lt;strong>函数参数列表非空&lt;/strong>的函数模板，可以用非 varargs 函数实现功能，varargs 作为 fallback。&lt;/li>
&lt;li>类模板可以用偏特化实现功能重载，用带模板默认参数的原始模板作为 fallback。&lt;/li>
&lt;li>模板用 tag dispatching 不会有重复定义的问题。&lt;/li>
&lt;li>&lt;code>std::enable_if&lt;/code> 用在函数模板的模板默认参数上表达更简洁，但&lt;strong>用在返回值上可避免重复定义&lt;/strong>。对比起来，类模板虽然能支持偏特化，但是也没有用返回值 SFINAE 避免重复的好处。（不过 C++20 有了 requires 就无所谓了。）&lt;/li>
&lt;li>concept、constexpr if 等。&lt;/li>
&lt;/ol>
&lt;p>1 和 2 其实分别适应了函数模板和类模板的特点：函数模板不能偏特化，类模板不是函数因而不能使用 varargs。&lt;/p></description></item><item><title>CTTCG 21 Templates and Inheritance</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/21-Templates-and-Inheritance/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/21-Templates-and-Inheritance/</guid><description>&lt;h1 id="零开销继承空基类优化ebco">零开销继承：空基类优化（EBCO）
&lt;a class="header-anchor" href="#%e9%9b%b6%e5%bc%80%e9%94%80%e7%bb%a7%e6%89%bf%e7%a9%ba%e5%9f%ba%e7%b1%bb%e4%bc%98%e5%8c%96ebco">&lt;/a>
&lt;/h1>&lt;p>The Empty Base Class Optimization (EBCO)&lt;/p>
&lt;p>C++ 没有真正零大小的类，因为在数组等场景需要用地址区分元素。一般编译器上空类的大小是 1 个字节。不过，当基类为空时，EBCO 会使得基类在子类中不占空间。但是 EBCO 的适用有条件。下面的场景是从实践中观察出来的，可能并没有被标准定义，但它演示了 EBCO 失效：&lt;/p></description></item><item><title>CTTCG 22 Bridging Static and Dynamic Polymorphism</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/22-Bridging-Static-and-Dynamic-Polymorphism/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/22-Bridging-Static-and-Dynamic-Polymorphism/</guid><description>&lt;h1 id="类型擦除">类型擦除
&lt;a class="header-anchor" href="#%e7%b1%bb%e5%9e%8b%e6%93%a6%e9%99%a4">&lt;/a>
&lt;/h1>&lt;p>主要讲的是&lt;strong>类型擦除&lt;/strong>，例子是 &lt;code>std::function&lt;/code> 类模板。特殊情况：&lt;code>std::function&amp;lt;void(void)&amp;gt;&lt;/code> 和 &lt;code>std::function&amp;lt;void()&amp;gt;&lt;/code> 是同一个类型。&lt;/p>
&lt;h1 id="实现思路">实现思路
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0%e6%80%9d%e8%b7%af">&lt;/a>
&lt;/h1>&lt;ol>
&lt;li>&lt;code>std::function&lt;/code> 原始模板捕获了函数类型。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> Signature&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">FunctionPtr&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>&lt;code>std::function&lt;/code> 的偏特化能够获得函数的返回值和函数参数包的类型。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> R, &lt;span style="color:#719e07">typename&lt;/span>... Args&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">FunctionPtr&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>R(Args...)&lt;span style="color:#719e07">&amp;gt;&lt;/span> { ... }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>&lt;code>std::function&lt;/code> 包含了一个&lt;strong>函数对象基类&lt;/strong>的指针，这个基类指针有一个 &lt;code>invoke&lt;/code> 虚函数，返回值和函数参数类型与模板参数对应。&lt;code>std::function&lt;/code> 被调用时，会将调用转发到这个函数对象上。&lt;/li>
&lt;li>实现构造模板函数、赋值模板操作符时，捕获传入的&lt;strong>对象&lt;/strong>，生成一个继承于&lt;strong>函数对象基类&lt;/strong>（之前提到过）的子类对象，其 &lt;code>invoke&lt;/code> 虚函数的实现就是转而调用这个&lt;strong>对象&lt;/strong>的 &lt;code>()&lt;/code> 操作符。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> Functor, &lt;span style="color:#719e07">typename&lt;/span> R, &lt;span style="color:#719e07">typename&lt;/span>... Args&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">SpecificFunctorBridge&lt;/span> &lt;span style="color:#719e07">:&lt;/span> &lt;span style="color:#719e07">public&lt;/span> FunctorBridge&lt;span style="color:#719e07">&amp;lt;&lt;/span>R, Args...&lt;span style="color:#719e07">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Functor functor;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>子类对象就是通过上面的模板创建的。模板参数 &lt;code>Functor&lt;/code> 对应于捕获对象的存储类型，书中的定义为 &lt;code>using Functor = std::decay_t&amp;lt;F&amp;gt;&lt;/code>（&lt;code>F&lt;/code> 为捕获对象的真实类型）。&lt;/p></description></item><item><title>CTTCG 23 Metaprogramming</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/23-Metaprogramming/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/23-Metaprogramming/</guid><description>&lt;h1 id="分类">分类
&lt;a class="header-anchor" href="#%e5%88%86%e7%b1%bb">&lt;/a>
&lt;/h1>&lt;p>现在值元编程已经能够很好地被 &lt;code>constexpr&lt;/code> 函数取代。&lt;/p>
&lt;p>类型元编程例子：&lt;code>std::chrono&lt;/code> 中的时间单位用分数表示，两个时间单位的加和的单位可以在运行时确定——尽管分母很可能会变化。&lt;/p></description></item><item><title>CTTCG 24 Typelists</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/24-Typelists/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/24-Typelists/</guid><description>&lt;p>本章介绍了构建类型列表的技巧。既然类型列表可以使用这类技巧，值列表当然也可以在编译期完成类似的计算。&lt;/p>
&lt;p>类型列表一开始是用可变长参数列表定义的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span>... Elements&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">Typelist&lt;/span> {};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>很容易使用偏特化手段为 Typelist 定义 Front trait，以此获得列表的第一个元素。当然这要求类型列表非空，否则不能完成实例化。&lt;/p></description></item><item><title>CTTCG 25 Tuples</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/25-Tuples/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/25-Tuples/</guid><description>&lt;p>类型计算可以在编译期间完成，取值的部分仍然是运行时操作。在 &lt;code>libc++&lt;/code> 中被实现成多继承+反序构造，在 &lt;code>libstdc++&lt;/code> 中被实现成双继承+正序构造。&lt;/p>
&lt;h1 id="base">Base
&lt;a class="header-anchor" href="#base">&lt;/a>
&lt;/h1>&lt;p>将元素包裹在 &lt;code>Base&lt;/code> 中再继承可以利用到 EBCO（可优化时继承元素，不可优化时将元素作为成员）。通过给 &lt;code>Base&lt;/code> 类模板添加下标作为参数，可以区分类型相同的元素。&lt;/p></description></item><item><title>CTTCG 26 Discriminated Unions</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/26-Discriminated-Unions/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/26-Discriminated-Unions/</guid><description>&lt;p>本章想要实现的类模板相当于 &lt;code>std::variant&lt;/code>。 可以用递归 union 模板，也可以用字符数组存储，本章选用的是后者。&lt;/p>
&lt;p>使用字符数组存储未知元素，需要注意：&lt;/p></description></item><item><title>CTTCG 27 Expression Templates</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/27-Expression-Templates/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/27-Expression-Templates/</guid><description>&lt;h1 id="表达式模板解决了什么问题">表达式模板解决了什么问题
&lt;a class="header-anchor" href="#%e8%a1%a8%e8%be%be%e5%bc%8f%e6%a8%a1%e6%9d%bf%e8%a7%a3%e5%86%b3%e4%ba%86%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98">&lt;/a>
&lt;/h1>&lt;p>表达式模板主要用在大数组的计算上。以相加为例，应该支持的操作有：同长度的数组相加、数组和标量的相加。有时候表达式比较复杂，会涉及多个操作，这种场景下，手工编写代码效率高，但是需要自己控制循环；使用模板编写代码则需要想办法把操作一次性完成，避免多次内存分配和内存访问。&lt;/p></description></item><item><title>CTTCG 28 Debugging Templates</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/28-Debugging-Templates/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/28-Debugging-Templates/</guid><description>&lt;h1 id="shallow-instantiation">Shallow Instantiation
&lt;a class="header-anchor" href="#shallow-instantiation">&lt;/a>
&lt;/h1>&lt;p>作用：早点暴露参数校验错误，避免在一堆模板实例化失败的信息中找错误。&lt;/p>
&lt;p>可以用 &lt;code>static_assert&lt;/code> 或者定义无用类：&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/6d63c902f6ee005bfe2b7348fa80e8dc.webp">&lt;/p>
&lt;p>这样在实例化 shell 函数的时候还会实例化其中的 &lt;code>ShallowChecks&lt;/code> 类，从而确保参数能够解引用。&lt;/p></description></item><item><title>CTTCG 附录 B Value Categories</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/0-B-Value-Categories/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/0-B-Value-Categories/</guid><description>&lt;p>对于变量而言，其括号表达式的值类别是左值引用。但由于 &lt;code>decltype&lt;/code> 有特殊效果，直接对变量 &lt;code>x&lt;/code> 使用 &lt;code>decltype(x)&lt;/code> 并不遵循这一点，为此可以按照下面说的使用 &lt;code>decltype((x))&lt;/code>。&lt;/p>
&lt;blockquote>
 &lt;p>With the keyword decltype (introduced in C++11), it is possible to check the value category of any C++ expression. For any expression &lt;code>x&lt;/code>, &lt;code>decltype((x))&lt;/code> (note the double parentheses) yields:&lt;/p></description></item><item><title>CTTCG 附录 D Standard Type Utilities</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/0-D-Standard-Type-Utilities/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/0-D-Standard-Type-Utilities/</guid><description>&lt;p>这一章介绍的大都是用来查询类型属性的 type traits。还有一些其他的工具。&lt;/p>
&lt;h1 id="按数据概念分类">按数据概念分类
&lt;a class="header-anchor" href="#%e6%8c%89%e6%95%b0%e6%8d%ae%e6%a6%82%e5%bf%b5%e5%88%86%e7%b1%bb">&lt;/a>
&lt;/h1>&lt;p>






&lt;img src="https://hxhue.github.io/assets/d1144640c713ad4c260d6384745dfbfa.webp">&lt;/p>
&lt;p>下面是基本（primary）类型，范围都是互斥的，而且任何一个类型必然使得下面中的一个且仅有一个评估为真：&lt;/p></description></item><item><title>CTTCG 附录 E Concept</title><link>https://hxhue.github.io/cpp-templates-the-complete-guide/0-E-Concept/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/cpp-templates-the-complete-guide/0-E-Concept/</guid><description>&lt;h1 id="定义和使用-concept">定义和使用 concept
&lt;a class="header-anchor" href="#%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%bf%e7%94%a8-concept">&lt;/a>
&lt;/h1>&lt;p>下面演示了几种 C++20 支持的定义 concept 的方式，每一条约束都是以下之一，然后用分号结尾：&lt;/p>
&lt;ol>
&lt;li>类型&lt;/li>
&lt;li>表达式&lt;/li>
&lt;li>{ 表达式 } noexcept -&amp;gt; 检查返回类型是否满足其他约束（这个 noexcept 可以不要）&lt;/li>
&lt;li>引入其他 &lt;code>requires&lt;/code> 表达式&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> T&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">concept&lt;/span> StringConcept &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">requires&lt;/span>(T t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">typename&lt;/span> T&lt;span style="color:#719e07">::&lt;/span>iterator; &lt;span style="color:#586e75">// 1. 检查类型存在性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> t.data(); &lt;span style="color:#586e75">// 2. 检查表达式合法性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 3. 将表达式作为 concept 的第一个参数，要求 concept 成立（额外参数从第二个参数起放置）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> { t.c_str() } &lt;span style="color:#719e07">-&amp;gt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>same_as&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">char&lt;/span> &lt;span style="color:#719e07">const&lt;/span> &lt;span style="color:#719e07">*&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 4. 用 requires 语句引入子条件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">requires&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>is_pointer_v&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">decltype&lt;/span>(t.data())&lt;span style="color:#719e07">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 5. 除了 requires 体之外还能用其他编译期常量表达式做约束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>} &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> (&lt;span style="color:#719e07">sizeof&lt;/span>(T) &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#2aa198">8&lt;/span>) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>std&lt;span style="color:#719e07">::&lt;/span>is_aggregate_v&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>StringConcept Str&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> takeString(Str &lt;span style="color:#719e07">const&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>s) { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> takeString(std&lt;span style="color:#719e07">::&lt;/span>string{&lt;span style="color:#2aa198">&amp;#34;hello&amp;#34;&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在模板中加上 &lt;code>requires&lt;/code> 条件则相对比较简单。只需要在 &lt;strong>模板参数后，函数返回值前面&lt;/strong>，或者 &lt;strong>函数体前面&lt;/strong> 加上 &lt;code>requires&lt;/code> 约束。&lt;code>requires&lt;/code> 约束能使用一般的条件表达式，也能把 concept 当成 type trait 使用。比如：&lt;/p></description></item><item><title>enum class</title><link>https://hxhue.github.io/posts/programming/cpp/enum-class/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/enum-class/</guid><description>&lt;p>C 风格枚举和 C++ 新增的 enum class：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">enum&lt;/span> { ITEM_A1, ITEM_A2 };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">enum&lt;/span> &lt;span style="color:#268bd2">B&lt;/span> { ITEM_B1, ITEM_B2 };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 从 C 沿用来的语法：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 1. 底层类型默认为int，但也能手动指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 2. 枚举名裸露在外
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 区别：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// C 允许前向声明 enum
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// C++ 允许枚举列表为空；允许在表示类型时省略 enum 关键字；虽然枚举名裸露但也能通过限定名访问
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// C++ 新增 enum class
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">enum&lt;/span> &lt;span style="color:#268bd2">C&lt;/span> { ITEM_C1, ITEM_C2 };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 类型不再裸露，需要使用限定名访问
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 没有默认底层类型，但是可以手动指定
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C++ enum class 禁止了隐式转换，但是用来表示 id 还是不太方便：&lt;/p></description></item><item><title>explicit</title><link>https://hxhue.github.io/posts/programming/cpp/explicit/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/explicit/</guid><description>&lt;p>一般认为 &lt;code>explicit&lt;/code> 是用在单参数构造函数 上防止隐式类型转换的。但如果参数有多个，explicit 关键字也有其他的作用。&lt;/p>
&lt;h1 id="explicit-可以阻止--推导">&lt;code>explicit&lt;/code> 可以阻止 &lt;code>{}&lt;/code> 推导
&lt;a class="header-anchor" href="#explicit-%e5%8f%af%e4%bb%a5%e9%98%bb%e6%ad%a2--%e6%8e%a8%e5%af%bc">&lt;/a>
&lt;/h1>&lt;p>&lt;a href="https://stackoverflow.com/a/39122237/" title="https://stackoverflow.com/a/39122237/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/39122237/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>可以参考另一篇文章：{ } Syntax。&lt;/p></description></item><item><title>Heterogeneous Lookup</title><link>https://hxhue.github.io/posts/programming/cpp/Heterogeneous-Lookup/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Heterogeneous-Lookup/</guid><description>&lt;p>&lt;a href="https://www.cppstories.com/2021/heterogeneous-access-cpp20/" title="https://www.cppstories.com/2021/heterogeneous-access-cpp20/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://www.cppstories.com/2021/heterogeneous-access-cpp20/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;h1 id="c-14-加入了对有序容器的异质查找">C++ 14 加入了对有序容器的异质查找
&lt;a class="header-anchor" href="#c-14-%e5%8a%a0%e5%85%a5%e4%ba%86%e5%af%b9%e6%9c%89%e5%ba%8f%e5%ae%b9%e5%99%a8%e7%9a%84%e5%bc%82%e8%b4%a8%e6%9f%a5%e6%89%be">&lt;/a>
&lt;/h1>&lt;p>用户的工作量很小，对标准库中的类型，只需要加上第三个模板参数：&lt;code>std::less&amp;lt;&amp;gt;&lt;/code>（它的默认参数是 void）。&lt;code>std::less&amp;lt;void&amp;gt;&lt;/code> 类中申明了 &lt;code>is_transparent&lt;/code> 类型，所以可以用于异质查找。&lt;/p></description></item><item><title>Hidden Friends</title><link>https://hxhue.github.io/posts/programming/cpp/Hidden-Friends/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Hidden-Friends/</guid><description>&lt;p>下面的代码中，Bar 能够隐式转换成 Foo。想要重载 Foo 的等于运算符至少有三种方案：&lt;/p>
&lt;ol>
&lt;li>重载全局的 &lt;code>==&lt;/code> 运算符&lt;/li>
&lt;li>重载 Foo 中的 hidden friend，即 &lt;code>friend bool operator==(Foo const &amp;amp;a, Foo const &amp;amp;b)&lt;/code>&lt;/li>
&lt;li>重载 &lt;code>bool operator==(Foo const &amp;amp;a) const&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>第一种方案会污染全局的名字空间，使得 Bar 和 Bar 之间也能通过转换两个参数进行比较；第三种方案允许第二个参数的隐式类型转换，但要求第一个参数必须是 Foo 类型；第二种方案只要求任一个参数为 Foo 类型，使得 ADL 能够参与找到这个函数，另一个参数则可以通过隐式类型转换来得到。&lt;/p></description></item><item><title>Inheritance</title><link>https://hxhue.github.io/posts/programming/cpp/Inheritance/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Inheritance/</guid><description>&lt;div style="overflow-x: auto">
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;/th>
 &lt;th>public&lt;/th>
 &lt;th>protected&lt;/th>
 &lt;th>private&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>共有继承&lt;/td>
 &lt;td>public&lt;/td>
 &lt;td>protected&lt;/td>
 &lt;td>不可见&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>私有继承&lt;/td>
 &lt;td>private&lt;/td>
 &lt;td>private&lt;/td>
 &lt;td>不可见&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>保护继承&lt;/td>
 &lt;td>protected&lt;/td>
 &lt;td>protected&lt;/td>
 &lt;td>不可见&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;/div>&lt;p>可见继承属性就是对于来自基类的 public 和 protected 成员进行一个取最小权限的操作（定义权限 public &amp;gt; protected &amp;gt; private）。&lt;/p></description></item><item><title>Lambda 在各 C++ 版本的演进</title><link>https://hxhue.github.io/posts/programming/cpp/Lambda-%E5%9C%A8%E5%90%84-C++-%E7%89%88%E6%9C%AC%E7%9A%84%E6%BC%94%E8%BF%9B/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Lambda-%E5%9C%A8%E5%90%84-C++-%E7%89%88%E6%9C%AC%E7%9A%84%E6%BC%94%E8%BF%9B/</guid><description>&lt;h1 id="c11">C++11
&lt;a class="header-anchor" href="#c11">&lt;/a>
&lt;/h1>&lt;p>虽然有了 auto 关键字，但是用起来还是需要 trailing return type 声明。&lt;/p>
&lt;h1 id="c14">C++14
&lt;a class="header-anchor" href="#c14">&lt;/a>
&lt;/h1>&lt;p>可以省略尾部声明（以下两种写法都是要 C++14 才能支持）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">auto&lt;/span> &lt;span style="color:#268bd2">f&lt;/span>() { &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">42&lt;/span>; } &lt;span style="color:#586e75">// #1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">auto&lt;/span> &lt;span style="color:#268bd2">f&lt;/span>() &lt;span style="color:#719e07">-&amp;gt;&lt;/span> &lt;span style="color:#719e07">auto&lt;/span> { &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">42&lt;/span>; } &lt;span style="color:#586e75">// #2，相当于 #1
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="markdown-alert markdown-alert-note">
 &lt;p class="markdown-alert-title">&lt;svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16"
 aria-hidden="true">
 &lt;path
 d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
 &lt;/path>
 &lt;/svg>Note&lt;/p></description></item><item><title>new 和 delete</title><link>https://hxhue.github.io/inside-the-cpp-object-model/new-%E5%92%8C-delete/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/new-%E5%92%8C-delete/</guid><description>&lt;h1 id="new">&lt;code>new&lt;/code>
&lt;a class="header-anchor" href="#new">&lt;/a>
&lt;/h1>&lt;p>用 new 申请的内存最少占用 1 个字节——尽管我们申请的可能是 0 个字节。&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/e06da70dc841cb03e9e0076d20f8f899.webp">&lt;/p>
&lt;h1 id="deletedelete">&lt;code>delete&lt;/code>/&lt;code>delete[]&lt;/code>
&lt;a class="header-anchor" href="#deletedelete">&lt;/a>
&lt;/h1>&lt;p>delete 和 delete[] 都会归还空间，但是 delete[] 会询问元素数量，并析构数组中的每个元素，而 delete 只会析构一个元素。&lt;/p></description></item><item><title>noexcept + throw</title><link>https://hxhue.github.io/posts/programming/cpp/noexcept-+-throw/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/noexcept-+-throw/</guid><description>&lt;p>noexcept 有几个用法：&lt;/p>
&lt;ol>
&lt;li>在编译期返回一个常量布尔值，评估其表达式是否会抛出异常。&lt;/li>
&lt;li>用于标志一个函数是否能抛出异常，需要一个编译期布尔常量作为参数。&lt;/li>
&lt;li>标志函数不会抛出异常。相当于 &lt;code>noexcept(true)&lt;/code>。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// whether foo is declared noexcept depends on if the expression
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// T() will throw any exceptions
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">template&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">T&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> foo() &lt;span style="color:#719e07">noexcept&lt;/span>(&lt;span style="color:#719e07">noexcept&lt;/span>(T())) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">bar&lt;/span>() &lt;span style="color:#719e07">noexcept&lt;/span>(&lt;span style="color:#b58900">true&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">baz&lt;/span>() &lt;span style="color:#719e07">noexcept&lt;/span> { &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#2aa198">42&lt;/span>; } &lt;span style="color:#586e75">// noexcept is the same as noexcept(true)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> foo&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>(); &lt;span style="color:#586e75">// noexcept(noexcept(int())) =&amp;gt; noexcept(true), so this is fine
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bar(); &lt;span style="color:#586e75">// fine
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> baz(); &lt;span style="color:#586e75">// compiles, but at runtime this calls std::terminate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C++17 已经禁用 &lt;code>throw&lt;/code> 的显式异常声明。（被称为 &lt;code>Dynamic exception specification&lt;/code>）&lt;/p></description></item><item><title>P2266R3: Simpler implicit move 对 C++23 函数返回表达式值类别的改变</title><link>https://hxhue.github.io/posts/programming/cpp/P2266R3-Simpler-implicit-move-%E5%AF%B9-C++23-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%80%BC%E7%B1%BB%E5%88%AB%E7%9A%84%E6%94%B9%E5%8F%98/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/P2266R3-Simpler-implicit-move-%E5%AF%B9-C++23-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%80%BC%E7%B1%BB%E5%88%AB%E7%9A%84%E6%94%B9%E5%8F%98/</guid><description>&lt;h1 id="写在前面">写在前面
&lt;a class="header-anchor" href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2">&lt;/a>
&lt;/h1>&lt;p>本篇内容参考提案 &lt;a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2266r3.html" title="Simpler implicit move" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Simpler implicit move&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>。&lt;/p>
&lt;p>隐式移动是函数返回值优化的一种，在 C++ 不同版本有不同的规则，这篇文章主要讲隐式移动，不涉及其他返回值优化的内容。&lt;/p></description></item><item><title>POD</title><link>https://hxhue.github.io/posts/programming/cpp/POD/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/POD/</guid><description>&lt;p>Plain Old Data&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/a/4178176/" title="https://stackoverflow.com/a/4178176" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/4178176&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>成为 POD 的条件：&lt;/p>
&lt;ol>
&lt;li>所有的标准类型都是 POD（尽管不是 aggregate）。&lt;/li>
&lt;li>数组要成为 POD 的条件是每个元素都是 POD。&lt;/li>
&lt;li>一个类要成为 POD，则必须首先是 &lt;strong>aggregate&lt;/strong>，然后：
&lt;ol>
&lt;li>没有用户定义的赋值运算符。&lt;/li>
&lt;li>没有析构函数。&lt;/li>
&lt;li>所有成员都是 POD（递归定义）。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol></description></item><item><title>Pointer to Member</title><link>https://hxhue.github.io/posts/programming/cpp/Pointer-to-Member/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Pointer-to-Member/</guid><description>&lt;h1 id="数据成员指针存储的是偏移">数据成员指针存储的是偏移
&lt;a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e6%88%90%e5%91%98%e6%8c%87%e9%92%88%e5%ad%98%e5%82%a8%e7%9a%84%e6%98%af%e5%81%8f%e7%a7%bb">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>&lt;span style="color:#719e07">using&lt;/span> &lt;span style="color:#719e07">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">Foo&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Foo x{&lt;span style="color:#2aa198">2&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> Foo&lt;span style="color:#719e07">::*&lt;/span> px &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>Foo&lt;span style="color:#719e07">::&lt;/span>x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> Foo&lt;span style="color:#719e07">::*&lt;/span> py &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>Foo&lt;span style="color:#719e07">::&lt;/span>y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> (&lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>)px &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#586e75">// 输出0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> (&lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>)py &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#586e75">// 输出4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#719e07">sizeof&lt;/span>(px) &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#586e75">// gcc输出8
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>数据成员指针的大小和实现相关。&lt;/p>
&lt;h1 id="成员函数指针比一般指针占用更多空间">成员函数指针比一般指针占用更多空间
&lt;a class="header-anchor" href="#%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88%e6%af%94%e4%b8%80%e8%88%ac%e6%8c%87%e9%92%88%e5%8d%a0%e7%94%a8%e6%9b%b4%e5%a4%9a%e7%a9%ba%e9%97%b4">&lt;/a>
&lt;/h1>&lt;p>和编译器相关。gcc 里成员函数指针在 64 位机器下是 16 字节。&lt;/p></description></item><item><title>range-for</title><link>https://hxhue.github.io/posts/programming/cpp/range-for/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/range-for/</guid><description>&lt;p>以前容易出现引用悬挂的问题。在新的语言标准中得到了改进。&lt;/p>
&lt;p>C++11 只是简单的语法糖，只能保证表达式返回值被临时变量接受并保留到循环结束：(&lt;a href="https://stackoverflow.com/a/51440883" title="https://stackoverflow.com/a/51440883" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/51440883&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>)&lt;/p></description></item><item><title>sizeof</title><link>https://hxhue.github.io/posts/programming/cpp/sizeof/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/sizeof/</guid><description>&lt;p>下面几个表达式相等：&lt;/p>
&lt;ul>
&lt;li>&lt;code>sizeof(T&amp;amp;)&lt;/code>&lt;/li>
&lt;li>&lt;code>sizeof(T&amp;amp;&amp;amp;)&lt;/code>&lt;/li>
&lt;li>&lt;code>sizeof(T)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>也就是说 &lt;code>sizeof&lt;/code> 会去掉引用。忘记出处了，twitter 上有人提过一个 quiz，什么类型 &lt;code>T&lt;/code> 能满足 &lt;code>struct {T x;}&lt;/code> 和 &lt;code>T&lt;/code> 的 sizeof 结果不相等，引用类型就满足这样的情况。&lt;/p></description></item><item><title>std::lower_bound/upper_bound</title><link>https://hxhue.github.io/posts/programming/cpp/std-lower_bound-upper_bound/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/std-lower_bound-upper_bound/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">public&lt;/span>&lt;span style="color:#719e07">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span> searchRange(vector&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#dc322f">int&lt;/span> target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> n &lt;span style="color:#719e07">=&lt;/span> (&lt;span style="color:#dc322f">int&lt;/span>)nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// lower_bound 的可能实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">auto&lt;/span> lowerbound &lt;span style="color:#719e07">=&lt;/span> [&lt;span style="color:#719e07">&amp;amp;&lt;/span>](&lt;span style="color:#719e07">auto&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span>less) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> lo &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>, hi &lt;span style="color:#719e07">=&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">while&lt;/span> (lo &lt;span style="color:#719e07">&amp;lt;&lt;/span> hi) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> mid &lt;span style="color:#719e07">=&lt;/span> (lo &lt;span style="color:#719e07">+&lt;/span> hi) &lt;span style="color:#719e07">/&lt;/span> &lt;span style="color:#2aa198">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (less(nums[mid], target)) lo &lt;span style="color:#719e07">=&lt;/span> mid &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">else&lt;/span> hi &lt;span style="color:#719e07">=&lt;/span> mid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> lo;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// std::lower_bound
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> left &lt;span style="color:#719e07">=&lt;/span> lowerbound(std&lt;span style="color:#719e07">::&lt;/span>less&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// std::upper_bound
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> right &lt;span style="color:#719e07">=&lt;/span> lowerbound(std&lt;span style="color:#719e07">::&lt;/span>less_equal&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (left &lt;span style="color:#719e07">&amp;lt;&lt;/span> n &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> nums[left] &lt;span style="color:#719e07">==&lt;/span> target) &lt;span style="color:#719e07">?&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>{left, right&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>} &lt;span style="color:#719e07">:&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>{&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>, &lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Strict Aliasing</title><link>https://hxhue.github.io/posts/programming/cpp/Strict-Aliasing/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Strict-Aliasing/</guid><description>&lt;p>文章：&lt;a href="https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8" title="What is Strict Aliasing and Why do we Care? (github.com)" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >What is Strict Aliasing and Why do we Care? (github.com)&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>所谓 Strict Aliasing 就是指为 aliasing 设定条件，使得编译器大多数场景下认为代码没有 aliasing，从而可以激进优化代码。&lt;/p></description></item><item><title>Three-way Comparison =</title><link>https://hxhue.github.io/posts/programming/cpp/Three-way-Comparison/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Three-way-Comparison/</guid><description>&lt;h1 id="含义">含义
&lt;a class="header-anchor" href="#%e5%90%ab%e4%b9%89">&lt;/a>
&lt;/h1>&lt;p>C++ 20 加入了 &lt;code>&amp;lt;=&amp;gt;&lt;/code> 操作符，该操作符会按布局顺序比较成员，比较时会递归使用 &lt;code>&amp;lt;=&amp;gt;&lt;/code> 操作符。对于类类型来说，即便默认的 &lt;code>&amp;lt;=&amp;gt;&lt;/code> 操作符可用，也必须显式声明为 &lt;code>= default&lt;/code>，否则不能使用。&lt;/p></description></item><item><title>type_index</title><link>https://hxhue.github.io/posts/programming/cpp/type_index/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/type_index/</guid><description>&lt;p>例子：bustub lab 0&lt;/p>
&lt;p>可以和 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/inside-the-cpp-object-model/vtable/" title="📌vtable" >📌vtable&lt;/a> 联系起来看。&lt;/p>
&lt;h1 id="dynamic_cast-何时可以使用">dynamic_cast 何时可以使用？
&lt;a class="header-anchor" href="#dynamic_cast-%e4%bd%95%e6%97%b6%e5%8f%af%e4%bb%a5%e4%bd%bf%e7%94%a8">&lt;/a>
&lt;/h1>&lt;p>使用要求：① 目标是类的指针或引用 ② 目标类含虚表&lt;/p>
&lt;p>我最初在 bustub lab 0 的实现中使用了向下转型的操作：在 &lt;code>Get&lt;/code> 操作中，当一个 &lt;code>TrieNode&lt;/code> 有值的时候，就尝试向下转型为 &lt;code>TrieNodeWithValue&amp;lt;T&amp;gt;&lt;/code>，这一步仍然正确就说明类型也正确，可以取出返回。&lt;/p></description></item><item><title>UB</title><link>https://hxhue.github.io/posts/programming/cpp/UB/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/UB/</guid><description>&lt;p>&lt;a href="https://en.cppreference.com/w/cpp/language/ub" title="Undefined behavior - cppreference.com" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Undefined behavior - cppreference.com&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>&lt;em>ill-formed&lt;/em>：有语法错误，或者能被检查出的语义错误。必须提供诊断（编译错误）。&lt;/p>
&lt;p>&lt;em>ill-formed, &lt;a href="https://en.cppreference.com/w/cpp/language/ndr" title="no diagnostic required" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >no diagnostic required&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/em>：正常编译，但有 UB。&lt;/p></description></item><item><title>Value Categories</title><link>https://hxhue.github.io/posts/programming/cpp/Value-Categories/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Value-Categories/</guid><description>&lt;p>&lt;a href="https://en.cppreference.com/w/cpp/language/value_category" title="Value categories - cppreference.com" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Value categories - cppreference.com&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 有更详细的说明。&lt;/p>
&lt;h1 id="分类">分类
&lt;a class="header-anchor" href="#%e5%88%86%e7%b1%bb">&lt;/a>
&lt;/h1>&lt;p>






&lt;img src="https://hxhue.github.io/assets/5910006dfebc9695741390926be5186f.webp">&lt;/p>
&lt;p>lvalue / rvalue / xvalue 是互斥的，C++ 表达式只能是三者之一。glvalue 和 rvalue 都是复合类别：glvalue 包括 lvalue 和 xvalue，rvalue 包括 prvalue 和 xvalue。在翻译上，xvalue 叫（将）亡值，glvalue 叫泛左值。&lt;/p></description></item><item><title>按需合成构造函数</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E6%8C%89%E9%9C%80%E5%90%88%E6%88%90%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E6%8C%89%E9%9C%80%E5%90%88%E6%88%90%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid><description>&lt;p>






&lt;img src="https://hxhue.github.io/assets/862beea85cbeacd098f8815be021dd62.webp">&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/44d6ca6c8f48a441c50cc07501a274e2.webp">&lt;/p>
&lt;p>复制、默认构造都是按需生成的。对于平凡的情况不需要生成，只是在语意上满足“拥有构造函数”的含义。&lt;/p>
&lt;p>&lt;code>x86-64 gcc 13.1 -std=c++20&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">Point&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Point() &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">default&lt;/span>; &lt;span style="color:#586e75">// 即便显式声明了默认构造函数，也不会合成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> some_point &lt;span style="color:#719e07">=&lt;/span> Point{}; &lt;span style="color:#586e75">// {}初始化对聚合类有清零的效果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>main:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">push&lt;/span> &lt;span style="color:#b58900">rbp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">mov&lt;/span> &lt;span style="color:#b58900">rbp&lt;/span>, &lt;span style="color:#b58900">rsp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">mov&lt;/span> &lt;span style="color:#dc322f">DWORD&lt;/span> &lt;span style="color:#268bd2">PTR&lt;/span> [&lt;span style="color:#b58900">rbp&lt;/span>&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">8&lt;/span>], &lt;span style="color:#2aa198">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">mov&lt;/span> &lt;span style="color:#dc322f">DWORD&lt;/span> &lt;span style="color:#268bd2">PTR&lt;/span> [&lt;span style="color:#b58900">rbp&lt;/span>&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">4&lt;/span>], &lt;span style="color:#2aa198">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">mov&lt;/span> &lt;span style="color:#b58900">eax&lt;/span>, &lt;span style="color:#2aa198">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">pop&lt;/span> &lt;span style="color:#b58900">rbp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">ret&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改 Point 的定义：&lt;/p></description></item><item><title>对象布局</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80/</guid><description>&lt;h1 id="关于-access-section">关于 access section
&lt;a class="header-anchor" href="#%e5%85%b3%e4%ba%8e-access-section">&lt;/a>
&lt;/h1>&lt;p>不同 access section 数据不保证按序布局。&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/a8b2681128b573bd4e51d97c763af9e4.webp">&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/a0ad7b8b74861c3674b93d10f9853a35.webp">&lt;/p>
&lt;blockquote>
 &lt;p>我在 Compiler Explorer 上测试了 gcc 和 clang，他们都是忽略 access 权限，将各个 access section 的变量布局直接拼接在一起的。&lt;/p>
&lt;/blockquote>&lt;p>注：同一个权限也可以是不同的 access section：&lt;/p></description></item><item><title>多继承给 C++ 带来了哪些设计负担？</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%BB%99-C++-%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E8%B4%9F%E6%8B%85/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%BB%99-C++-%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E8%B4%9F%E6%8B%85/</guid><description>&lt;ol>
&lt;li>指针偏移本身有少量开销，若需要偏移则得先判空，这样才能保证空指针永远为空。&lt;/li>
&lt;li>指针偏移对设计虚函数表带来了困难。例如 &lt;strong>thunk&lt;/strong> 技术用来对 this 指针做适配再调用对应函数。&lt;/li>
&lt;li>指针偏移让指向成员函数的指针携带了 this 偏移量，变成了胖指针。&lt;/li>
&lt;li>多继承引入了菱形继承困境，进而又引入了虚拟继承。&lt;/li>
&lt;li>虚拟继承使得 vtable 中还要存储虚基类子对象的偏移。由于不同继承结构中 vtable 里虚基类子对象的偏移可能不同，又引入了 &lt;strong>VTT&lt;/strong>，让子类调用基类构造函数时为基类的构造函数提供 vptr 参数。&lt;/li>
&lt;/ol></description></item><item><title>多继承下的虚函数</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0/</guid><description>&lt;h1 id="多继承下重载签名相同的函数">多继承下重载签名相同的函数
&lt;a class="header-anchor" href="#%e5%a4%9a%e7%bb%a7%e6%89%bf%e4%b8%8b%e9%87%8d%e8%bd%bd%e7%ad%be%e5%90%8d%e7%9b%b8%e5%90%8c%e7%9a%84%e5%87%bd%e6%95%b0">&lt;/a>
&lt;/h1>&lt;p>






&lt;img src="https://hxhue.github.io/assets/7bd760c39d3ddb901cc71b7795369680.webp">&lt;/p>
&lt;p>结果是&lt;strong>会把基类同签名的所有非 final 虚函数都重写了&lt;/strong>，而且实现方式相同。尽管基类的虚函数签名一样，但是他们没有关联性，所以在子类的虚表中占两个槽（slots）（一个槽是一个指针）。同样的，如果 Interface 中有虚函数 foo，而 A 和 B 都继承了 Interface，C 继承了 A 和 B。如果 A 和 B 没有虚拟继承 Interface，那么在 C 的对象调用函数 foo 时将出现 ambiguous 指代错误。如果 C 重写了 foo 函数，那么指代就还是明确的。&lt;strong>或者，如果 A 和 B 都是虚拟继承自 Interface，那么也不会有编译错误&lt;/strong>。但这样通过指针/引用调用虚函数 foo 就需要先取虚基类子对象 this 的偏移，修改 this 之后再从 vptr 中读虚函数 foo，开销是 4 次访存（将虚拟继承和虚函数调用的代价累加起来了） 。&lt;/p></description></item><item><title>多继承下的指针转换</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2/</guid><description>&lt;p>要注意空指针是特殊情况：&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/b91cf97c72043857b03f7b43bb65feac.webp">&lt;/p></description></item><item><title>复制构造和赋值运算符</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/</guid><description>&lt;h1 id="vptr">vptr
&lt;a class="header-anchor" href="#vptr">&lt;/a>
&lt;/h1>&lt;p>这个小节没有提到 vptr 的处理。&lt;/p>
&lt;ol>
&lt;li>对于复制构造函数，其本质还是构造，所以和一般的构造函数流程相似，会正确设置好 vptr。&lt;/li>
&lt;li>对于赋值运算符，原有 vptr 和新的 vptr 是一样的，不需要修改。&lt;/li>
&lt;/ol>
&lt;h1 id="怎么写复制构造赋值">怎么写复制构造/赋值？
&lt;a class="header-anchor" href="#%e6%80%8e%e4%b9%88%e5%86%99%e5%a4%8d%e5%88%b6%e6%9e%84%e9%80%a0%e8%b5%8b%e5%80%bc">&lt;/a>
&lt;/h1>&lt;p>写复制构造函数和复制赋值操作符的时候要记得把基类和成员都正确初始化（&lt;strong>用默认的最好&lt;/strong>）。复制构造函数也算是构造函数，所以要使用成员初始化列表来正确初始化。&lt;/p></description></item><item><title>构造函数的成员初始化列表</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</guid><description>&lt;p>初始化会按照变量声明的顺序进行。因此虽然下面的代码想要用 j 的新值初始化 i，但实际上是 &lt;code>i(j)&lt;/code> 先被执行，然后才是 &lt;code>j(val)&lt;/code>。&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/06ab52d0a31a5f56f772342fefe137d6.webp">&lt;/p>
&lt;p>不过，构造函数代码块中的初始化过程始终发生于成员初始化列表之后。&lt;/p></description></item><item><title>静态成员函数</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</guid><description>&lt;h1 id="静态成员函数出现之前">静态成员函数出现之前
&lt;a class="header-anchor" href="#%e9%9d%99%e6%80%81%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e5%87%ba%e7%8e%b0%e4%b9%8b%e5%89%8d">&lt;/a>
&lt;/h1>&lt;p>很久以前没有静态成员函数（直到 Cfront 2.0 才加入），那个时候静态方法可以用这种方式调用：&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/07580994615633018e06f05426e98683.webp">&lt;/p>
&lt;p>该方法没有通过 this 访存，因而不会出现段错误。尽管这种方法还在某些编译器上能够使用，&lt;strong>但这种写法在现在是未定义行为&lt;/strong>。&lt;/p></description></item><item><title>类定义中的类型名可见性</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%90%8D%E5%8F%AF%E8%A7%81%E6%80%A7/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%90%8D%E5%8F%AF%E8%A7%81%E6%80%A7/</guid><description>&lt;p>尽管现在的编译器能够正确理解数据成员（含有隐式的 this 指针）的使用，并在看到整个类定义之后再查找名字，类型名的查找则发生的很早，导致使用时可能看不到、或者使用了错误的类型声明。&lt;/p></description></item><item><title>实现简单的花括号插值打印</title><link>https://hxhue.github.io/posts/programming/cpp/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%8A%B1%E6%8B%AC%E5%8F%B7%E6%8F%92%E5%80%BC%E6%89%93%E5%8D%B0/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%8A%B1%E6%8B%AC%E5%8F%B7%E6%8F%92%E5%80%BC%E6%89%93%E5%8D%B0/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">print&lt;/span>(std&lt;span style="color:#719e07">::&lt;/span>ostream &lt;span style="color:#719e07">&amp;amp;&lt;/span>os, &lt;span style="color:#719e07">const&lt;/span> &lt;span style="color:#dc322f">char&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">while&lt;/span> (&lt;span style="color:#719e07">*&lt;/span>s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">char&lt;/span> ch &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s&lt;span style="color:#719e07">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Treat &amp;#34;{}&amp;#34; as a normal substring when no arguments are left
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// if (ch == &amp;#39;{&amp;#39; &amp;amp;&amp;amp; *s == &amp;#39;}&amp;#39;) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> ((ch &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;{&amp;#39;&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;{&amp;#39;&lt;/span>) &lt;span style="color:#719e07">||&lt;/span> (ch &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;}&amp;#39;&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;}&amp;#39;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s&lt;span style="color:#719e07">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> ch;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">A&lt;/span>, &lt;span style="color:#719e07">class&lt;/span>... &lt;span style="color:#268bd2">Ts&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> print(std&lt;span style="color:#719e07">::&lt;/span>ostream &lt;span style="color:#719e07">&amp;amp;&lt;/span>os, &lt;span style="color:#719e07">const&lt;/span> &lt;span style="color:#dc322f">char&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s, A &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span>a, Ts &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span>...args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">while&lt;/span> (&lt;span style="color:#719e07">*&lt;/span>s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">char&lt;/span> ch &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s&lt;span style="color:#719e07">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ch &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;{&amp;#39;&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;}&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#268bd2">if&lt;/span> ((ch &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;{&amp;#39;&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;{&amp;#39;&lt;/span>) &lt;span style="color:#719e07">||&lt;/span> (ch &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;}&amp;#39;&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;}&amp;#39;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s&lt;span style="color:#719e07">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> ch;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">*&lt;/span>s) print(os, s &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>, std&lt;span style="color:#719e07">::&lt;/span>forward&lt;span style="color:#719e07">&amp;lt;&lt;/span>Ts&lt;span style="color:#719e07">&amp;gt;&lt;/span>(args)...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>(&lt;span style="color:#dc322f">int&lt;/span> argc, &lt;span style="color:#dc322f">char&lt;/span> &lt;span style="color:#719e07">**&lt;/span>argv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>unitbuf;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(std&lt;span style="color:#719e07">::&lt;/span>cout, &lt;span style="color:#2aa198">&amp;#34;numbers : {} {} {}&lt;/span>&lt;span style="color:#cb4b16">\\&lt;/span>&lt;span style="color:#2aa198">n&amp;#34;&lt;/span>, &lt;span style="color:#2aa198">10&lt;/span>, &lt;span style="color:#2aa198">5&lt;/span>, &lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">7&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的写法依赖了 &lt;code>std::ostream&lt;/code>，而且不支持格式指定符。如果能够构造一个模板类 &lt;code>PrintArg&lt;/code> 包装 1 个任意类型参数和 1 个输出说明字符串，然后重载 &lt;code>std::ostream&lt;/code> 的 &lt;code>&amp;lt;&amp;lt;&lt;/code> 操作符，那么可以不用动 print 函数的逻辑。&lt;/p></description></item><item><title>完整构造函数的初始化顺序</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E5%AE%8C%E6%95%B4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E5%AE%8C%E6%95%B4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</guid><description>&lt;p>构造函数分为完整构造函数（Complete Object Constructor）和基类构造函数（Base Object Constructor）。&lt;/p>
&lt;h1 id="初始化顺序">初始化顺序
&lt;a class="header-anchor" href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%ba%e5%ba%8f">&lt;/a>
&lt;/h1>&lt;p>显式构造一个对象的时候调用的是完整构造函数。该函数执行的初始化流程如下：&lt;/p></description></item><item><title>析构函数</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</guid><description>&lt;p>析构函数和构造函数一样，也分完整析构函数和基类析构函数两种。而且析构函数的工作流程和构造函数相反。&lt;/p>
&lt;p>如果一个类的基类有未实现的析构函数（未提供定义或者是纯虚函数），会导致链接失败。这是因为子类的析构函数有调用基类析构函数的逻辑！&lt;/p></description></item><item><title>虚拟继承</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF/</guid><description>&lt;h1 id="基本概念">基本概念
&lt;a class="header-anchor" href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">&lt;/a>
&lt;/h1>&lt;p>






&lt;img src="https://hxhue.github.io/assets/9af2a15e034c9be3cf15b35c0525e241.webp">&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/f28a0c3cd8d9c1ba00bb081453f3f9c6.webp">&lt;/p>
&lt;p>cfront 实现&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/9d2a24e047f5cb0385a5aa819156d4db.webp">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">X&lt;/span> { &lt;span style="color:#719e07">public&lt;/span>&lt;span style="color:#719e07">:&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> i; }; &lt;span style="color:#586e75">// size: 4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">A&lt;/span>&lt;span style="color:#719e07">:&lt;/span> &lt;span style="color:#719e07">virtual&lt;/span> X { &lt;span style="color:#dc322f">int&lt;/span> j; }; &lt;span style="color:#586e75">// size: 16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">B&lt;/span>&lt;span style="color:#719e07">:&lt;/span> &lt;span style="color:#719e07">virtual&lt;/span> X { &lt;span style="color:#dc322f">double&lt;/span> d; }; &lt;span style="color:#586e75">// size: 24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">C&lt;/span>&lt;span style="color:#719e07">:&lt;/span> A, B { &lt;span style="color:#dc322f">int&lt;/span> k; }; &lt;span style="color:#586e75">// size: 40
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> C c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> c.i &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果把 A 或者 B 的 virtual 继承属性删除就会出现 ambiguous 指代错误。因为 virtual 继承只保存基类的一份数据，删掉之后自然就有多份变量 i 了。不过，&lt;strong>virtual 继承并不代表该类为多态类（可用 type traits 判断）&lt;/strong>。&lt;/p></description></item><item><title>虚拟继承和虚函数对比</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94/</guid><description>&lt;h1 id="目的不同">目的不同
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84%e4%b8%8d%e5%90%8c">&lt;/a>
&lt;/h1>&lt;p>虚拟继承用来动态访问数据（节约存储空间或保证数据地址唯一），虚函数用来动态访问方法。&lt;/p>
&lt;h1 id="虚表的访问方式">虚表的访问方式
&lt;a class="header-anchor" href="#%e8%99%9a%e8%a1%a8%e7%9a%84%e8%ae%bf%e9%97%ae%e6%96%b9%e5%bc%8f">&lt;/a>
&lt;/h1>&lt;p>如果 A 类有虚函数，那么 A 类已经有 vptr、是多态类，通过 A 类指针/引用访问虚函数则需要查找虚表。&lt;/p></description></item><item><title>异常处理</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid><description>&lt;p>有人说从 Cfront 转向专门的 C++ 编译器的一大原因就是支持异常处理，因为异常处理在 C 语言中很难做。&lt;/p>
&lt;p>一个函数的指令区域分成三种：&lt;/p>
&lt;ol>
&lt;li>try 以外，且没有活跃对象&lt;/li>
&lt;li>try 以外，有活跃对象，发生异常时需要析构&lt;/li>
&lt;li>try 以内&lt;/li>
&lt;/ol>
&lt;blockquote>
 &lt;p>有一个活跃对象和两个活跃对象应该会有区别吧？这样制表/查表的压力很大。&lt;/p></description></item><item><title>用构造函数和 swap 实现 operator=</title><link>https://hxhue.github.io/posts/programming/cpp/%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C-swap-%E5%AE%9E%E7%8E%B0-operator/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C-swap-%E5%AE%9E%E7%8E%B0-operator/</guid><description>&lt;h1 id="代码展示">代码展示
&lt;a class="header-anchor" href="#%e4%bb%a3%e7%a0%81%e5%b1%95%e7%a4%ba">&lt;/a>
&lt;/h1>&lt;p>先在参数的位置创建一个新的对象，然后和 &lt;code>*this&lt;/code> 交换。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyClass&lt;span style="color:#719e07">&amp;amp;&lt;/span> &lt;span style="color:#719e07">operator&lt;/span>&lt;span style="color:#719e07">=&lt;/span>(MyClass other) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(&lt;span style="color:#719e07">*&lt;/span>&lt;span style="color:#719e07">this&lt;/span>, other);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">*&lt;/span>&lt;span style="color:#719e07">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">friend&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">swap&lt;/span>(MyClass &lt;span style="color:#719e07">&amp;amp;&lt;/span>a, MyClass &lt;span style="color:#719e07">&amp;amp;&lt;/span>b) &lt;span style="color:#719e07">noexcept&lt;/span>; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">using&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>swap;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(a.member1, b.member1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(a.member2, b.member2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> member1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> member2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种实现既能够匹配 &lt;code>const MyClass &amp;amp;&lt;/code> 的情况，又能匹配 &lt;code>MyClass &amp;amp;&amp;amp;&lt;/code> 的情况，而且代码行数更短。&lt;/p></description></item><item><title>指向成员的指针</title><link>https://hxhue.github.io/inside-the-cpp-object-model/%E6%8C%87%E5%90%91%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/inside-the-cpp-object-model/%E6%8C%87%E5%90%91%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/</guid><description>&lt;p>参考 &lt;a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#member-pointers" title="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#member-pointers" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://itanium-cxx-abi.github.io/cxx-abi/abi.html#member-pointers&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>。&lt;/p>
&lt;h1 id="向下转换的能力">向下转换的能力！
&lt;a class="header-anchor" href="#%e5%90%91%e4%b8%8b%e8%bd%ac%e6%8d%a2%e7%9a%84%e8%83%bd%e5%8a%9b">&lt;/a>
&lt;/h1>&lt;p>和类的指针/引用的转换不同，指向成员的指针既可以&lt;strong>向下转&lt;/strong>，又可以向上转！只需要目的类型拥有对应的成员即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">A&lt;/span> { &lt;span style="color:#dc322f">long&lt;/span> a; };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">B&lt;/span>&lt;span style="color:#719e07">:&lt;/span> A { &lt;span style="color:#dc322f">long&lt;/span> b; };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// long (A::*p) = &amp;amp;B::b; // 错误，A 类型没有成员 B::b
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> (A&lt;span style="color:#719e07">::*&lt;/span>q) &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>B&lt;span style="color:#719e07">::&lt;/span>a; &lt;span style="color:#586e75">// B::a 和 A::a 是相同的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> (B&lt;span style="color:#719e07">::*&lt;/span>r) &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>A&lt;span style="color:#719e07">::&lt;/span>a; &lt;span style="color:#586e75">// 向下转
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="指向数据成员">指向数据成员
&lt;a class="header-anchor" href="#%e6%8c%87%e5%90%91%e6%95%b0%e6%8d%ae%e6%88%90%e5%91%98">&lt;/a>
&lt;/h1>&lt;p>需要存储 this 偏置，按照 Itanium C++ ABI，存储的类型为 &lt;strong>ptrdiff_t&lt;/strong>。一般数据成员指针就用其相对于开头的偏移作为指针的值，而空指针则用 &lt;strong>-1&lt;/strong> 表示。&lt;/p></description></item></channel></rss>