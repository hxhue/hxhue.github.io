<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="4. Synchronizing concurrent operations"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content="cpp,cpp-concurrency-in-action"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"4.-Synchronizing-concurrent-operations","permalink":"https://hxhue.github.io/cpp-concurrency-in-action/4.-Synchronizing-concurrent-operations/","title":"4. Synchronizing concurrent operations","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>4. Synchronizing concurrent operations - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#条件变量>条件变量</a></li><li><a href=#案例线程安全的队列>案例：线程安全的队列</a></li><li><a href=#未来future>未来（Future）</a><ul><li><a href=#stdasync><code>std::async</code></a></li><li><a href=#stdpackaged_task><code>std::packaged_task</code></a></li><li><a href=#stdpromise><code>std::promise</code></a></li><li><a href=#stdshared_future><code>std::shared_future</code></a></li></ul></li><li><a href=#等待一段时间>等待一段时间</a><ul><li><a href=#stdchrono-api><code>std::chrono</code> API</a></li><li><a href=#wait_for-和-wait_until><code>wait_for</code> 和 <code>wait_until</code></a></li></ul></li><li><a href=#案例parallel_quick_sort>案例：<code>parallel_quick_sort</code></a></li><li><a href=#案例用自动状态机思想实现-atm-类>案例：用自动状态机思想实现 ATM 类</a></li><li><a href=#concurrency-ts-中的-stdexperimentalfuture>Concurrency TS 中的 `std::experimental::future</a></li><li><a href=#等待一组-futures>等待一组 futures</a></li><li><a href=#stdlatch-和-stdbarrier><code>std::latch</code> 和 <code>std::barrier</code></a><ul><li><a href=#stdlatch><code>std::latch</code></a></li><li><a href=#stdbarrier><code>std::barrier</code></a><ul><li><a href=#构造函数>构造函数</a></li><li><a href=#成员函数>成员函数</a></li><li><a href=#-arrive-和-wait>✨ <code>arrive()</code> 和 <code>wait()</code></a></li><li><a href=#-completion-函数>✨ completion 函数</a></li></ul></li><li><a href=#stdexperimentalflex_barrier><code>std::experimental::flex_barrier</code></a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-concurrency-in-action/4.-Synchronizing-concurrent-operations/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="4. Synchronizing concurrent operations"><meta itemprop=description content="这一章主要讲线程之间的同步和信息传递，包括条件变量（condition variable）、futures、latches/barries。
条件变量

头文件是 <condition_variable>。包含 std::condition_variable 和 std::condition_variable_any。前者只能在 std::mutex 上使用，后者可以在所有满足 BasicLockable（lock() + unlock()，不需要 try_lock()）的类型上使用。如果只需要使用 std::mutex，那么就用前者，开销可能会比后者小一点。"></span><header class=post-header><h1 class=post-title itemprop="name headline">4. Synchronizing concurrent operations</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-10-02 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-10-02 00:00:00 +0800 CST">2024-10-02
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-01-31T00:00:00+08:00 itemprop=dateModified datetime=2025-01-31T00:00:00+08:00>2025-01-31</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-concurrency-in-action itemprop=url rel=index><span itemprop=name>cpp-concurrency-in-action</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>4769</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>10分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><p>这一章主要讲线程之间的同步和信息传递，包括条件变量（condition variable）、futures、latches/barries。</p><h1 id=条件变量>条件变量
<a class=header-anchor href=#%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f></a></h1><p>头文件是 <code>&lt;condition_variable></code>。包含 <code>std::condition_variable</code> 和 <code>std::condition_variable_any</code>。前者只能在 <code>std::mutex</code> 上使用，后者可以在所有满足 BasicLockable（<code>lock()</code> + <code>unlock()</code>，不需要 <code>try_lock()</code>）的类型上使用。如果只需要使用 <code>std::mutex</code>，那么就用前者，开销可能会比后者小一点。</p><div class="markdown-alert markdown-alert-tip"><p class=markdown-alert-title><svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363.0-4 1.69-4 3.75.0.984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75.0 01-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456.0 00-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863.0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751.0 01-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304.0-2.06-1.637-3.75-4-3.75zM5.75 12h4.5a.75.75.0 010 1.5h-4.5a.75.75.0 010-1.5zM6 15.25a.75.75.0 01.75-.75h2.5a.75.75.0 010 1.5h-2.5A.75.75.0 016 15.25z"/></svg>Tip</p><p>接口只有一处区别：<code>std::condition_variable</code> 可以获取 native handle，而 <code>std::condition_variable_any</code> 不能。</p></div><p>条件变量可以用来协调生产者和消费者之间的关系。</p><p>典型操作流程：</p><ol><li>先用 <code>std::unique_lock</code> 获得锁。</li><li>然后用条件变量来等待锁。这个过程需要一个 pred（用来检查条件是否满足），如果条件已经满足则会直接返回；否则释放锁并陷入休眠，直到自发唤醒（spurious wake）或者被通知（notify）。</li></ol><p>使用方法可以参考 <a href=https://en.cppreference.com/w/cpp/thread/condition_variable title=https://en.cppreference.com/w/cpp/thread/condition_variable rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://en.cppreference.com/w/cpp/thread/condition_variable<i class="fa fa-external-link-alt"></i></a> 。</p><p>之所以不用 <code>std::lock_guard</code> 是因为条件变量的等待对象必须是可解锁的。而 <code>std::unique_lock</code> 又比直接对 <code>std::mutex</code> 操作安全。</p><h1 id=案例线程安全的队列>案例：线程安全的队列
<a class=header-anchor href=#%e6%a1%88%e4%be%8b%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e9%98%9f%e5%88%97></a></h1><p>和第 3 章中线程安全栈一样，书上还是提供了两种重载，一种用传出参数来返回结果，一种返回共享指针。同时，由于队列常常用来协调消费者和生产者之间的关系，因此又有阻塞等待和轮询两个版本。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#dc322f>bool</span> <span style=color:#268bd2>try_pop</span>(T <span style=color:#719e07>&amp;</span>value);
</span></span><span style=display:flex><span>std<span style=color:#719e07>::</span>shared_ptr<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> try_pop(); <span style=color:#586e75>// 如果失败就返回空指针
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#dc322f>void</span> <span style=color:#268bd2>wait_and_pop</span>(T <span style=color:#719e07>&amp;</span>value);
</span></span><span style=display:flex><span>std<span style=color:#719e07>::</span>shared_ptr<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> wait_and_pop();
</span></span></code></pre></div><p>如果生产者完成了生产，那么可以用 <code>notify_one</code> 来通知一个消费者。如果是一个线程完成初始化操作，其他所有线程都能来读取结果，那么可以用 <code>notify_all</code> 来通知。</p><h1 id=未来future>未来（Future）
<a class=header-anchor href=#%e6%9c%aa%e6%9d%a5future></a></h1><p>如果条件变量只需要等待一次，那么用 <code>std::future</code> 可能会更加合适，它<strong>表示一个异步任务的结果</strong>。比较：<code>std::future</code> 是一次性的、而且可以携带数据（如果不携带数据，模板参数就是 <code>void</code>）。<code>std::condition_variable</code> 是可以重复使用的，本身不能携带数据。</p><p>C++ 提供了两种 futures：<code>std::future</code> 和 <code>std::shared_future</code>。</p><h2 id=stdasync><code>std::async</code>
<a class=header-anchor href=#stdasync></a></h2><p>用 <code>std::async</code> 创建任务是获取 future 的一种方式。在 <code>&lt;future></code> 头文件中，C++ 还提供了 <code>std::async</code> 函数模板。<code>std::async</code> 的启动参数可以是 <code>std::launch::async</code> 或者 <code>std::launch::deferred</code>，或者两者都可（默认）。如果启动被延迟，则计算只会在等待或获取结果时才开始计算。</p><p><img src=/cpp-concurrency-in-action/assets/Pasted%20image%2020241002234941.webp></p><h2 id=stdpackaged_task><code>std::packaged_task</code>
<a class=header-anchor href=#stdpackaged_task></a></h2><p>可以和线程池结合使用。</p><p><code>std::packaged_task</code> 的模板参数的含义和 <code>std::function</code> 非常相似。不同之处是 <code>std::function</code> 是同步调用，（只有）调用者可以获取任务的结果，而 <code>std::package_task&lt;></code> 通过暴露出一个 <code>std::future</code>，将计算和获取结果的过程分开，从而计算可以异步进行。</p><p><code>std::packaged_task</code> 只能被成功调用一次，后续的调用将抛出 <a href=https://en.cppreference.com/w/cpp/thread/future_error title=std::future_error rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>std::future_error</code><i class="fa fa-external-link-alt"></i></a> 异常。而 <code>std::function</code> 则可以多次调用。</p><p>感觉 <code>std::async</code> 也是可以用 <code>std::packaged_task</code> 来实现的，前者强调提交任务的功能，后者只是表示任务这个实体。</p><p><a href=https://en.cppreference.com/w/cpp/thread/packaged_task title="来自 cppreference 的例子" rel="noopener external nofollow noreferrer" target=_blank class=exturl>来自 cppreference 的例子<i class="fa fa-external-link-alt"></i></a>：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;cmath&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;functional&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;future&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;iostream&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;thread&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#586e75>// unique function to avoid disambiguating the std::pow overload set
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#dc322f>int</span> <span style=color:#268bd2>f</span>(<span style=color:#dc322f>int</span> x, <span style=color:#dc322f>int</span> y) { <span style=color:#719e07>return</span> std<span style=color:#719e07>::</span>pow(x, y); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>task_thread</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>packaged_task<span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span>(<span style=color:#dc322f>int</span>, <span style=color:#dc322f>int</span>)<span style=color:#719e07>&gt;</span> task(f);
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>future<span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span><span style=color:#719e07>&gt;</span> result <span style=color:#719e07>=</span> task.get_future();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span><span style=color:#268bd2>thread</span> task_td(std<span style=color:#719e07>::</span>move(task), <span style=color:#2aa198>2</span>, <span style=color:#2aa198>10</span>);
</span></span><span style=display:flex><span>    task_td.join(); <span style=color:#586e75>// 这里 detach 也没有关系，因为下面 result.get() 会同步
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#34;task_thread:</span><span style=color:#cb4b16>\t</span><span style=color:#2aa198>&#34;</span> <span style=color:#719e07>&lt;&lt;</span> result.get() <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() { task_thread(); }
</span></span></code></pre></div><h2 id=stdpromise><code>std::promise</code>
<a class=header-anchor href=#stdpromise></a></h2><p>从 <code>std::async</code> 到 <code>std::packaged_task</code>，再到 <code>std::promise</code>，它们实现的功能越来越基础。<code>std::promise</code> 解决了 <code>std::packaged_task</code> 的局限性：有时候获取结果的过程并不能用一个函数来简单表达。</p><p>就像 <code>std::packaged_task</code> 一样，我们可以用 <code>get_future()</code> 来从 <code>std::promise</code> 上获取 future，生产者用 <code>set_value</code> 设置结果。<code>std::promise</code> 还有设置异常的功能：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#586e75>// 1
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>extern</span> std<span style=color:#719e07>::</span>promise<span style=color:#719e07>&lt;</span><span style=color:#dc322f>double</span><span style=color:#719e07>&gt;</span> some_promise;
</span></span><span style=display:flex><span><span style=color:#719e07>try</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    some_promise.set_value(calculate_value());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#719e07>catch</span>(...)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    some_promise.set_exception(std<span style=color:#719e07>::</span>current_exception());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// 2
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>some_promise.set_exception(std<span style=color:#719e07>::</span>make_exception_ptr(std<span style=color:#719e07>::</span>logic_error(<span style=color:#2aa198>&#34;foo &#34;</span>)));
</span></span></code></pre></div><p>如果 <code>std::promise</code> 被析构，但是没有被调用过 <code>set_value()</code> 或者 <code>set_exception()</code>，那么就会存储一个带有 <code>std::future_errc::broken_promise</code> 错误码的 <code>std::future_error</code> 异常。</p><p><code>std::promise</code> 还有 <a href=https://en.cppreference.com/w/cpp/thread/promise/set_value_at_thread_exit title=set_value_at_thread_exit() rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>set_value_at_thread_exit()</code><i class="fa fa-external-link-alt"></i></a> 和 <a href=https://en.cppreference.com/w/cpp/thread/promise/set_exception_at_thread_exit title=set_exception_at_thread_exit rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>set_exception_at_thread_exit</code><i class="fa fa-external-link-alt"></i></a> 方法，可以防止遗漏赋值。</p><h2 id=stdshared_future><code>std::shared_future</code>
<a class=header-anchor href=#stdshared_future></a></h2><p><code>std::future</code> 没有考虑多个消费者之间的数据竞争，所以只能被一个消费者使用，而且是 move-only 的类型；而 <code>std::shared_future</code> 可以被多个消费者使用，是 copyable 的类型。不过，<strong>不同线程应该获取 <code>std::shared_future</code> 的副本，而不是使用同一个引用，才能避免数据竞争</strong>。<a href=https://en.cppreference.com/w/cpp/thread/shared_future title=Cppreference rel="noopener external nofollow noreferrer" target=_blank class=exturl>Cppreference<i class="fa fa-external-link-alt"></i></a> 上给了一个前提：</p><blockquote><p>Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a <code>shared_future</code> object.</p></blockquote><p><a href=https://stackoverflow.com/a/73835675/ title=https://stackoverflow.com/a/73835675/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://stackoverflow.com/a/73835675/<i class="fa fa-external-link-alt"></i></a> 有更详细的解释：<code>std::future</code> 上的等待也是安全的，但是 <code>get()</code> 不是。<code>std::future</code> 的 <code>get()</code> 对非引用类型返回的是值类型，结果被取走之后就没有了。尝试对一个结果取多次会报错 <code>std::future_error: No associated state</code>，就算取走结果之后想要再调用 <code>set_value()</code> 也会报错 <code>std::future_error: Promise already satisfied</code>。</p><p>而 <code>std::shared_future</code> 的 <code>get()</code> 对非引用类型返回常量引用，只要有一个消费者还持有对结果的引用，那么结果就不会被销毁（就像 <code>std::shared_ptr</code> 那样）。因此在 <code>std::shared_future</code> 上可以多次调用 <code>share()</code>。<a href=https://godbolt.org/z/Td37Y96hf title="Compiler Explorer 上的例子" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Compiler Explorer 上的例子<i class="fa fa-external-link-alt"></i></a>。</p><div class="markdown-alert markdown-alert-note"><p class=markdown-alert-title><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>Note</p><p>对于引用类型，<code>std::future</code> 和 <code>std::shared_future</code> 都是返回引用类型本身。</p></div><p>我们需要从 <code>std::future</code> 中创建 <code>std::shared_future</code>，要么传入右值（亡值或者纯右值）来构建：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#586e75>// 1
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>std<span style=color:#719e07>::</span>promise<span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span><span style=color:#719e07>&gt;</span> p;
</span></span><span style=display:flex><span>std<span style=color:#719e07>::</span>future<span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span><span style=color:#719e07>&gt;</span> f(p.get_future());
</span></span><span style=display:flex><span>assert(f.valid());                        
</span></span><span style=display:flex><span>std<span style=color:#719e07>::</span>shared_future<span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span><span style=color:#719e07>&gt;</span> sf(std<span style=color:#719e07>::</span>move(f));
</span></span><span style=display:flex><span>assert(<span style=color:#719e07>!</span>f.valid());                       
</span></span><span style=display:flex><span>assert(sf.valid())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// 2
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>std<span style=color:#719e07>::</span>promise<span style=color:#719e07>&lt;</span>std<span style=color:#719e07>::</span>string<span style=color:#719e07>&gt;</span> p;
</span></span><span style=display:flex><span>std<span style=color:#719e07>::</span>shared_future<span style=color:#719e07>&lt;</span>std<span style=color:#719e07>::</span>string<span style=color:#719e07>&gt;</span> sf(p.get_future());
</span></span></code></pre></div><p>要么调用 <code>std::future</code> 的 <code>.shared()</code> 方法：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>auto</span> sf <span style=color:#719e07>=</span> p.get_future().share();
</span></span></code></pre></div><h1 id=等待一段时间>等待一段时间
<a class=header-anchor href=#%e7%ad%89%e5%be%85%e4%b8%80%e6%ae%b5%e6%97%b6%e9%97%b4></a></h1><p>之前介绍的等待函数都只能永久等待，不能指定等待的时间。这个小节还介绍了一些 <code>std::chrono</code> 中的 API。</p><h2 id=stdchrono-api><code>std::chrono</code> API
<a class=header-anchor href=#stdchrono-api></a></h2><p>时钟：</p><ul><li><code>std::chrono::steady_clock</code></li><li><code>std::chrono::system_clock</code> 不是稳定的，因为时间可以设定。其 time_point 可以和 <code>std::time_t</code> 通过 <code>to_time_t</code> 和 <code>from_time_t</code> 相互转换。</li><li><code>std::chrono::high_resolution_clock</code></li></ul><p>时间：</p><p><code>std::chrono::duration&lt;></code> 的模板参数是表示类型（比如 double）和 ratio（单位是秒）。</p><p>在 <code>std::chrono</code> 中有很多时间单位的定义：<code>nanoseconds</code>, <code>microseconds</code>, <code>milliseconds</code>, <code>seconds</code>, <code>minutes</code>, <code>hours</code> 等。在 <code>std</code> 中有很多 SI 比例的定义：<code>std::atto</code>（1e-18）、<code>std::exa</code>（1e18）等，见 <a href=https://en.cppreference.com/w/cpp/numeric/ratio/ratio title=https://en.cppreference.com/w/cpp/numeric/ratio/ratio rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://en.cppreference.com/w/cpp/numeric/ratio/ratio<i class="fa fa-external-link-alt"></i></a> 。尤其是要注意 <code>std::milli</code>、<code>std::micro</code>、<code>std::nano</code> 这些是 SI 比例，而不是时间单位。</p><p>用字面量后缀操作符更方便地表示时间：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>using</span> <span style=color:#719e07>namespace</span> std<span style=color:#719e07>::</span>chrono_literals;
</span></span><span style=display:flex><span><span style=color:#719e07>auto</span> one_day<span style=color:#719e07>=</span><span style=color:#2aa198>24</span>h;
</span></span><span style=display:flex><span><span style=color:#719e07>auto</span> half_an_hour<span style=color:#719e07>=</span><span style=color:#2aa198>30</span>min;
</span></span><span style=display:flex><span><span style=color:#719e07>auto</span> max_time_between_messages<span style=color:#719e07>=</span><span style=color:#2aa198>30</span>ms;
</span></span></code></pre></div><p>从一个时间单位转换到另外一个时间单位用 <code>std::chrono::duration_cast</code>。此外，duration 还支持算术运算！</p><p>时刻（时间点）：</p><p><code>std::chrono::time_point&lt;></code>。时间点的值是相关时钟的纪元（epoch）。</p><blockquote><p>Although you can’t find out when the epoch is, you can get the <code>time_since_epoch()</code> for a given time_point. This member function returns a duration value specifying the length of time since the clock epoch to that particular time point.</p></blockquote><h2 id=wait_for-和-wait_until><code>wait_for</code> 和 <code>wait_until</code>
<a class=header-anchor href=#wait_for-%e5%92%8c-wait_until></a></h2><p><code>wait_for</code> 配合时间，<code>wait_util</code> 配合时刻。很多时候 <code>wait_until</code> 比 <code>wait_for</code> 更合适，比如在循环中等待条件变量但是又不传 predicate 的时候，由于虚假唤醒的存在，<code>wait_*</code> 可能会被调用多次，那么 <code>wait_until</code> 能更加准确地表示时间，而不是（可能）永远无法离开循环。（所以用条件变量还是传 predicate 比较好。）</p><h1 id=案例parallel_quick_sort>案例：<code>parallel_quick_sort</code>
<a class=header-anchor href=#%e6%a1%88%e4%be%8bparallel_quick_sort></a></h1><p>书中使用 <code>std::list</code> 的 <code>splice()</code> 操作、<code>std::partition</code> 操作和 <code>std::async</code> 操作来实现了一个并行的快速排序算法。这个快速排序算法遵循函数式编程的思想，只对输入做更改，并将结果以返回值的形式体现。每次找到 pivot 的时候都用 <code>std::async</code> 创建一个新的任务。现在只有子区间是并行的，分区过程本身不是并行的。</p><p>在默认策略下，<code>std::async</code> 不一定每次都要创建新的线程，是否创建新的线程由库的实现决定。</p><h1 id=案例用自动状态机思想实现-atm-类>案例：用自动状态机思想实现 ATM 类
<a class=header-anchor href=#%e6%a1%88%e4%be%8b%e7%94%a8%e8%87%aa%e5%8a%a8%e7%8a%b6%e6%80%81%e6%9c%ba%e6%80%9d%e6%83%b3%e5%ae%9e%e7%8e%b0-atm-%e7%b1%bb></a></h1><p>书里前面讲了 FP，这里实现 ATM 则是为了体现 CSP 的思想。这份代码很有意思，通过一个指向成员函数的指针来转移状态，比设置枚举量，然后用 switch 来跳转要显得更加优雅。</p><p><img src=/cpp-concurrency-in-action/assets/Pasted%20image%2020241130004610.webp width=600></p><p>这种编程范式又被叫做演员模型（Actor Model），每个线程充当一个角色，执行不同的任务。</p><h1 id=concurrency-ts-中的-stdexperimentalfuture>Concurrency TS 中的 `std::experimental::future
<a class=header-anchor href=#concurrency-ts-%e4%b8%ad%e7%9a%84-stdexperimentalfuture></a></h1><p><strong>增加了延续（continuation）的概念，可以用 <code>then</code> 函数来组织 futures（Java、Javascript 都有类似的函数）。但是这个提案被废弃，并被（被认为更好的） executors 来代替</strong>，后者被包含在 C++26 中。</p><p><code>std::experimental::shared_future</code> 也可以用 <code>then</code>，而且可用多次。</p><blockquote><p>The difference here is that <code>std::experimental::shared_future</code> objects can have more than one continuation, and the continuation parameter is a <code>std::experimental:: shared_future</code> rather than a <code>std::experimental::future</code>.</p></blockquote><h1 id=等待一组-futures>等待一组 futures
<a class=header-anchor href=#%e7%ad%89%e5%be%85%e4%b8%80%e7%bb%84-futures></a></h1><p>如果有一组 futures 需要等待，而且等待的过程是由当前接口的使用方来进行的，那么可以创建一个新的 future，并且在这个 future 里面等待之前的所有 futures。</p><p><img src=/cpp-concurrency-in-action/assets/Pasted%20image%2020241208151603.webp></p><p>我认为这里可以添加一个 <code>std::launch::deferred</code> 标记，这样就不必为“等待”这个过程创建一个新的线程了。</p><p>在 Concurrency TS 中有 <a href=https://en.cppreference.com/w/cpp/experimental/when_all title=std::experimental::when_all rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>std::experimental::when_all</code><i class="fa fa-external-link-alt"></i></a>（返回一组 futures） 和 <a href=https://en.cppreference.com/w/cpp/experimental/when_any title=std::experimental::when_any rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>std::experimental::when_any</code><i class="fa fa-external-link-alt"></i></a>（返回一个 <code>match_any_result</code>，它包含原来的 futures 和首先可用的 future 的下标），它们分别创建在 futures 都可用时可用的新 future，和至少有一个可用就可用的新 future。<strong>前者（<code>when_all</code>）可以由上面截图的代码来模拟</strong>。后者在书上没有给出模拟的代码。</p><h1 id=stdlatch-和-stdbarrier><code>std::latch</code> 和 <code>std::barrier</code>
<a class=header-anchor href=#stdlatch-%e5%92%8c-stdbarrier></a></h1><p>写书时这两个类还在 Concurrency TS 中，现在这两个类已经加入 C++20 中。</p><h2 id=stdlatch><code>std::latch</code>
<a class=header-anchor href=#stdlatch></a></h2><p><code>std::latch</code> 模型比较简单，只能使用一次，一旦计数降低（<code>count_down()</code>）到 0，就永远保持在 ready 状态（在 Concurrency TS 中可以用 <code>is_ready()</code> 查询，而在 C++20 中有 <code>try_wait()</code> 方法来查询）。</p><h2 id=stdbarrier><code>std::barrier</code>
<a class=header-anchor href=#stdbarrier></a></h2><p>C++20 的 <code>std::barrier</code> 是结合了 Concurrency TS 中 <code>barrier</code> 和 <code>flex_barrier</code> 特性的类。它是一个模板类，但是 <code>std::experimental::barrier</code> 和 <code>std::experimental::flex_barrier</code> 不是。</p><div class="markdown-alert markdown-alert-note"><p class=markdown-alert-title><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>Note</p><p><code>std::experimental::flex_barrier</code> 接受 completion 函数，但是居然不是类模板，应该是有类型擦除。</p></div><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span> <span style=color:#719e07>class</span> <span style=color:#268bd2>CompletionFunction</span> <span style=color:#719e07>=</span> <span style=color:#586e75>/* ... */</span> <span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>barrier</span>;
</span></span></code></pre></div><p>接下来的内容会直接介绍 <code>std::barrier</code>，并指出它和 <code>std::experimental::barrier</code> 的区别。</p><p><code>std::barrier</code> 和 <code>std::string</code> 不一样，<code>std::string</code> 是 <code>std::basic_string</code> 的特化，是一个具体的类，而 <code>std::barrier</code> 是一个类模板，虽然在定义时可以利用 CTAD，显得和普通类没有区别，但是在声明时必须体现它是模板类。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-diff data-lang=diff><span style=display:flex><span>    #include &lt;barrier&gt;
</span></span><span style=display:flex><span>    struct Foo {
</span></span><span style=display:flex><span><span style=color:#dc322f>-       std::barrier b;   // ❌
</span></span></span><span style=display:flex><span><span style=color:#dc322f></span><span style=color:#719e07>+       std::barrier&lt;&gt; b; // ✔
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>    };
</span></span></code></pre></div><p>它还有个静态常量函数是 <a href=https://en.cppreference.com/w/cpp/thread/barrier/max title=max rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>max</code><i class="fa fa-external-link-alt"></i></a>，表示当前实现中允许的最大初始值。在 <a href=https://godbolt.org/z/an3nE6qPY title=我的一个测试 rel="noopener external nofollow noreferrer" target=_blank class=exturl>我的一个测试<i class="fa fa-external-link-alt"></i></a> 中返回 64 位有符号数的最大值（不代表每个平台都是这样）。</p><p>很常见的一个 barrier 的使用场景是用 CUDA 中的 <code>__syncthreads()</code> 完成块内的同步。</p><h3 id=构造函数>构造函数
<a class=header-anchor href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0></a></h3><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>constexpr</span> <span style=color:#719e07>explicit</span> <span style=color:#268bd2>barrier</span>( std<span style=color:#719e07>::</span>ptrdiff_t expected,
</span></span><span style=display:flex><span>                            CompletionFunction f <span style=color:#719e07>=</span> CompletionFunction());
</span></span><span style=display:flex><span>barrier( <span style=color:#719e07>const</span> barrier<span style=color:#719e07>&amp;</span> ) <span style=color:#719e07>=</span> <span style=color:#719e07>delete</span>;
</span></span></code></pre></div><p>第二个构造函数的声明标志着拷贝构造函数、移动构造函数 / 赋值操作符的删除。可以参考
<a href=/posts/programming/cpp/C++-Rule-of-3-5-0/ title="C++ - Rule of 3, 5, 0">C++ - Rule of 3, 5, 0</a>。</p><h3 id=成员函数>成员函数
<a class=header-anchor href=#%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0></a></h3><p><a href=https://en.cppreference.com/w/cpp/thread/barrier/barrier title=std::barrier rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>std::barrier</code><i class="fa fa-external-link-alt"></i></a> 可以反复使用，一组线程必须要一起来到等待点才能通过，都通过等待点之后计数器就会重置。每一轮叫做 <em>barrier phase</em>。其设计思想是：只有在同步组中的线程才能使用 <code>arrive()</code> 来减少计数，而且在每个 phase 只能 <code>arrive</code> 一次。它有以下几个方法：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>arrive         : 计数减 1，返回 arrival_token
</span></span><span style=display:flex><span>wait           : 在同步点（phase synchronization point）等待计数归零，需要 arrival_token 作为参数
</span></span><span style=display:flex><span>arrive_and_wait: 计数减 1，并且在同步点等待计数归零
</span></span><span style=display:flex><span>arrive_and_drop: 计数减 1，并且退出同步组
</span></span></code></pre></div><p><code>std::barrier</code> 有一个删除了的 <code>operator=</code>，这也标志着其无法拷贝赋值。（注意：禁用拷贝构造并不会禁用拷贝赋值，两者需要分别禁用。）</p><h3 id=-arrive-和-wait>✨ <code>arrive()</code> 和 <code>wait()</code>
<a class=header-anchor href=#-arrive-%e5%92%8c-wait></a></h3><p>也就是说，如果不想阻塞其他线程继续前进，可以使用 <code>arrive</code> 而不是 <code>arrive_and_wait</code>，但是接下来要用 <code>wait</code> 同步，同时要传入之前 <code>arrive</code> 返回的 <code>arrival_token</code>。参考 <a href=https://stackoverflow.com/questions/72213987/how-to-use-c-stdbarrier-arrival-token title=https://stackoverflow.com/questions/72213987/how-to-use-c-stdbarrier-arrival-token rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://stackoverflow.com/questions/72213987/how-to-use-c-stdbarrier-arrival-token<i class="fa fa-external-link-alt"></i></a> 。<strong><code>arrive()</code> 和 <code>wait()</code> 是 <code>std::barrier</code> 相比 <code>std::experimental::barrier</code> 多出的两个函数。</strong></p><h3 id=-completion-函数>✨ completion 函数
<a class=header-anchor href=#-completion-%e5%87%bd%e6%95%b0></a></h3><p>和只能指定线程数量的 <a href=https://en.cppreference.com/w/cpp/experimental/barrier/barrier title=std::experiment::barrier rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>std::experiment::barrier</code><i class="fa fa-external-link-alt"></i></a> 相比，<strong><code>std::barrier</code> 还可以指定 completion 函数</strong>，这个函数在所有线程达到同步点时运行，而且只会被一个线程运行。从 <a href=https://godbolt.org/z/1hMKKqve5 title=https://godbolt.org/z/1hMKKqve5 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://godbolt.org/z/1hMKKqve5<i class="fa fa-external-link-alt"></i></a> 的结果来看，应该是被最后一个到达同步点的线程运行。如果没有线程调用 <code>wait()</code>，那么 completion 函数是否被调用是实现定义的：</p><blockquote><p>A barrier <em>phase</em> consists of the following steps:</p><ol><li>The <em>expected count</em> is decremented by each call to <a href=https://en.cppreference.com/w/cpp/thread/barrier/arrive title=arrive rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>arrive</code><i class="fa fa-external-link-alt"></i></a> or <a href=https://en.cppreference.com/w/cpp/thread/barrier/arrive_and_drop title=arrive_and_drop rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>arrive_and_drop</code><i class="fa fa-external-link-alt"></i></a>.</li><li>When the expected count reaches zero, the <em>phase completion step</em> is run, meaning that the <a href=https://en.cppreference.com/w/cpp/thread/barrier#Data_members title=_completion_ rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>_completion_</code><i class="fa fa-external-link-alt"></i></a> is invoked, and all threads blocked on the phase synchronization point are unblocked. The end of the completion step <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Strongly_happens-before title="strongly happens-before" rel="noopener external nofollow noreferrer" target=_blank class=exturl>strongly happens-before<i class="fa fa-external-link-alt"></i></a> all calls that were unblocked by the completion step return.<br>Exactly once after the expected count reaches zero, <mark>a thread executes the completion step during its call to <a href=https://en.cppreference.com/w/cpp/thread/barrier/arrive title=arrive rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>arrive</code><i class="fa fa-external-link-alt"></i></a>, <a href=https://en.cppreference.com/w/cpp/thread/barrier/arrive_and_drop title=arrive_and_drop rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>arrive_and_drop</code><i class="fa fa-external-link-alt"></i></a>, or <a href=https://en.cppreference.com/w/cpp/thread/barrier/wait title=wait rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>wait</code><i class="fa fa-external-link-alt"></i></a></mark>, <mark>except that it is implementation-defined whether the step executes if no thread calls <a href=https://en.cppreference.com/w/cpp/thread/barrier/wait title=wait rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>wait</code><i class="fa fa-external-link-alt"></i></a></mark>.</li><li>When the completion step finishes, the expected count is reset to the value specified at construction less the number of calls to <a href=https://en.cppreference.com/w/cpp/thread/barrier/arrive_and_drop title=arrive_and_drop rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>arrive_and_drop</code><i class="fa fa-external-link-alt"></i></a> since, and the next <em>barrier phase</em> begins.</li></ol></blockquote><p>上述引用也表明最后一个到达的线程会在调用 <code>arrive</code> 等方法的时候来执行 completion 函数。</p><p>Completion 函数可以简化很多代码逻辑，特别是每一轮需要清理工作时。如果没有 completion 函数，而是由 0 号线程完成清理工作，为了防止其他线程在清理工作完成之前进入下一轮工作，需要增加一个同步点——在第二个同步点只有 0 号线程在完成清理工作，其他线程阻塞等待。一方面是逻辑代码会显得复杂，另一方面是<strong>其他线程刚被唤醒又要再次进入睡眠状态等待清理工作完成</strong>。</p><h2 id=stdexperimentalflex_barrier><code>std::experimental::flex_barrier</code>
<a class=header-anchor href=#stdexperimentalflex_barrier></a></h2><p>Concurrency TS 中还有一个 <code>flex_barrier</code>，但是没有进入 C++20。这个类可以随时修改同步组中的线程数量，还可以指定所有线程到达同步点时要运行的 completion 函数（<code>std::experiment::barrier</code> 没有这个功能，但是 <code>std::barrier</code> 有）。<code>flex_barrier</code> 可以通过 completion 函数的返回值来修改下一轮同步组中的线程数量，-1 表示不改变，非负表示下一轮同步组中的线程数量，这个特性是 <code>std::barrier</code> 不具备的。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/cpp>cpp
</a><a href=/tags/cpp-concurrency-in-action>cpp-concurrency-in-action</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/cpp-concurrency-in-action/5.-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E6%A0%87%E5%87%86%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%87%AA%E6%97%8B%E9%94%81/ rel=next title="5. 内存模型基础、标准原子类型、自旋锁"><i class="fa fa-chevron-left"></i> 5. 内存模型基础、标准原子类型、自旋锁</a></div><div class="post-nav-prev post-nav-item"><a href=/cpp-concurrency-in-action/3.-Sharing-data-between-threads/ rel=prev title="3. Sharing data between threads">3. Sharing data between threads
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>