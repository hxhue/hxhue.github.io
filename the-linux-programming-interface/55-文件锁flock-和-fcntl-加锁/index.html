<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="55 文件锁：flock() 和 fcntl() 加锁"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content="the-linux-programming-interface"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"55-%E6%96%87%E4%BB%B6%E9%94%81flock-%E5%92%8C-fcntl-%E5%8A%A0%E9%94%81","permalink":"https://hxhue.github.io/the-linux-programming-interface/55-%E6%96%87%E4%BB%B6%E9%94%81flock-%E5%92%8C-fcntl-%E5%8A%A0%E9%94%81/","title":"55 文件锁：flock() 和 fcntl() 加锁","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>55 文件锁：flock() 和 fcntl() 加锁 - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#要点>要点</a></li><li><a href=#flock-对整个文件加锁><code>flock()</code> 对整个文件加锁</a><ul><li><a href=#flock-锁转换不是原子的><code>flock()</code> 锁转换不是原子的</a></li><li><a href=#flock-锁的释放和继承><code>flock()</code> 锁的释放和继承</a></li><li><a href=#flock-的限制><code>flock()</code> 的限制</a></li><li><a href=#内核如何维护-flock-锁>内核如何维护 <code>flock()</code> 锁？</a></li></ul></li><li><a href=#fcntl-对文件部分区域加锁><code>fcntl()</code> 对文件部分区域加锁</a><ul><li><a href=#记录锁的释放和继承>记录锁的释放和继承</a></li><li><a href=#内核如何维护记录锁>内核如何维护记录锁？</a></li><li><a href=#强制锁支持>强制锁支持</a></li></ul></li><li><a href=#proclocks-文件和-lslocks-命令>/proc/locks 文件和 <code>lslocks</code> 命令</a></li><li><a href=#文件租用书上没有但是-man-手册很详细>文件租用（书上没有，但是 man 手册很详细）</a></li><li><a href=#仅运行一个程序的单个实例>仅运行一个程序的单个实例</a></li><li><a href=#老的进程加锁技术>老的进程加锁技术</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/55-%E6%96%87%E4%BB%B6%E9%94%81flock-%E5%92%8C-fcntl-%E5%8A%A0%E9%94%81/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="55 文件锁：flock() 和 fcntl() 加锁"><meta itemprop=description content="要点

Linux 提供了两种文件加锁系统调用：从 BSD 衍生出来的 flock() 和从 System V 衍生出来的 fcntl()。尽管这两组系统调用在大多数 UNIX 实现上都是可用的，但只有 fcntl() 加锁在 SUSv3 中进行了标准化。"></span><header class=post-header><h1 class=post-title itemprop="name headline">55 文件锁：flock() 和 fcntl() 加锁</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-05 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-05 00:00:00 +0800 CST">2024-08-05
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-09-07T00:00:00+08:00 itemprop=dateModified datetime=2024-09-07T00:00:00+08:00>2024-09-07</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>3115</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>7分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=要点>要点
<a class=header-anchor href=#%e8%a6%81%e7%82%b9></a></h1><p>Linux 提供了两种文件加锁系统调用：从 BSD 衍生出来的 <code>flock()</code> 和从 System V 衍生出来的 <code>fcntl()</code>。尽管这两组系统调用在大多数 UNIX 实现上都是可用的，但只有 fcntl() 加锁在 SUSv3 中进行了标准化。</p><p>要理解 <code>flock()</code> 和 <code>fcntl()</code> 的锁分别和什么东西有关联，才能理解什么行为会导致锁的意外释放。“锁和什么有关联”意思就是以什么来标识锁的主人。而锁的对象则分别是整个文件（<code>flock()</code>）和指定区域（<code>fcntl()</code>）。锁是要放在锁的对象上的，所以锁链表在打开文件上记录。</p><h1 id=flock-对整个文件加锁><code>flock()</code> 对整个文件加锁
<a class=header-anchor href=#flock-%e5%af%b9%e6%95%b4%e4%b8%aa%e6%96%87%e4%bb%b6%e5%8a%a0%e9%94%81></a></h1><p>从 BSD 衍生而来。加的是劝告锁（advisory locking）。</p><p>flock(2)：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span>SYNOPSIS
</span></span><span style=display:flex><span>       <span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/file.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span>       <span style=color:#dc322f>int</span> <span style=color:#268bd2>flock</span>(<span style=color:#dc322f>int</span> fd, <span style=color:#dc322f>int</span> operation);
</span></span></code></pre></div><p>操作有三种：<code>LOCK_SH</code>、<code>LOCK_EX</code>、<code>LOCK_UN</code>。还可以<strong>或</strong>上标志 <code>LOCK_NB</code> 表示非阻塞。从语义来看是标准的读写锁，但是却没有明确提到“读写”这个概念。</p><h2 id=flock-锁转换不是原子的><code>flock()</code> 锁转换不是原子的
<a class=header-anchor href=#flock-%e9%94%81%e8%bd%ac%e6%8d%a2%e4%b8%8d%e6%98%af%e5%8e%9f%e5%ad%90%e7%9a%84></a></h2><p>如果已经持有了文件的锁，现在指定了另外一种类型的锁，则会先解除锁定，再重新请求锁。这个过程称为锁转换，这个过程不是原子的！有可能在释放锁之后另外一个进程获得了锁，导致阻塞，或者（在非阻塞情况下）丢失了锁而失败返回。</p><h2 id=flock-锁的释放和继承><code>flock()</code> 锁的释放和继承
<a class=header-anchor href=#flock-%e9%94%81%e7%9a%84%e9%87%8a%e6%94%be%e5%92%8c%e7%bb%a7%e6%89%bf></a></h2><p><mark><code>flock()</code> 锁和打开的文件项（是 <em>file description</em> 而不是 descriptor）相关</mark>，如果打开文件项从系统打开文件表中撤下（引用计数归 0），则对应的文件项的锁会被释放。</p><p>另外一方面，显式释放锁会导致系统打开文件表上的这个文件项中记录的锁的释放！</p><ol><li><code>dup()</code> 来的 fd 会指向同一个打开文件项，关闭其一会使得文件被关闭，锁也会被释放。如果想要一个 fd 一把锁，那就不要 <code>dup()</code>，而是打开同一个文件多次。</li><li><code>flock()</code> 锁可以跨越 <code>fork()</code>，但是子进程和父进程共享同样的打开文件项，因此共享同样的锁，操作不当（比如子进程关闭文件）将会导致父进程的锁一起丢失（实际上，锁并不以进程标识）。</li><li><code>flock()</code> 锁能跨越 <code>exec()</code>，除非文件项设置了 close-on-exec，这样锁会随着文件的关闭而解除。<code>dup()</code> 来的 fd、以及子进程继承的 fd 都指向同样的打开文件项，只有都关闭了之后 <code>flock()</code> 的锁才会释放，因此父进程可以通过关闭 fd 而将锁转让给子进程（这时只有子进程能通过 fd 控制锁）。</li></ol><h2 id=flock-的限制><code>flock()</code> 的限制
<a class=header-anchor href=#flock-%e7%9a%84%e9%99%90%e5%88%b6></a></h2><ol><li>只能加劝告锁。</li><li>只能对整个文件加锁。</li><li>很多 NFS 实现对 <code>flock()</code> 支持不好。</li></ol><h2 id=内核如何维护-flock-锁>内核如何维护 <code>flock()</code> 锁？
<a class=header-anchor href=#%e5%86%85%e6%a0%b8%e5%a6%82%e4%bd%95%e7%bb%b4%e6%8a%a4-flock-%e9%94%81></a></h2><p>内核在与一个打开着的文件相关联的锁链表中维护着 <code>flock()</code> 锁与文件租用。/proc/locks 文件中可能会记录相关信息？</p><h1 id=fcntl-对文件部分区域加锁><code>fcntl()</code> 对文件部分区域加锁
<a class=header-anchor href=#fcntl-%e5%af%b9%e6%96%87%e4%bb%b6%e9%83%a8%e5%88%86%e5%8c%ba%e5%9f%9f%e5%8a%a0%e9%94%81></a></h1><p>从 System V 衍生而来。加的是劝告锁还是强制锁（mandatory locking）取决于文件是否打开了强制锁支持（权限位）。</p><p><code>fcntl()</code> 可以对文件的一部分加锁，<strong>这种形式的锁也叫做记录锁</strong>（record locking）。SUSv3 要求至少能对普通文件加锁，Linux 实现中所有类型的文件都能加锁。</p><p>fcntl() 操作锁时可以指定 <code>F_SETLK</code>（非阻塞加锁）、<code>F_GETLK</code>（试探能否加锁）、<code>F_SETLKW</code>（阻塞加锁） 三种操作。</p><p><strong><code>fcntl()</code> 的锁在接口上有了“读写”的概念</strong>，因此有权限检查。为了加写锁，必须对文件有写入权限；为了加读锁，必须对文件有读取权限；如果同时加读写锁，则必须有读写权限（在同一个区域上只能有一把锁，但是文件的不同区域可以有不同类型的锁）。</p><p><code>fcntl()</code> 的锁转换是原子的。如果同一个位置放新锁，锁的类型相同则直接返回，锁的类型不同则会发生原子转换，不会在丢掉锁的情况下返回。</p><p>在一块已锁定区域的中间一小片区域放一把类型不同的锁，会导致持有三把锁。</p><p><code>fcntl()</code> 加锁有死锁检测功能。</p><h2 id=记录锁的释放和继承>记录锁的释放和继承
<a class=header-anchor href=#%e8%ae%b0%e5%bd%95%e9%94%81%e7%9a%84%e9%87%8a%e6%94%be%e5%92%8c%e7%bb%a7%e6%89%bf></a></h2><ol><li><code>fcntl()</code> 记录锁不会跨越 <code>fork()</code>，这是因为记录锁和进程有关系（见第 3 点）。</li><li><code>fcntl()</code> 记录锁在 <code>exec()</code> 中会得到保留！</li><li><mark><code>fcntl()</code> 记录锁和<strong>进程</strong> + <strong>i-node</strong> 关联</mark>。同一个进程打开同一个文件多次，通过一个 fd 对文件上锁之后，<mark>关闭另外一个 fd 会因为文件关闭事件而使得文件锁丢失</mark>。其他 fd 虽然指向的是不同的系统打开文件项，但在同一个进程中依然共享一个锁。<em>这和 <code>flock()</code> 不同，<code>flock()</code> 和文件描述关联，如果不显式释放锁，只有所有文件描述符都关闭之后文件描述对应的锁才会释放。</em></li></ol><h2 id=内核如何维护记录锁>内核如何维护记录锁？
<a class=header-anchor href=#%e5%86%85%e6%a0%b8%e5%a6%82%e4%bd%95%e7%bb%b4%e6%8a%a4%e8%ae%b0%e5%bd%95%e9%94%81></a></h2><p><img src=/the-linux-programming-interface/tlpi-assets/Pasted%20image%2020240808232333.webp></p><p>每个打开文件上都有一个记录锁链表。链表是有序的：先按进程号排序，再按<strong>起始</strong>偏移量排序。</p><h2 id=强制锁支持>强制锁支持
<a class=header-anchor href=#%e5%bc%ba%e5%88%b6%e9%94%81%e6%94%af%e6%8c%81></a></h2><p>用 mand 选项挂载文件系统可以启用强制锁的支持。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>mount -o mand /dev/sda10 /testfs
</span></span></code></pre></div><p><strong>这种支持是通过打开文件的 set-group-ID 权限位、关闭 group-execute 权限位实现的</strong>。对单个文件启用强制锁支持：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>chmod g+s,g-x /testfs/file
</span></span></code></pre></div><p>如果一个文件上被启用了强制锁支持，那么相当于每个用于读写的系统调用都会临时获取对应区域的锁（如果还没有锁的话）。</p><p>在一个开启了强制锁支持的文件上，<code>mmap()</code> 共享文件映射和任何的读写锁都是排斥的。这是因为 <code>mmap()</code> 共享文件映射需要读写权限，相当于读写锁的有效期是整个映射期间。不过，内核检查的更严格一点：只要是同一个文件，任意位置的强制读 / 写锁都和任意位置的 <code>mmap()</code> 排斥。</p><p>一些缺点：</p><ol><li>强制读写检查并不影响删除文件。</li><li>特权进程也不能覆盖强制锁。（但可以杀掉持有锁的进程。）</li><li>强制上锁有性能开销。</li><li>读写系统调用更可能失败或阻塞了，应用设计变得复杂。</li></ol><h1 id=proclocks-文件和-lslocks-命令>/proc/locks 文件和 <code>lslocks</code> 命令
<a class=header-anchor href=#proclocks-%e6%96%87%e4%bb%b6%e5%92%8c-lslocks-%e5%91%bd%e4%bb%a4></a></h1><p>记录了锁由什么进程持有（可以配合 ps 等工具查看进程信息）。如果锁类型前面加了 <code>-></code>，表示这是一个被阻塞的锁请求（还没有获得锁），下面的例子中没有这种情况。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>(base) xxx@yyy:~$ cat  /proc/locks
</span></span><span style=display:flex><span>1: FLOCK  ADVISORY  WRITE 2356 08:01:258736157 0 EOF
</span></span><span style=display:flex><span>2: FLOCK  ADVISORY  READ 184242 00:229:260005901 0 EOF
</span></span><span style=display:flex><span>3: POSIX  ADVISORY  READ 3903125 103:03:13243512 128 128
</span></span><span style=display:flex><span>4: POSIX  ADVISORY  READ 3903125 103:03:13238296 1073741826 1073742335
</span></span><span style=display:flex><span>5: FLOCK  ADVISORY  WRITE 2356 08:01:258867202 0 EOF
</span></span><span style=display:flex><span>6: POSIX  ADVISORY  READ 2141698 00:dc:262314226 128 128
</span></span><span style=display:flex><span>7: POSIX  ADVISORY  READ 3811720 103:03:13255374 128 128
</span></span><span style=display:flex><span>8: POSIX  ADVISORY  READ 3811720 103:03:13255370 1073741826 1073742335
</span></span><span style=display:flex><span>9: FLOCK  ADVISORY  WRITE 5472 00:e5:15466515 0 EOF
</span></span><span style=display:flex><span>10: FLOCK  ADVISORY  WRITE 2356 08:01:258736387 0 EOF
</span></span><span style=display:flex><span>11: POSIX  ADVISORY  WRITE 1640 00:19:2400 0 EOF
</span></span><span style=display:flex><span>12: POSIX  ADVISORY  WRITE 2268 00:19:2635 0 EOF
</span></span><span style=display:flex><span>13: FLOCK  ADVISORY  WRITE 2356 08:01:258736388 0 EOF
</span></span><span style=display:flex><span>14: FLOCK  ADVISORY  WRITE 2356 08:01:258736386 0 EOF
</span></span><span style=display:flex><span>15: FLOCK  ADVISORY  WRITE 2356 08:01:258736247 0 EOF
</span></span><span style=display:flex><span>16: OFDLCK ADVISORY  WRITE -1 08:01:258736332 0 EOF
</span></span><span style=display:flex><span>17: POSIX  ADVISORY  READ 2372 103:03:14946021 128 128
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>POSIX 表示 <code>fcntl()</code> 申请的锁，FLOCK 表示 <code>flock()</code> 申请的锁。/proc/locks 还显示了文件租用的信息。</p><p>查找一个锁记录对应的进程是什么、文件是什么：</p><p><img src=/the-linux-programming-interface/tlpi-assets/Pasted%20image%2020240809122006.webp></p><p>还可以用 <code>lslocks</code> 命令查看系统中创建的锁的情况（有点像 <code>ipcs</code>）。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#719e07>(</span>base<span style=color:#719e07>)</span> xxx ~ $ lslocks
</span></span><span style=display:flex><span>COMMAND PID  TYPE SIZE MODE  M START END PATH
</span></span><span style=display:flex><span>cron     <span style=color:#2aa198>82</span> FLOCK      WRITE <span style=color:#2aa198>0</span>     <span style=color:#2aa198>0</span>   <span style=color:#2aa198>0</span> /run...
</span></span></code></pre></div><h1 id=文件租用书上没有但是-man-手册很详细>文件租用（书上没有，但是 man 手册很详细）
<a class=header-anchor href=#%e6%96%87%e4%bb%b6%e7%a7%9f%e7%94%a8%e4%b9%a6%e4%b8%8a%e6%b2%a1%e6%9c%89%e4%bd%86%e6%98%af-man-%e6%89%8b%e5%86%8c%e5%be%88%e8%af%a6%e7%bb%86></a></h1><p>fcntl(2) 的 <code>F_SETLEASE</code> / <code>F_GETLEASE</code> 操作。</p><p>如果一个进程成为租用持有者（lease holder），其他进程（lease breaker）打开或截断文件（<code>open()</code>、<code>truncate()</code>）文件时，租用持有者会收到信号通知。</p><p>在使用 <code>F_SETLEASE</code> 操作使用以下参数之一：</p><ol><li><code>F_RDLCK</code>：读锁。</li><li><code>F_WRLCK</code>：写锁。</li><li><code>F_UNLCK</code>：释放锁。</li></ol><p>文件租用只能在普通文件上发生。非特权（<code>CAP_LEASE</code>）程序只能租用 owner 的 UID 和进程文件系统 UID 匹配的文件。</p><p>手册：</p><blockquote><p>Leases are associated with an open file description (see open(2)). This means that duplicate file descriptors (created by, for example, fork(2) or dup(2)) refer to the same lease, and this lease may be modified or released using any of these descriptors. Furthermore, the lease is released by either an explicit <code>F_UNLCK</code> operation on any of these duplicate file descriptors, or when all such file descriptors have been closed.</p></blockquote><p>租用和打开文件描述相关，这一点和 <code>flock()</code> 相似。</p><h1 id=仅运行一个程序的单个实例>仅运行一个程序的单个实例
<a class=header-anchor href=#%e4%bb%85%e8%bf%90%e8%a1%8c%e4%b8%80%e4%b8%aa%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%8d%95%e4%b8%aa%e5%ae%9e%e4%be%8b></a></h1><p>一般把 xxx.pid 这样的锁放在 /var/run 文件夹下。Daemon 在其执行期间一直持有这个文件锁并在即将终止之前删除这个文件。</p><p>比如，/var/run/syslogd.pid 是由 syslogd 创建的。（测试的 wsl、服务器都没有这个文件，可能没有启用 syslogd 这个功能？）我还在 wsl 上面发现了 /var/run/crond.pid 这个文件。</p><blockquote><p>Debian 上可以安装 rsyslogd，但是我还是没有找到 /var/run/rsyslogd.pid 这个文件。</p></blockquote><p>书上例子用的是 <code>fcntl()</code> 完成加锁（封装在了作者自己实现的 <code>lockRegion()</code> 函数中）。</p><h1 id=老的进程加锁技术>老的进程加锁技术
<a class=header-anchor href=#%e8%80%81%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%8a%a0%e9%94%81%e6%8a%80%e6%9c%af></a></h1><ol><li><code>open(file, O_CREAT | O_EXCL, ...)</code> + <code>unlink(file)</code></li><li><code>link(file, lockfile)</code> + <code>unlink(lockfile)</code></li><li><code>open(file, O_CREAT | O_TRUNC | O_WRONLY, 0)</code> + <code>unlink(file)</code></li></ol><p>前两种方法都是用文件是否存在（当前进程是否为文件的创建者）来表示锁的持有。缺点：</p><ol><li>模拟加锁比调用新系统调用创建 xxx.pid 更慢。</li><li>没有阻塞的机制，失败只能忙等待或者睡眠重试。</li><li>没有死锁检查。</li><li>如果进程意外终止，锁文件不会被删除，从而导致“锁”没有被释放。有一些补救方法，比如在锁文件中记录主人的进程号、检查文件上次修改时间，但是这些方法都不是很可靠。</li></ol><p>第 3 种方法的机制是：无法获得写权限时，含有 <code>O_TRUNC</code> 标志也会使得 <code>open()</code> 失败。文件创建时指定的 <code>mode_t</code> 为 0，所以一旦创建其他进程就不能获得写权限。除了包含以上缺点外，还多了一个特权进程总是会成功的缺点。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/the-linux-programming-interface>the-linux-programming-interface</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/the-linux-programming-interface/54-POSIX-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/ rel=next title="54 POSIX 共享内存"><i class="fa fa-chevron-left"></i> 54 POSIX 共享内存</a></div><div class="post-nav-prev post-nav-item"><a href=/the-linux-programming-interface/50-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/ rel=prev title="50 虚拟内存操作">50 虚拟内存操作
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>