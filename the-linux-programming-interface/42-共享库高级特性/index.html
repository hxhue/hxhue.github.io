<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="42 共享库高级特性"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content="the-linux-programming-interface"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"42-%E5%85%B1%E4%BA%AB%E5%BA%93%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7","permalink":"https://hxhue.github.io/the-linux-programming-interface/42-%E5%85%B1%E4%BA%AB%E5%BA%93%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/","title":"42 共享库高级特性","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>42 共享库高级特性 - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#动态加载库dlopen-api>动态加载库：dlopen API</a><ul><li><a href=#dlopen><code>dlopen()</code></a><ul><li><a href=#filename-参数>filename 参数</a><ul><li><a href=#在全局符号对象中符号的搜索顺序>在全局符号对象中符号的搜索顺序</a></li><li><a href=#解析共享对象中的符号时的搜索顺序>解析共享对象中的符号时的搜索顺序</a></li></ul></li><li><a href=#flags-参数>flags 参数</a></li></ul></li><li><a href=#dlerror><code>dlerror()</code></a></li><li><a href=#dlsym><code>dlsym()</code></a><ul><li><a href=#c99-中使用-dlsym-的问题>C99 中使用 <code>dlsym()</code> 的问题</a></li><li><a href=#伪句柄-rtld_default-和-rtld_next>伪句柄 <code>RTLD_DEFAULT</code> 和 <code>RTLD_NEXT</code></a></li><li><a href=#用-dladdr-获取加载的符号的更多信息>用 <code>dladdr()</code> 获取加载的符号的更多信息</a></li></ul></li></ul></li><li><a href=#在静态链接时导出符号到全局作用域>在静态链接时导出符号到全局作用域</a></li><li><a href=#在代码中控制符号的可见性>在代码中控制符号的可见性</a><ul><li><a href=#补充测试>补充测试</a></li></ul></li><li><a href=#链接器版本脚本version-script>链接器版本脚本（version script）</a><ul><li><a href=#用途一指定符号可见性>用途一：指定符号可见性</a></li><li><a href=#用途二符号版本化>用途二：符号版本化</a><ul><li><a href=#验证书上例子>验证书上例子</a></li><li><a href=#其他补充>其他补充</a></li></ul></li></ul></li><li><a href=#构造函数和析构函数>构造函数和析构函数</a></li><li><a href=#预加载共享库>预加载共享库</a></li><li><a href=#用环境变量调试动态链接器>用环境变量调试动态链接器</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/42-%E5%85%B1%E4%BA%AB%E5%BA%93%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="42 共享库高级特性"><meta itemprop=description content="动态加载库：dlopen API

#include <dlfcn.h>

void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
使用 dlopen API 要给 gcc 传递 -ldl 参数使其链接到 libdl.so。
dlopen()

每个被加载的库会有一个引用计数，一个库被加载时，它依赖的其他库（被称为依赖树）会被自动加载，它们的引用计数增加；卸载时引用计数又会减少，归零时才真正意义上卸载共享库。"></span><header class=post-header><h1 class=post-title itemprop="name headline">42 共享库高级特性</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-07-20 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-07-20 00:00:00 +0800 CST">2024-07-20
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-04-06T00:00:00+08:00 itemprop=dateModified datetime=2025-04-06T00:00:00+08:00>2025-04-06</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>5316</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>11分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=动态加载库dlopen-api>动态加载库：dlopen API
<a class=header-anchor href=#%e5%8a%a8%e6%80%81%e5%8a%a0%e8%bd%bd%e5%ba%93dlopen-api></a></h1><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;dlfcn.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#719e07>*</span><span style=color:#268bd2>dlopen</span>(<span style=color:#719e07>const</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>filename, <span style=color:#dc322f>int</span> flags);
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>dlclose</span>(<span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>handle);
</span></span></code></pre></div><p>使用 dlopen API 要给 gcc 传递 <code>-ldl</code> 参数使其链接到 libdl.so。</p><h2 id=dlopen><code>dlopen()</code>
<a class=header-anchor href=#dlopen></a></h2><p>每个被加载的库会有一个引用计数，一个库被加载时，它依赖的其他库（被称为依赖树）会被自动加载，它们的引用计数增加；卸载时引用计数又会减少，归零时才真正意义上卸载共享库。</p><h3 id=filename-参数>filename 参数
<a class=header-anchor href=#filename-%e5%8f%82%e6%95%b0></a></h3><ul><li>如果 filename 包含 /，那么按照文件路径查找；否则在标准的路径中按照 41 章描述的顺序查找。</li><li>如果 filename 为 <code>NULL</code>，那么返回主程序的句柄，也就是“全局符号对象”（global symbol object）。</li></ul><h4 id=在全局符号对象中符号的搜索顺序><mark>在全局符号对象中符号的搜索顺序</mark>
<a class=header-anchor href=#%e5%9c%a8%e5%85%a8%e5%b1%80%e7%ac%a6%e5%8f%b7%e5%af%b9%e8%b1%a1%e4%b8%ad%e7%ac%a6%e5%8f%b7%e7%9a%84%e6%90%9c%e7%b4%a2%e9%a1%ba%e5%ba%8f></a></h4><p>如果用全局符号对象的句柄作为参数调用 <code>dlsym()</code>，那么会：</p><ol><li>先在主程序中搜索符号</li><li>然后在程序启动时加载的共享库中按顺序搜索</li><li>最后在所有使用了 <code>RTLD_GLOBAL</code> 标志加载的共享库中按顺序搜索。</li></ol><h4 id=解析共享对象中的符号时的搜索顺序><mark>解析共享对象中的符号时的搜索顺序</mark>
<a class=header-anchor href=#%e8%a7%a3%e6%9e%90%e5%85%b1%e4%ba%ab%e5%af%b9%e8%b1%a1%e4%b8%ad%e7%9a%84%e7%ac%a6%e5%8f%b7%e6%97%b6%e7%9a%84%e6%90%9c%e7%b4%a2%e9%a1%ba%e5%ba%8f></a></h4><p>加载时没 <code>RTLD_LAZY</code> 立即解析，有则延后函数解析、立即变量解析。</p><blockquote><p>Symbol references in the shared object are resolved using (in order):（<strong>这一段话来自 man 手册</strong>）</p><ol><li>symbols in the link map of objects <strong>loaded for the main program</strong>（不包括主程序本身！） and its dependencies;</li><li>symbols in shared objects (and their dependencies) that were previously opened with <code>dlopen()</code> using the <code>RTLD_GLOBAL</code> flag;</li><li>and definitions in the shared object itself (and any dependencies that were loaded for that object).</li></ol></blockquote><p>有了这样的解析顺序，想要在不重新链接程序的情况下替换 malloc 的实现为 jemalloc，可以使用 <code>LD_PRELOAD</code> 环境变量（格式和 <code>PATH</code>、<code>LD_LIBRARY_PATH</code> 差不多）指定 jemalloc 共享库的路径（比如 <code>LD_PRELOAD=/path/to/jemalloc.so /bin/ls</code>），这样就能把它作为额外的依赖注入在依赖列表的最前面，找 malloc 的时候会首先找到 jemalloc 中的实现。</p><p>如果不使用环境变量，且要让程序使用 jemalloc 的共享库版本，可以将可执行程序连接到 jemalloc 库。如果命令行中没有显式出现 libc，那么 libc 就是最后被链接的；如果出现了 libc 则要写在对 jemalloc 链接的后面！</p><h3 id=flags-参数>flags 参数
<a class=header-anchor href=#flags-%e5%8f%82%e6%95%b0></a></h3><p>flags 参数可以取以下标志：</p><ul><li><code>RTLD_LAZY</code>：对于函数符号，在代码执行的时候才解析。（变量仍然是加载时就解析。）</li><li><code>RTLD_NOW</code>：在 <code>dlopen()</code> 结束之前就加载库中的符号。如果环境变量 <code>LD_BIND_NOW</code> 是非空字符串，那么会忽略 <code>RTLD_LAZY</code> 标志，始终采用 <code>RTLD_NOW</code> 标志，即环境变量 <code>LD_BIND_NOW</code> 有更高的优先级。</li><li><code>RTLD_GLOBAL</code>：将加载到的符号共享给进程加载的其他库的符号解析过程。</li><li><code>RTLD_LOCAL</code>：和 <code>RTLD_GLOBAL</code> 相反。</li><li><code>RTLD_NODELETE</code>：在引用计数归零的时候不要卸载库。这样卸载库之后再重新加载就不会反复初始化静态变量。（<code>gcc -Wl,-znodelete</code> 对于动态链接器自动加载的库而言有相似的效果。这里用 <code>-Wl,-z,nodelete</code> 是一样的。）</li><li><code>RTLD_NOLOAD</code>：不加载库。作用有两个：1. 检查是否库是否已经加载（没有加载会返回 <code>NULL</code>）；2. 修改已经加载的库的 flags。</li><li><code>RTLD_DEEPBIND</code>：在解析这个库中的符号引用时先搜索库中的定义，然后再搜索已加载的库中的定义，有点类似于创建共享库的时候就把 <code>-Bsymbolic</code> 参数传递给了 <code>ld</code>。</li></ul><h2 id=dlerror><code>dlerror()</code>
<a class=header-anchor href=#dlerror></a></h2><p>如果上一次用 dlopen API 出现了错误，那么 <code>dlerror()</code> 会返回一个描述错误的字符串。如果没有错误 <code>dlerror()</code> 返回 <code>NULL</code>。</p><p>有意调用 <code>dlerror()</code> 并忽略返回值，则可以将已经记录的错误删除（有点类似于将 <code>errno</code> 置 0）。</p><h2 id=dlsym><code>dlsym()</code>
<a class=header-anchor href=#dlsym></a></h2><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;dlfcn.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#719e07>*</span><span style=color:#268bd2>dlsym</span>(<span style=color:#dc322f>void</span> <span style=color:#719e07>*</span><span style=color:#268bd2>restrict</span> handle, <span style=color:#719e07>const</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span><span style=color:#268bd2>restrict</span> symbol);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>#define _GNU_SOURCE
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;dlfcn.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#719e07>*</span><span style=color:#268bd2>dlvsym</span>(<span style=color:#dc322f>void</span> <span style=color:#719e07>*</span><span style=color:#268bd2>restrict</span> handle, <span style=color:#719e07>const</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span><span style=color:#268bd2>restrict</span> symbol,
</span></span><span style=display:flex><span>            <span style=color:#719e07>const</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span><span style=color:#268bd2>restrict</span> version);
</span></span></code></pre></div><p><code>dlsym()</code> 返回的结果是无类型的，需要强制转换才能使用。</p><p>在一些没有错误的情况下，<code>dlsym()</code> 也可能返回 <code>NULL</code>，这和运行出现错误无法通过返回值区分，因此我们在调用 <code>dlsym()</code> 之后要用 <code>dlerror()</code> 来检查错误。</p><p>一个符号地址为 <code>NULL</code> 的正常情况包括：</p><ul><li>symbol 真的就是被放在 0 地址的（这需要专门的链接脚本或 <code>--defsym</code> 命令行选项）。</li><li>未定义的 weak symbol 地址为 NULL。</li><li><mark><em>Finally, the symbol value may be the result of a GNU indirect function (IFUNC) resolver function that returns <code>NULL</code> as the resolved value</em>.</mark></li></ul><p>不过，<code>dlopen()</code> 在前两种情况下会认为出错从而设置 <code>dlerror()</code> 的错误。第三种情况是无错但是返回 NULL 的。</p><h3 id=c99-中使用-dlsym-的问题>C99 中使用 <code>dlsym()</code> 的问题
<a class=header-anchor href=#c99-%e4%b8%ad%e4%bd%bf%e7%94%a8-dlsym-%e7%9a%84%e9%97%ae%e9%a2%98></a></h3><p>在 C99 中，<code>void *</code> 类型不能和函数指针类型互相转换，开启 <code>-pedantic</code> 选项就会给出警告信息：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>warning: ISO C forbids conversion of object pointer to function pointer type [-Wpedantic]
</span></span></code></pre></div><p>C++ 就不会有这种警告。书上给出的解决方案是不转换赋值号右边的类型，而是把赋值号左边的类型转换了：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;dlfcn.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>main</span>(<span style=color:#dc322f>int</span> argc, <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#dc322f>void</span> (<span style=color:#719e07>*</span>funcp)(<span style=color:#dc322f>void</span>);        <span style=color:#586e75>/* Pointer to function with no arguments */</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#719e07>*</span>(<span style=color:#dc322f>void</span> <span style=color:#719e07>**</span>) (<span style=color:#719e07>&amp;</span>funcp) <span style=color:#719e07>=</span> <span style=color:#268bd2>dlsym</span>(libHandle, argv[<span style=color:#2aa198>2</span>]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://stackoverflow.com/a/19487645/ title=https://stackoverflow.com/a/19487645/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://stackoverflow.com/a/19487645/<i class="fa fa-external-link-alt"></i></a> 有相关讨论。</p><p>虽然说也可以用 <code>memcpy()</code> 来复制数据，但是会麻烦一点，因为 <code>memcpy()</code> 有 <code>dest</code> 和 <code>src</code>，其中 <code>dest</code> 是上面的 <code>funcp</code>，而 <code>src</code> 是目标数据的地址。也就是说我们要先把 <code>dlsym()</code> 的返回值存储到一个变量中，再取其地址作为 <code>src</code> 用于复制数据。</p><h3 id=伪句柄-rtld_default-和-rtld_next>伪句柄 <code>RTLD_DEFAULT</code> 和 <code>RTLD_NEXT</code>
<a class=header-anchor href=#%e4%bc%aa%e5%8f%a5%e6%9f%84-rtld_default-%e5%92%8c-rtld_next></a></h3><p>除了使用 <code>dlopen()</code> 返回的指针作为 <code>dlsym()</code> 的句柄参数之外，还可以使用以下伪句柄：</p><ul><li><code>RTLD_DEFAULT</code>：对应于动态链接库采用的默认搜索类型，也相当于先给 <code>dlopen()</code> 传入 <code>NULL</code> 作为 filename 参数得到全局符号对象，然后再拿着这个句柄去搜索。</li><li><code>RTLD_NEXT</code>：找到下一个 symbol。</li></ul><p>实际上 <code>RTLD_DEFAULT</code> 可能和 <code>dlopen(NULL, 0)</code> 相等（在 debian 虚拟机中测试，结果仅代表特定环境）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;dlfcn.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>handle <span style=color:#719e07>=</span> <span style=color:#268bd2>dlopen</span>(<span style=color:#b58900>NULL</span>, <span style=color:#2aa198>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#719e07>if</span> (handle <span style=color:#719e07>==</span> RTLD_DEFAULT) { <span style=color:#268bd2>printf</span>(<span style=color:#2aa198>&#34;equal</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>); }
</span></span><span style=display:flex><span>    <span style=color:#719e07>else</span>                        { <span style=color:#268bd2>printf</span>(<span style=color:#2aa198>&#34;not equal</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>); }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对 <code>RTLD_NEXT</code> 的理解：</p><ul><li>Man 手册中说的是：Find the next occurrence of the desired symbol in the search order <strong>after the current object</strong>.</li><li>TLPI 说的是：Search for symbol in shared libraries loaded after the one invoking <code>dlsym()</code>.</li></ul><p>这个伪句柄限制了从它之后加载的共享库中搜索 symbol（这一段调用 <code>dlsym(RTLD_NEXT, ...)</code> 的代码在于某个 object 中，要按照搜索顺序，从下一个 object 开始搜索同名 symbol），因此可以用来实现包装函数，TLPI 举的例子是 <code>func = dlsym(RTLD_NEXT, "malloc")</code>，GNU ld 的 <code>--wrap</code> 选项应该也是通过类似的原理实现的。</p><p><code>RTLD_NEXT</code> <u>并不能用来迭代目前已知的所有同名 symbols（如果有该多好啊！），只能获得当前共享对象位置后面的第一个符号</u>。需要强制使用特定库中的函数时，则需要先用 <code>dlopen()</code> 打开特定库，然后再将其句柄传给 <code>dlsym()</code>。相关文章： <a href=https://optumsoft.com/dangers-of-using-dlsym-with-rtld_next/ title=https://optumsoft.com/dangers-of-using-dlsym-with-rtld_next/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://optumsoft.com/dangers-of-using-dlsym-with-rtld_next/<i class="fa fa-external-link-alt"></i></a> 。</p><h3 id=用-dladdr-获取加载的符号的更多信息>用 <code>dladdr()</code> 获取加载的符号的更多信息
<a class=header-anchor href=#%e7%94%a8-dladdr-%e8%8e%b7%e5%8f%96%e5%8a%a0%e8%bd%bd%e7%9a%84%e7%ac%a6%e5%8f%b7%e7%9a%84%e6%9b%b4%e5%a4%9a%e4%bf%a1%e6%81%af></a></h3><p>使用 <code>dlsym()</code> 找到符号之后，可以用 <code>dladdr()</code> 获取它的更多信息。有些 UNIX 实现没有提供这个函数。</p><h1 id=在静态链接时导出符号到全局作用域>在静态链接时导出符号到全局作用域
<a class=header-anchor href=#%e5%9c%a8%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e6%97%b6%e5%af%bc%e5%87%ba%e7%ac%a6%e5%8f%b7%e5%88%b0%e5%85%a8%e5%b1%80%e4%bd%9c%e7%94%a8%e5%9f%9f></a></h1><p>有的时候我们希望通过 <code>dlopen()</code> 加载的共享库中的代码反而能够使用主程序中的符号，这个时候我们就需要在链接主程序的时候将符号导出到全局作用域中。这样 <code>dlsym()</code> 才能找到对应的符号。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>gcc -Wl,--export-dynamic main.c
</span></span><span style=display:flex><span><span style=color:#586e75># 或者</span>
</span></span><span style=display:flex><span>gcc -export-dynamic main.c
</span></span></code></pre></div><p>参考 <a href=https://stackoverflow.com/a/36700270/ title=https://stackoverflow.com/a/36700270/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://stackoverflow.com/a/36700270/<i class="fa fa-external-link-alt"></i></a> ，用其中的代码分别在无 <code>-rdynamic</code> 和有 <code>-rdynamic</code> 选项的情况下编译，得到两个文件 prog 和 prog.dyn（为了区分我在名字上加了后缀）。用 <code>readelf -s</code> 去查看两个可执行文件，会发现它们都有 .dynsym 和 .symtab 两张符号表，其中 .symtab 一样长，但是 prog.dyn 的 .dynsym 更长了、增加了 foo / main 等符号（在主函数中定义）。</p><h1 id=在代码中控制符号的可见性>在代码中控制符号的可见性
<a class=header-anchor href=#%e5%9c%a8%e4%bb%a3%e7%a0%81%e4%b8%ad%e6%8e%a7%e5%88%b6%e7%ac%a6%e5%8f%b7%e7%9a%84%e5%8f%af%e8%a7%81%e6%80%a7></a></h1><p>共享库符号默认对外可见，主程序中符号默认对外不可见。</p><p><strong>如果想要控制共享库中符号对外的可见性</strong>，可以使用以下语法：</p><ul><li>单个文件可见：<code>static</code>。</li><li>库中可见，库外不可见：<code>__attribute__ ((visibility("hidden")))</code>，这个是 GNU 扩展语法。</li></ul><p>只要库外不可见，就不用担心暴露过多细节在 ABI 中，既防止了用户依赖实现细节，又避免了不重要的符号和后加载的共享库中的公开符号重名、导致其无法被正确绑定（会绑定到第一个）。</p><p>此外，如果有以上的可见性说明，在编译共享库的时候见到这样的符号就会立即绑定，就好像只对特定的符号开启了链接器的 <code>-Bsymbolic</code> 选项一样。</p><h2 id=补充测试>补充测试
<a class=header-anchor href=#%e8%a1%a5%e5%85%85%e6%b5%8b%e8%af%95></a></h2><p>先创建 foo.c，其中只定义一个变量 <code>int foo = 42;</code>。然后编译成目标文件，发现 foo 这个符号并不存在于 .dynsym 当中。（不仅如此，整个 .dynsym section 都不存在！）但是将目标文件链接成共享库之后 foo 这个符号就出现在 .dynsym 当中了。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>eric@debian:~/attr$ <span style=color:#b58900>echo</span> <span style=color:#2aa198>&#34;int foo = 42;&#34;</span> &gt; foo.c
</span></span><span style=display:flex><span>eric@debian:~/attr$ gcc -fPIC -c -o foo.o foo.c
</span></span><span style=display:flex><span>eric@debian:~/attr$ readelf -sD foo.o
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Dynamic symbol information is not available <span style=color:#719e07>for</span> displaying symbols.
</span></span><span style=display:flex><span>eric@debian:~/attr$ gcc -fPIC -shared -o libfoo.so foo.o
</span></span><span style=display:flex><span>eric@debian:~/attr$ readelf -sD libfoo.so
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Symbol table <span style=color:#719e07>for</span> image contains <span style=color:#2aa198>6</span> entries:
</span></span><span style=display:flex><span>   Num:    Value          Size Type    Bind   Vis      Ndx Name
</span></span><span style=display:flex><span>     0: <span style=color:#2aa198>0000000000000000</span>     <span style=color:#2aa198>0</span> NOTYPE  LOCAL  DEFAULT  UND
</span></span><span style=display:flex><span>     1: <span style=color:#2aa198>0000000000000000</span>     <span style=color:#2aa198>0</span> NOTYPE  WEAK   DEFAULT  UND __cxa_finalize
</span></span><span style=display:flex><span>     2: <span style=color:#2aa198>0000000000000000</span>     <span style=color:#2aa198>0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC<span style=color:#719e07>[</span>...<span style=color:#719e07>]</span>
</span></span><span style=display:flex><span>     3: <span style=color:#2aa198>0000000000000000</span>     <span style=color:#2aa198>0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT<span style=color:#719e07>[</span>...<span style=color:#719e07>]</span>
</span></span><span style=display:flex><span>     4: <span style=color:#2aa198>0000000000000000</span>     <span style=color:#2aa198>0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__
</span></span><span style=display:flex><span>     5: <span style=color:#2aa198>0000000000004008</span>     <span style=color:#2aa198>4</span> OBJECT  GLOBAL DEFAULT   <span style=color:#2aa198>17</span> foo
</span></span></code></pre></div><p>在生成目标文件时指定 <code>-Wl,--export-dynamic</code> 也是没有效果的，因为 <code>-Wl,--export-dynamic</code> 只在链接的时候起作用：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>eric@debian:~/attr$ gcc -fPIC -Wl,--export-dynamic -c -o foo.o foo.c
</span></span><span style=display:flex><span>eric@debian:~/attr$ readelf -sD foo.o
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Dynamic symbol information is not available <span style=color:#719e07>for</span> displaying symbols.
</span></span></code></pre></div><p>观察：将符号从 .symtab 导出到 .dynsym 的过程是在链接过程中做的，在生成目标文件的时候不会处理 .dynsym。生成共享库的时候符号默认会被导出，生成可执行文件时符号默认不被导出。静态库只是对目标文件的打包而已，应该也不涉及 .dynsym。</p><h1 id=链接器版本脚本version-script>链接器版本脚本（version script）
<a class=header-anchor href=#%e9%93%be%e6%8e%a5%e5%99%a8%e7%89%88%e6%9c%ac%e8%84%9a%e6%9c%acversion-script></a></h1><h2 id=用途一指定符号可见性>用途一：指定符号可见性
<a class=header-anchor href=#%e7%94%a8%e9%80%94%e4%b8%80%e6%8c%87%e5%ae%9a%e7%ac%a6%e5%8f%b7%e5%8f%af%e8%a7%81%e6%80%a7></a></h2><p>在链接成共享库的时候使用版本脚本：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span>gcc <span style=color:#719e07>-</span>Wl,<span style=color:#719e07>--</span>version<span style=color:#719e07>-</span>script,myscriptfile.map ...
</span></span></code></pre></div><p>在生成共享库的目标文件（没有链接过程）、或者链接成可执行程序时不需要使用版本脚本。</p><p>版本脚本一般用 .map 结尾。举例：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>VER_1 {
</span></span><span style=display:flex><span>    global:
</span></span><span style=display:flex><span>        vis_f1;
</span></span><span style=display:flex><span>        vis_f2;
</span></span><span style=display:flex><span>    local:
</span></span><span style=display:flex><span>        *;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这个版本脚本规定了 vis_f1 和 vis_f2 这两个符号对库外可见，而其他符号对库外不可见。<u>这是链接器版本脚本的第一个用途：指定符号的可见性</u>。</p><h2 id=用途二符号版本化>用途二：符号版本化
<a class=header-anchor href=#%e7%94%a8%e9%80%94%e4%ba%8c%e7%ac%a6%e5%8f%b7%e7%89%88%e6%9c%ac%e5%8c%96></a></h2><p>旧的版本脚本为：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>VER_1 {
</span></span><span style=display:flex><span>        global: xyz;
</span></span><span style=display:flex><span>        local:  *;      # Hide all other symbols
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>旧的共享库代码为：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>xyz</span>(<span style=color:#dc322f>void</span>) { <span style=color:#268bd2>printf</span>(<span style=color:#2aa198>&#34;v1 xyz</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>); }
</span></span></code></pre></div><p>假设已经有可执行程序 A 链接到了这个（特定版本的）库。</p><p><u>维护多版本的库可以使用 soname</u>：接下来如果想要更新库，且库的 ABI 不兼容旧库，那么按照前一章的内容，可以创建一个具有不同主要版本号的共享库并安装，这样系统中会同时存在新库和老库。<strong>还要保证可执行程序 A 之前就是用 soname 链接的，以便它仍然能找到旧版本的共享库进行加载</strong>，新程序也能开始使用新版本的库。</p><p><u>另外一种维护共享库多版本的做法是使用版本脚本和符号版本化技术</u>：在同一个库中同时提供新老代码，用汇编代码指定符号版本，然后用版本脚本来控制新增部分的可见性。</p><p>新的库代码：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#268bd2>__asm__</span>(<span style=color:#2aa198>&#34;.symver xyz_old,xyz@VER_1&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#268bd2>__asm__</span>(<span style=color:#2aa198>&#34;.symver xyz_new,xyz@@VER_2&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>xyz_old</span>(<span style=color:#dc322f>void</span>) { <span style=color:#268bd2>printf</span>(<span style=color:#2aa198>&#34;v1 xyz</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>xyz_new</span>(<span style=color:#dc322f>void</span>) { <span style=color:#268bd2>printf</span>(<span style=color:#2aa198>&#34;v2 xyz</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>pqr</span>(<span style=color:#dc322f>void</span>) { <span style=color:#268bd2>printf</span>(<span style=color:#2aa198>&#34;v2 pqr</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>); }
</span></span></code></pre></div><p>现在新增了函数 <code>pqr()</code>。<code>xyz()</code> 函数被分成了 <code>xyz_old()</code> 和 <code>xyz_new()</code> 两个版本，并通过汇编指定到了不同的版本。<code>@</code> 后面就跟着一个版本标签，这个版本标签和版本脚本对应，其关联符号的可见性受到对应版本的规则约束。<code>@@</code> 表示默认版本，同一个符号只能有一个带 <code>@@</code> 标签的版本。</p><p>新的版本脚本：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>VER_1 {
</span></span><span style=display:flex><span>        global: xyz;
</span></span><span style=display:flex><span>        local:  *;      # Hide all other symbols 
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>VER_2 {
</span></span><span style=display:flex><span>        global: pqr;
</span></span><span style=display:flex><span>} VER_1;
</span></span></code></pre></div><p><code>VER_2 { global: pqr; } VER_1;</code> 表示 VER_2 依赖 VER_1，其中的符号可见性规则也会继承过来。版本并不是一定要用 VER_ 开头命名，只要易读即可，例如 glibc 会使用 GLIBC_2.0、GLIBC_2.1 的版本名。</p><p>如果可执行文件 A 之前就是使用版本脚本进行链接的，那么它需要的符号就会被做上 VER_1 的标记（很显然，旧的版本脚本只有 VER_1 这一个版本，所以无需特别指定就能确定版本）。现在更新共享库之后，共享库同时带有新老代码，A 依然能够找到正确的符号，因为它就是根据 VER_1 来找的。新的程序自然能够链接到 VER_2 版本的 <code>xyz</code>。</p><p>因此，<u>符号版本化也可以替代 soname 作为共享库迭代升级的管理方式</u>。（<mark>此时要固定使用同一个 soname</mark>，因为动态链接器还是按照 soname 来找库的。）<strong>Glibc 从 2.1 版本开始就使用了符号版本化技术，glibc 2.0 以及之后的版本都通过单个主要库版本（libc.so.6）来支持</strong>（← soname 也固定了），<del>因而 glibc 有着非常好的兼容性</del>（我看未必，经常遇到依赖问题）。</p><p>在我最近编译出来的程序中，可以看到标准库函数有不同的符号版本：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>eric@debian:~/rdynamic$ readelf -s prog | grep @GLIBC | awk <span style=color:#2aa198>&#39;/[a-z]+@/ { print $8 }&#39;</span> | sort -u
</span></span><span style=display:flex><span>dlerror@GLIBC_2.34
</span></span><span style=display:flex><span>dlopen@GLIBC_2.34
</span></span><span style=display:flex><span>dlsym@GLIBC_2.34
</span></span><span style=display:flex><span>exit@GLIBC_2.2.5
</span></span><span style=display:flex><span>fprintf@GLIBC_2.2.5
</span></span><span style=display:flex><span>puts@GLIBC_2.2.5
</span></span><span style=display:flex><span>stderr@GLIBC_2.2.5
</span></span></code></pre></div><div class="markdown-alert markdown-alert-note"><p class=markdown-alert-title><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>Note</p><p>C++ 有 name mangling，如果做符号版本化就得使用名字重整之后的符号名，可能会有比较棘手的问题。我记得 PyTorch 源码中有个文件就包含了大量的重整后符号名。</p></div><h3 id=验证书上例子>验证书上例子
<a class=header-anchor href=#%e9%aa%8c%e8%af%81%e4%b9%a6%e4%b8%8a%e4%be%8b%e5%ad%90></a></h3><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>eric@debian:~/symver$ gcc -fPIC -shared -o libxyz.so xyz.c -Wl,--version-script,v1.map
</span></span><span style=display:flex><span>eric@debian:~/symver$ gcc -fPIC -o prog1 main.c libxyz.so
</span></span><span style=display:flex><span>eric@debian:~/symver$ <span style=color:#268bd2>LD_LIBRARY_PATH</span><span style=color:#719e07>=</span>. ./prog1
</span></span><span style=display:flex><span>v1 xyz
</span></span><span style=display:flex><span>eric@debian:~/symver$ gcc -fPIC -shared -o libxyz.so xyz2.c -Wl,--version-script,v2.map <span style=color:#586e75># 覆盖更新旧的共享库</span>
</span></span><span style=display:flex><span>eric@debian:~/symver$ gcc -fPIC -o prog2 main.c libxyz2.so
</span></span><span style=display:flex><span>eric@debian:~/symver$ <span style=color:#268bd2>LD_LIBRARY_PATH</span><span style=color:#719e07>=</span>. ./prog2
</span></span><span style=display:flex><span>v2 xyz
</span></span><span style=display:flex><span>eric@debian:~/symver$ <span style=color:#268bd2>LD_LIBRARY_PATH</span><span style=color:#719e07>=</span>. ./prog1 <span style=color:#586e75># 旧的可执行文件依然能运行</span>
</span></span><span style=display:flex><span>v1 xyz
</span></span><span style=display:flex><span>eric@debian:~/symver$ objdump -t prog1 | grep xyz
</span></span><span style=display:flex><span><span style=color:#2aa198>0000000000000000</span>       F *UND*  <span style=color:#2aa198>0000000000000000</span>              xyz@VER_1
</span></span><span style=display:flex><span>eric@debian:~/symver$ objdump -t prog2 | grep xyz
</span></span><span style=display:flex><span><span style=color:#2aa198>0000000000000000</span>       F *UND*  <span style=color:#2aa198>0000000000000000</span>              xyz@VER_2
</span></span></code></pre></div><p>可以发现两个可执行文件中使用的符号是带有版本号标记的。</p><h3 id=其他补充>其他补充
<a class=header-anchor href=#%e5%85%b6%e4%bb%96%e8%a1%a5%e5%85%85></a></h3><p>在代码中实现符号版本化除了用 .symver 汇编之外，还可以用 GNU 的 <a href=https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-symver-function-attribute title=函数属性 rel="noopener external nofollow noreferrer" target=_blank class=exturl>函数属性<i class="fa fa-external-link-alt"></i></a>：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#268bd2>__attribute__</span> ((<span style=color:#268bd2>__symver__</span> (<span style=color:#2aa198>&#34;foo@VERS_1&#34;</span>)))
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>foo_v1</span> (<span style=color:#dc322f>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>/* 需要 binutils 2.35 以上 */</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>__attribute__</span> ((<span style=color:#268bd2>__symver__</span> (<span style=color:#2aa198>&#34;foo@VERS_2&#34;</span>), <span style=color:#268bd2>__symver__</span> (<span style=color:#2aa198>&#34;foo@VERS_3&#34;</span>)))
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>symver_foo_v1</span> (<span style=color:#dc322f>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=构造函数和析构函数>构造函数和析构函数
<a class=header-anchor href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%92%8c%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0></a></h1><p>参考 <a href=https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-constructor-function-attribute title="GCC 文档" rel="noopener external nofollow noreferrer" target=_blank class=exturl>GCC 文档<i class="fa fa-external-link-alt"></i></a>：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>constructor
</span></span><span style=display:flex><span>destructor
</span></span><span style=display:flex><span>constructor (priority)
</span></span><span style=display:flex><span>destructor (priority)
</span></span></code></pre></div><p>其中 priority 的 0-100 范围是被预留的，<strong>我们能用的范围是 101 到 65535</strong>。<strong>构造函数能够在共享库载入时完成初始化工作、析构函数在共享库卸载时完成清理工作</strong>。这和 C++ 静态变量的初始化和析构是同样的过程：在主程序中静态变量先于 <code>main()</code> 函数被初始化，在 <code>main()</code> 函数退出之后才析构。</p><p>用来实现共享库初始化和析构的较早技术是 <code>void _init(void)</code> 和 <code>void _fini(void)</code> 函数，如果要使用自己创建的这两个函数，需要使用 <code>gcc -nostartfiles</code> 选项以防止链接器加入这些函数的默认实现。也可以使用 <code>–Wl,–init</code> 和 <code>–Wl,–fini</code> 选项来指定函数的名称。</p><p>有了 constructor 和 destructor 特性之后应该避免使用老的 <code>void _init(void)</code> 和 <code>void _fini(void)</code> 函数。</p><h1 id=预加载共享库>预加载共享库
<a class=header-anchor href=#%e9%a2%84%e5%8a%a0%e8%bd%bd%e5%85%b1%e4%ba%ab%e5%ba%93></a></h1><p>环境变量 <code>LD_PRELOAD</code> 可以用来指定空格或冒号分割的、共享库的列表。这些共享库不仅是额外加载对象，而且在程序进入时先于其他共享库被加载。</p><p>和 <code>LD_LIBRARY_PATH</code> 的区别：<code>LD_PRELOAD</code> 用来强制加载具体的库（添加依赖），<code>LD_LIBRARY_PATH</code> 则是提供了搜索库的额外路径。</p><p><u>在系统层面上控制预加载共享库可以使用 /etc/ld.so.preload 文件来完成</u>。在我的测试环境中这个文件不存在。（应该是表示不会预加载任何共享库？）</p><p>处于安全原因，set-user/group-ID 程序禁用了环境变量 <code>LD_PRELOAD</code>。</p><h1 id=用环境变量调试动态链接器>用环境变量调试动态链接器
<a class=header-anchor href=#%e7%94%a8%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e8%b0%83%e8%af%95%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e5%99%a8></a></h1><p>用 <code>LD_DEBUG=help date</code> 就会输出帮助信息，并不会执行程序！</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>eric@debian:~/attr$ <span style=color:#268bd2>LD_DEBUG</span><span style=color:#719e07>=</span><span style=color:#b58900>help</span> date
</span></span><span style=display:flex><span>Valid options <span style=color:#719e07>for</span> the LD_DEBUG environment variable are:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  libs        display library search paths
</span></span><span style=display:flex><span>  reloc       display relocation processing
</span></span><span style=display:flex><span>  files       display progress <span style=color:#719e07>for</span> input file
</span></span><span style=display:flex><span>  symbols     display symbol table processing
</span></span><span style=display:flex><span>  bindings    display information about symbol binding
</span></span><span style=display:flex><span>  versions    display version dependencies
</span></span><span style=display:flex><span>  scopes      display scope information
</span></span><span style=display:flex><span>  all         all previous options combined
</span></span><span style=display:flex><span>  statistics  display relocation statistics
</span></span><span style=display:flex><span>  unused      determined unused DSOs
</span></span><span style=display:flex><span>  <span style=color:#b58900>help</span>        display this <span style=color:#b58900>help</span> message and <span style=color:#b58900>exit</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>To direct the debugging output into a file instead of standard output
</span></span><span style=display:flex><span>a filename can be specified using the LD_DEBUG_OUTPUT environment variable.
</span></span></code></pre></div><p>有了帮助信息之后我们可以选一些来执行，比如：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>eric@debian:~/attr$ <span style=color:#268bd2>LD_DEBUG</span><span style=color:#719e07>=</span>libs date
</span></span><span style=display:flex><span>      8403:     find <span style=color:#268bd2>library</span><span style=color:#719e07>=</span>libc.so.6 <span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>; searching
</span></span><span style=display:flex><span>      8403:      search <span style=color:#268bd2>cache</span><span style=color:#719e07>=</span>/etc/ld.so.cache
</span></span><span style=display:flex><span>      8403:       trying <span style=color:#268bd2>file</span><span style=color:#719e07>=</span>/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>      8403:
</span></span><span style=display:flex><span>      8403:
</span></span><span style=display:flex><span>      8403:     calling init: /lib64/ld-linux-x86-64.so.2
</span></span><span style=display:flex><span>      8403:
</span></span><span style=display:flex><span>      8403:
</span></span><span style=display:flex><span>      8403:     calling init: /lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>      8403:
</span></span><span style=display:flex><span>      8403:
</span></span><span style=display:flex><span>      8403:     initialize program: date
</span></span><span style=display:flex><span>      8403:
</span></span><span style=display:flex><span>      8403:
</span></span><span style=display:flex><span>      8403:     transferring control: date
</span></span><span style=display:flex><span>      8403:
</span></span><span style=display:flex><span>Monday, July 22, <span style=color:#2aa198>2024</span> PM03:57:52 HKT
</span></span></code></pre></div><p>可以同时使用多个选项：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>eric@debian:~/attr$ <span style=color:#268bd2>LD_DEBUG</span><span style=color:#719e07>=</span>statistics,libs date
</span></span><span style=display:flex><span>      8420:     find <span style=color:#268bd2>library</span><span style=color:#719e07>=</span>libc.so.6 <span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>; searching
</span></span><span style=display:flex><span>      8420:      search <span style=color:#268bd2>cache</span><span style=color:#719e07>=</span>/etc/ld.so.cache
</span></span><span style=display:flex><span>      8420:       trying <span style=color:#268bd2>file</span><span style=color:#719e07>=</span>/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>      8420:
</span></span><span style=display:flex><span>      8420:
</span></span><span style=display:flex><span>      8420:     runtime linker statistics:
</span></span><span style=display:flex><span>      8420:       total startup <span style=color:#b58900>time</span> in dynamic loader: <span style=color:#2aa198>382413</span> cycles
</span></span><span style=display:flex><span>      8420:                 <span style=color:#b58900>time</span> needed <span style=color:#719e07>for</span> relocation: <span style=color:#2aa198>27469</span> cycles <span style=color:#719e07>(</span>7.1%<span style=color:#719e07>)</span>
</span></span><span style=display:flex><span>      8420:                      number of relocations: <span style=color:#2aa198>93</span>
</span></span><span style=display:flex><span>      8420:           number of relocations from cache: <span style=color:#2aa198>7</span>
</span></span><span style=display:flex><span>      8420:             number of relative relocations: <span style=color:#2aa198>171</span>
</span></span><span style=display:flex><span>      8420:                <span style=color:#b58900>time</span> needed to load objects: <span style=color:#2aa198>67369</span> cycles <span style=color:#719e07>(</span>17.6%<span style=color:#719e07>)</span>
</span></span><span style=display:flex><span>      8420:
</span></span><span style=display:flex><span>      8420:     calling init: /lib64/ld-linux-x86-64.so.2
</span></span><span style=display:flex><span>      8420:
</span></span><span style=display:flex><span>      8420:
</span></span><span style=display:flex><span>      8420:     calling init: /lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>      8420:
</span></span><span style=display:flex><span>      8420:
</span></span><span style=display:flex><span>      8420:     initialize program: date
</span></span><span style=display:flex><span>      8420:
</span></span><span style=display:flex><span>      8420:
</span></span><span style=display:flex><span>      8420:     transferring control: date
</span></span><span style=display:flex><span>      8420:
</span></span><span style=display:flex><span>Monday, July 22, <span style=color:#2aa198>2024</span> PM04:00:26 HKT
</span></span></code></pre></div><p>这个环境变量不仅对可执行文件中链接的共享库有效，对 <code>dlopen()</code> 打开的共享库也有效。出于安全考虑，set-user/group-ID 程序（在 glibc 2.2.5 起）会忽略环境变量 <code>LD_DEBUG</code>。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/the-linux-programming-interface>the-linux-programming-interface</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/the-linux-programming-interface/42.1-%E5%87%A0%E4%B8%AA%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F/ rel=next title="42.1 几个搜索顺序"><i class="fa fa-chevron-left"></i> 42.1 几个搜索顺序</a></div><div class="post-nav-prev post-nav-item"><a href=/the-linux-programming-interface/40-%E7%99%BB%E5%BD%95%E8%AE%B0%E8%B4%A6/ rel=prev title="40 登录记账">40 登录记账
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>