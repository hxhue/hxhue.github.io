<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="The-Linux-Programming-Interfaces"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":false,"path":"the-linux-programming-interface","permalink":"https://hxhue.github.io/the-linux-programming-interface/","title":"The-Linux-Programming-Interfaces","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>the-linux-programming-interface - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/53-POSIX-%E4%BF%A1%E5%8F%B7%E9%87%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="53 POSIX 信号量"><meta itemprop=description content="大概特点

POSIX 信号量有两种：命名信号量和匿名信号量，前者和 System V 信号量比较相似（System V 的 IPC 都用 key 来标识，因此相当于是命名的）。
POSIX 信号量使用了 futex(2) 来实现，在没有争抢的情况下，不会发生系统调用，因此效率比 System V 实现更高。在争抢频繁的情况下，两者性能差不多。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/the-linux-programming-interface/53-POSIX-%E4%BF%A1%E5%8F%B7%E9%87%8F/ itemprop=url class=post-title-link>53 POSIX 信号量</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-05 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-05 00:00:00 +0800 CST">2024-08-05
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-09-07T00:00:00+08:00 itemprop=dateModified datetime=2024-09-07T00:00:00+08:00>2024-09-07</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=大概特点>大概特点
<a class=header-anchor href=#%e5%a4%a7%e6%a6%82%e7%89%b9%e7%82%b9></a></h1><p>POSIX 信号量有两种：命名信号量和匿名信号量，前者和 System V 信号量比较相似（System V 的 IPC 都用 key 来标识，因此相当于是命名的）。</p><p>POSIX 信号量使用了 futex(2) 来实现，在没有争抢的情况下，不会发生系统调用，因此效率比 System V 实现更高。在争抢频繁的情况下，两者性能差不多。</p><p>和 POSIX 消息队列类似，Linux 上的 POSIX 信号量被挂载在 /dev/shm 目录这个 tmpfs 文件系统下。该文件系统具有内和持久性。</p><p>（二元）信号量和 pthreads mutex 相比：</p><ol><li>前者是异步信号安全的，后者不是。但是处理信号还是建议用 <code>sigwaitinfo()</code>。</li><li>前者可以由任何线程释放资源（<code>sem_post()</code>），后者只能由锁的持有者释放，否则是未定义行为。</li></ol></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/the-linux-programming-interface/53-POSIX-%E4%BF%A1%E5%8F%B7%E9%87%8F/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/54-POSIX-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="54 POSIX 共享内存"><meta itemprop=description content="POSIX 共享内存对应虚拟文件系统 /dev/shm，这是一个 tmpfs 文件系统，具有内核持久性。如果不满意默认的大小（书上说默认大小是 256M，但是我测试默认大小是内存的一半——在服务器、虚拟机、wsl 上都是这样；docker 容器共享内存的默认大小则是 64M），可以使用 mount -o remount,size=<num_bytes> ... 重新挂载。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/the-linux-programming-interface/54-POSIX-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/ itemprop=url class=post-title-link>54 POSIX 共享内存</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-05 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-05 00:00:00 +0800 CST">2024-08-05
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-09-07T00:00:00+08:00 itemprop=dateModified datetime=2024-09-07T00:00:00+08:00>2024-09-07</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>POSIX 共享内存对应虚拟文件系统 /dev/shm，这是一个 tmpfs 文件系统，具有内核持久性。如果不满意默认的大小（书上说默认大小是 256M，但是我测试默认大小是内存的一半——在服务器、虚拟机、wsl 上都是这样；docker 容器共享内存的默认大小则是 64M），可以使用 <code>mount -o remount,size=&lt;num_bytes> ...</code> 重新挂载。</p><blockquote><p>回忆：PyTorch 的 dataloader 经常需要共享内存，因此创建的跑 PyTorch 程序的容器需要设置更大一点的共享内存限制。</p></blockquote><p>POSIX 共享内存的使用方式很像一个文件，可以用 <code>shm_open()</code> 打开或者创建，用 <code>shm_unlink()</code> 来删除。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span>SYNOPSIS
</span></span><span style=display:flex><span>       <span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/mman.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>       <span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/stat.h&gt;        /* For mode constants */</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>       <span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;fcntl.h&gt;           /* For O_* constants */</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span>       <span style=color:#dc322f>int</span> <span style=color:#268bd2>shm_open</span>(<span style=color:#719e07>const</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>name, <span style=color:#dc322f>int</span> oflag, <span style=color:#dc322f>mode_t</span> mode);
</span></span><span style=display:flex><span>       <span style=color:#dc322f>int</span> <span style=color:#268bd2>shm_unlink</span>(<span style=color:#719e07>const</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>name);
</span></span></code></pre></div><p>POSIX 共享内存对象要和 <code>mmap()</code> 一起用：先打开一个共享内存对象，然后将其文件描述符映射到内存的某处。这个时候 <code>shm_open()</code> 和 <code>mmap()</code> 的关系很像 <code>shmget()</code> 和 <code>shmat()</code> 的关系。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/the-linux-programming-interface/54-POSIX-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/55-%E6%96%87%E4%BB%B6%E9%94%81flock-%E5%92%8C-fcntl-%E5%8A%A0%E9%94%81/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="55 文件锁：flock() 和 fcntl() 加锁"><meta itemprop=description content="要点

Linux 提供了两种文件加锁系统调用：从 BSD 衍生出来的 flock() 和从 System V 衍生出来的 fcntl()。尽管这两组系统调用在大多数 UNIX 实现上都是可用的，但只有 fcntl() 加锁在 SUSv3 中进行了标准化。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/the-linux-programming-interface/55-%E6%96%87%E4%BB%B6%E9%94%81flock-%E5%92%8C-fcntl-%E5%8A%A0%E9%94%81/ itemprop=url class=post-title-link>55 文件锁：flock() 和 fcntl() 加锁</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-05 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-05 00:00:00 +0800 CST">2024-08-05
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-09-07T00:00:00+08:00 itemprop=dateModified datetime=2024-09-07T00:00:00+08:00>2024-09-07</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=要点>要点
<a class=header-anchor href=#%e8%a6%81%e7%82%b9></a></h1><p>Linux 提供了两种文件加锁系统调用：从 BSD 衍生出来的 <code>flock()</code> 和从 System V 衍生出来的 <code>fcntl()</code>。尽管这两组系统调用在大多数 UNIX 实现上都是可用的，但只有 fcntl() 加锁在 SUSv3 中进行了标准化。</p><p>要理解 <code>flock()</code> 和 <code>fcntl()</code> 的锁分别和什么东西有关联，才能理解什么行为会导致锁的意外释放。“锁和什么有关联”意思就是以什么来标识锁的主人。而锁的对象则分别是整个文件（<code>flock()</code>）和指定区域（<code>fcntl()</code>）。锁是要放在锁的对象上的，所以锁链表在打开文件上记录。</p><h1 id=flock-对整个文件加锁><code>flock()</code> 对整个文件加锁
<a class=header-anchor href=#flock-%e5%af%b9%e6%95%b4%e4%b8%aa%e6%96%87%e4%bb%b6%e5%8a%a0%e9%94%81></a></h1><p>从 BSD 衍生而来。加的是劝告锁（advisory locking）。</p><p>flock(2)：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span>SYNOPSIS
</span></span><span style=display:flex><span>       <span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/file.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span>       <span style=color:#dc322f>int</span> <span style=color:#268bd2>flock</span>(<span style=color:#dc322f>int</span> fd, <span style=color:#dc322f>int</span> operation);
</span></span></code></pre></div></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/the-linux-programming-interface/55-%E6%96%87%E4%BB%B6%E9%94%81flock-%E5%92%8C-fcntl-%E5%8A%A0%E9%94%81/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/50-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="50 虚拟内存操作"><meta itemprop=description content="
  本章介绍在进程的虚拟地址空间上执行操作的各个系统调用。

mprotect() 系统调用修改一块虚拟内存区域上的保护信息。
mlock() 和 mlockall() 系统调用将一块虚拟内存区域锁进物理内存，从而防止它被交换出去。
mincore() 系统调用让一个进程能够确定一块虚拟内存区域中的分页是否驻留在物理内存中。
madvise() 系统调用让一个进程能够将其对虚拟内存区域的使用模式报告给内核。

mprotect()

同 mmap() 的 prot 参数。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/the-linux-programming-interface/50-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/ itemprop=url class=post-title-link>50 虚拟内存操作</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-04 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-04 00:00:00 +0800 CST">2024-08-04
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-09-07T00:00:00+08:00 itemprop=dateModified datetime=2024-09-07T00:00:00+08:00>2024-09-07</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><blockquote><p>本章介绍在进程的虚拟地址空间上执行操作的各个系统调用。</p><ol><li><code>mprotect()</code> 系统调用修改一块虚拟内存区域上的保护信息。</li><li><code>mlock()</code> 和 <code>mlockall()</code> 系统调用将一块虚拟内存区域锁进物理内存，从而防止它被交换出去。</li><li><code>mincore()</code> 系统调用让一个进程能够确定一块虚拟内存区域中的分页是否驻留在物理内存中。</li><li><code>madvise()</code> 系统调用让一个进程能够将其对虚拟内存区域的使用模式报告给内核。</li></ol></blockquote><h1 id=mprotect><code>mprotect()</code>
<a class=header-anchor href=#mprotect></a></h1><p>同 <code>mmap()</code> 的 <code>prot</code> 参数。</p><h1 id=mlock><code>mlock()</code>
<a class=header-anchor href=#mlock></a></h1><p>可能是为了速度，也可能是为了防止敏感信息写入磁盘（这样恶意程序没办法从磁盘中读取内容）。</p><blockquote><p>一些电脑的休眠模式会在磁盘上存储当前系统运行状态的副本，不管页面有没有被锁定。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span>SYNOPSIS
</span></span><span style=display:flex><span>       <span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/mman.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span>       <span style=color:#dc322f>int</span> <span style=color:#268bd2>mlock</span>(<span style=color:#719e07>const</span> <span style=color:#dc322f>void</span> addr[.len], <span style=color:#dc322f>size_t</span> len);
</span></span><span style=display:flex><span>       <span style=color:#dc322f>int</span> <span style=color:#268bd2>mlock2</span>(<span style=color:#719e07>const</span> <span style=color:#dc322f>void</span> addr[.len], <span style=color:#dc322f>size_t</span> len, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> flags);
</span></span><span style=display:flex><span>       <span style=color:#dc322f>int</span> <span style=color:#268bd2>munlock</span>(<span style=color:#719e07>const</span> <span style=color:#dc322f>void</span> addr[.len], <span style=color:#dc322f>size_t</span> len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#dc322f>int</span> <span style=color:#268bd2>mlockall</span>(<span style=color:#dc322f>int</span> flags);
</span></span><span style=display:flex><span>       <span style=color:#dc322f>int</span> <span style=color:#268bd2>munlockall</span>(<span style=color:#dc322f>void</span>);
</span></span></code></pre></div></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/the-linux-programming-interface/50-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/51-POSIX-IPC-%E4%BB%8B%E7%BB%8D/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="51 POSIX IPC 介绍"><meta itemprop=description content="总体来说，POSIX IPC 的接口比 System V IPC 更简单，而且使用方式也更贴近文件。

POSIX IPC 对象名字需要是类似于 /myobject 的、以斜线开头后面跟非斜线字符的字符串。字符串长度受到 NAME_MAX 限制（255 个字符）。信号量的名字还要少 4 个，因为会增加前缀 sem.。如果不以 / 开头，则是实现定义。IPC 对象名字很像一个根目录下的文件的绝对路径，在有些实现上，IPC 对象真的被放在文件系统上。
创建和打开 IPC 对象很像创建或打开文件。
POSIX IPC 对象有引用计数，进程退出或者关闭 IPC 对象后引用计数就会减少。进程调用 exec() 后 POSIX IPC 对象也会被关闭（很像文件有 close-on-exec 标记）。{mq,sem,shm}_unlink() 可以用来删除 POSIX IPC 对象，已经打开了 IPC 对象的进程仍能继续使用它们。而 System V 的删除（除了共享内存）是立即生效的，进程的后续访问会出错。
持久性：和 System V IPC 一样，POSIX IPC 对象也有内核持久性（如果不显式删除，将会持续到系统关机）。
IPC 对象管理：System V IPC 可以用 ipcs 来列出 IPC 对象，用 ipcrm 来删除 IPC 对象。POSIX IPC 没有这样标准化的命令。Linux 上的 POSIX IPC 对象被挂载在虚拟文件系统上，其所在目录有粘滞位，可以用 ls(1) 和 rm(1) 这样的标准命令来操作 Linux 的 POSIX IPC 对象。
System V IPC 更古老，可移植性更强。
System V IPC 用 key 来访问，本质都是命名的；POSIX 信号量可以匿名也可以命名；POSIX 用 shm_open 创建共享内存是命名的，但用 mmap 也可以创建匿名共享内存（mmap 也是 POSIX 标准）；POSIX 消息队列是命名的。
"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/the-linux-programming-interface/51-POSIX-IPC-%E4%BB%8B%E7%BB%8D/ itemprop=url class=post-title-link>51 POSIX IPC 介绍</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-04 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-04 00:00:00 +0800 CST">2024-08-04
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-03-08T00:00:00+08:00 itemprop=dateModified datetime=2025-03-08T00:00:00+08:00>2025-03-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>总体来说，POSIX IPC 的接口比 System V IPC 更简单，而且使用方式也更贴近文件。</p><ol><li><u>POSIX IPC 对象名字需要是类似于 /myobject 的</u>、以斜线开头后面跟非斜线字符的字符串。字符串长度受到 NAME_MAX 限制（255 个字符）。信号量的名字还要少 4 个，因为会增加前缀 <code>sem.</code>。如果不以 / 开头，则是实现定义。<em>IPC 对象名字很像一个根目录下的文件的绝对路径，在有些实现上，IPC 对象真的被放在文件系统上</em>。</li><li>创建和打开 IPC 对象很像创建或打开文件。</li><li><u>POSIX IPC 对象有引用计数</u>，进程退出或者关闭 IPC 对象后引用计数就会减少。<strong>进程调用 <code>exec()</code> 后 POSIX IPC 对象也会被关闭（很像文件有 close-on-exec 标记）</strong>。<code>{mq,sem,shm}_unlink()</code> 可以用来删除 POSIX IPC 对象，已经打开了 IPC 对象的进程仍能继续使用它们。而 System V 的删除（除了共享内存）是立即生效的，进程的后续访问会出错。</li><li><u>持久性</u>：和 System V IPC 一样，POSIX IPC 对象也有<strong>内核持久性</strong>（<strong>如果不显式删除，将会持续到系统关机</strong>）。</li><li><u>IPC 对象管理</u>：System V IPC 可以用 <code>ipcs</code> 来列出 IPC 对象，用 <code>ipcrm</code> 来删除 IPC 对象。POSIX IPC 没有这样标准化的命令。<em>Linux 上的 POSIX IPC 对象被挂载在虚拟文件系统上，其所在目录有粘滞位，可以用 ls(1) 和 rm(1) 这样的标准命令来操作 Linux 的 POSIX IPC 对象。</em></li><li>System V IPC 更古老，可移植性更强。</li><li>System V IPC 用 key 来访问，本质都是命名的；POSIX 信号量可以匿名也可以命名；POSIX 用 <code>shm_open</code> 创建共享内存是命名的，但用 mmap 也可以创建匿名共享内存（mmap 也是 POSIX 标准）；POSIX 消息队列是命名的。</li></ol></div><footer class=post-footer><div readmore=false><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/the-linux-programming-interface/51-POSIX-IPC-%E4%BB%8B%E7%BB%8D/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/52-POSIX-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="52 POSIX 消息队列"><meta itemprop=description content="和 System V 不同点：
消息按照优先级排序

消息按照优先级排序（数值越小越靠前）。每次接收都只能拿到开头的消息，不像 SysV 消息队列那样不按照优先级排序、且可以选择性获取中间的消息。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/the-linux-programming-interface/52-POSIX-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/ itemprop=url class=post-title-link>52 POSIX 消息队列</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-04 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-04 00:00:00 +0800 CST">2024-08-04
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-09-07T00:00:00+08:00 itemprop=dateModified datetime=2024-09-07T00:00:00+08:00>2024-09-07</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>和 System V 不同点：</p><h1 id=消息按照优先级排序>消息按照优先级排序
<a class=header-anchor href=#%e6%b6%88%e6%81%af%e6%8c%89%e7%85%a7%e4%bc%98%e5%85%88%e7%ba%a7%e6%8e%92%e5%ba%8f></a></h1><p>消息按照优先级排序（数值越小越靠前）。每次接收都只能拿到开头的消息，不像 SysV 消息队列那样不按照优先级排序、且可以选择性获取中间的消息。</p><h1 id=注册消息通知>注册消息通知
<a class=header-anchor href=#%e6%b3%a8%e5%86%8c%e6%b6%88%e6%81%af%e9%80%9a%e7%9f%a5></a></h1><p>POSIX 消息队列还有一个功能就是能够注册消息通知，以得到有消息来临的消息：</p><ol><li>任何时候只能有一个进程可以注册特定队列的消息通知（第二个进程注册时会失败得到 EBUSY 错误）。进程也可以主动解除通知。</li><li>消息通知是一次性的，通知完成之后就会自动解除。</li><li><strong>只有消息队列从空变成非空时，才可能有通知</strong>。在非空的状态下来消息是不会产生通知的，只能先清空再来消息才可以产生通知。</li><li>消息队列从空变成非空时，如果有其他因为调用 <code>mq_receive()</code> 而阻塞的进程，那么消息由其中的一个进程获取，而不会产生通知！！</li></ol><p>API：</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/the-linux-programming-interface/52-POSIX-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/49-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-mmap/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="49 内存映射 mmap()"><meta itemprop=description content="内存映射分类

内存映射可以通过 mmap() 函数来完成。

内存映射从可见性来讲可以分成私有（MAP_PRIVATE）和共享（MAP_SHARED）。

私有内存映射有写时复制语义。
共享映射页面上的内容变化对所有共享者都可见。共享文件映射的页面变化还会同步回文件。


内存映射从映射类型上可以分成文件映射和匿名映射。

文件映射页面被初始化为文件对应位置的内容。
匿名映射页面被初始化为 0。



因此，它们可以有以下 4 种组合方式："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/the-linux-programming-interface/49-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-mmap/ itemprop=url class=post-title-link>49 内存映射 mmap()</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-02 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-02 00:00:00 +0800 CST">2024-08-02
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-03-08T00:00:00+08:00 itemprop=dateModified datetime=2025-03-08T00:00:00+08:00>2025-03-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=内存映射分类>内存映射分类
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e5%88%86%e7%b1%bb></a></h1><p>内存映射可以通过 <code>mmap()</code> 函数来完成。</p><ol><li>内存映射从可见性来讲可以分成私有（<code>MAP_PRIVATE</code>）和共享（<code>MAP_SHARED</code>）。<ol><li>私有内存映射有写时复制语义。</li><li>共享映射页面上的内容变化对所有共享者都可见。共享文件映射的页面变化还会同步回文件。</li></ol></li><li>内存映射从映射类型上可以分成文件映射和匿名映射。<ol><li>文件映射页面被初始化为文件对应位置的内容。</li><li>匿名映射页面被初始化为 0。</li></ol></li></ol><p>因此，它们可以有以下 4 种组合方式：</p><ol><li>私有文件映射：映射的内容会被初始化为相同的内容。多个映射同一个文件的进程一开始会共享内存的物理分页，但是在修改时会触发<strong>写时复制</strong>。在私有文件映射上面的变更不会同步回文件。</li><li>私有匿名映射：<code>malloc()</code> 申请大块内存时就会使用 <code>mmap()</code> 的私有匿名映射。这样的映射虽然会在 <code>fork()</code> 后由子进程继承，但是在写入页面的时候会触发写时复制。</li><li>共享文件映射：主要功能有两个，即文件映射 I/O 和无关进程的 IPC。</li><li>共享匿名映射：可以通过 <code>fork()</code> 由相关进程共享。</li></ol><div class="markdown-alert markdown-alert-note"><p class=markdown-alert-title><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>Note</p><p>进程的文本段就是私有文件映射。尽管文本段保护位一般是 <code>PROT_EXEC | PROT_READ</code>，而且程序本身也一般不会尝试去修改代码本身，但是调试器等可能会修改程序代码。我们不希望这样的修改操作同步回可执行文件，所以使用 <code>MAP_PRIVATE</code> 而不是 <code>MAP_SHARED</code> 来映射文本段。</p><p>进程的初始化数据段也是私有文件映射。（书上没说，但是未初始化数据段大概是私有匿名映射吧？）</p></div></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/the-linux-programming-interface/49-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-mmap/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/48-System-V-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="48 System V 共享内存"><meta itemprop=description content="共享内存是 IPC 机制中最快的一种，因为共享内存段会成为进程用户空间内存的一部分，因此在申请完成之后无需内核介入便可通信。作为对比，管道数据生产者需要将数据从用户缓冲区（如果使用 stdio）写入到内核缓冲区，管道数据的消费者也需要从内核缓冲区读取信息。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/the-linux-programming-interface/48-System-V-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/ itemprop=url class=post-title-link>48 System V 共享内存</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-01 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-01 00:00:00 +0800 CST">2024-08-01
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-03-08T00:00:00+08:00 itemprop=dateModified datetime=2025-03-08T00:00:00+08:00>2025-03-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>共享内存是 IPC 机制中最快的一种，因为共享内存段会成为进程用户空间内存的一部分，因此在申请完成之后无需内核介入便可通信。作为对比，管道数据生产者需要将数据从用户缓冲区（如果使用 stdio）写入到内核缓冲区，管道数据的消费者也需要从内核缓冲区读取信息。</p><p>使用方式：</p><ul><li>用 <code>shmget()</code> 创建或取得共享内存段的标识符。</li><li>用 <code>shmat()</code> 来附上共享内存段。</li><li>用 <code>shmdt()</code> 来分离共享内存段，此操作完成之后共享内存段将无法访问。在进程终止时，未分离的共享内存段会自动分离。</li><li>用 <code>shmctl()</code> 来删除共享内存段。<strong>只有所有附加到共享内存段的进程都与其分离后，内存段才会被销毁</strong>。</li></ul><h1 id=创建-system-v-共享内存段>创建 System V 共享内存段
<a class=header-anchor href=#%e5%88%9b%e5%bb%ba-system-v-%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98%e6%ae%b5></a></h1><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/shm.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>shmget</span>(<span style=color:#dc322f>key_t</span> key, <span style=color:#dc322f>size_t</span> size, <span style=color:#dc322f>int</span> shmflg);
</span></span></code></pre></div><p>标志 <code>IPC_CREAT</code> 表示如果不存在和 key 对应的段，就创建一个新的；<code>IPC_EXCL</code> 表示共享内存段必须由当前进程创建，否则返回错误并设置 errno 为 EEXIST，使用时要同时指定 <code>IPC_CREAT</code>（man 手册中没讲不同时指定会怎么样）。其他标志略。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/the-linux-programming-interface/48-System-V-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/47-System-V-%E4%BF%A1%E5%8F%B7%E9%87%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="47 System V 信号量"><meta itemprop=description content="SysV 信号量是以信号量集的形式出现的。
创建 SysV 信号量后需要显式初始化

在 Linux 中，创建的 SysV 信号量的 semval 会被初始化为 0，但是这个行为是不可以移植的。在其他系统中，需要手动创建，再跟着初始化，这两部分可能会出现同步错误。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/the-linux-programming-interface/47-System-V-%E4%BF%A1%E5%8F%B7%E9%87%8F/ itemprop=url class=post-title-link>47 System V 信号量</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-07-28 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-07-28 00:00:00 +0800 CST">2024-07-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-09-07T00:00:00+08:00 itemprop=dateModified datetime=2024-09-07T00:00:00+08:00>2024-09-07</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>SysV 信号量是以信号量集的形式出现的。</p><h1 id=创建-sysv-信号量后需要显式初始化>创建 SysV 信号量后需要显式初始化
<a class=header-anchor href=#%e5%88%9b%e5%bb%ba-sysv-%e4%bf%a1%e5%8f%b7%e9%87%8f%e5%90%8e%e9%9c%80%e8%a6%81%e6%98%be%e5%bc%8f%e5%88%9d%e5%a7%8b%e5%8c%96></a></h1><p>在 Linux 中，创建的 SysV 信号量的 <code>semval</code> 会被初始化为 0，但是这个行为是不可以移植的。在其他系统中，需要手动创建，再跟着初始化，这两部分可能会出现同步错误。</p><h1 id=使用-semctl-前需要自己提供-semun-定义>使用 <code>semctl</code> 前需要自己提供 <code>semun</code> 定义
<a class=header-anchor href=#%e4%bd%bf%e7%94%a8-semctl-%e5%89%8d%e9%9c%80%e8%a6%81%e8%87%aa%e5%b7%b1%e6%8f%90%e4%be%9b-semun-%e5%ae%9a%e4%b9%89></a></h1><p>参考 <code>man semctl</code>，应用程序必须自己提供 <code>semun</code> 的定义（如果想要给 <code>semctl</code> 传递第 4 个参数）。这个定义并不在头文件里！</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>union</span> semun {
</span></span><span style=display:flex><span>   <span style=color:#dc322f>int</span>              val;    <span style=color:#586e75>/* Value for SETVAL */</span>
</span></span><span style=display:flex><span>   <span style=color:#719e07>struct</span> semid_ds <span style=color:#719e07>*</span>buf;    <span style=color:#586e75>/* Buffer for IPC_STAT, IPC_SET */</span>
</span></span><span style=display:flex><span>   <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>short</span>  <span style=color:#719e07>*</span>array;  <span style=color:#586e75>/* Array for GETALL, SETALL */</span>
</span></span><span style=display:flex><span>   <span style=color:#719e07>struct</span> seminfo  <span style=color:#719e07>*</span>__buf;  <span style=color:#586e75>/* Buffer for IPC_INFO
</span></span></span><span style=display:flex><span><span style=color:#586e75>                               (Linux-specific) */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h1 id=semop-和操作系统课程所学有什么差异><code>semop()</code> 和操作系统课程所学有什么差异？
<a class=header-anchor href=#semop-%e5%92%8c%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e8%af%be%e7%a8%8b%e6%89%80%e5%ad%a6%e6%9c%89%e4%bb%80%e4%b9%88%e5%b7%ae%e5%bc%82></a></h1><p>共性：永不为负，P 和 V 都是原子操作。关于“永不为负”这一点我还去求证了一下，发现确实是自己本科学的东西记错了。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/the-linux-programming-interface/47-System-V-%E4%BF%A1%E5%8F%B7%E9%87%8F/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/45-System-V-IPC/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="45 System V IPC"><meta itemprop=description content="System V IPC 对象 xxx_get 来打开（含创建）、xxx_ctl 来控制（含删除）。
操作 System V IPC 对象需要 key，key 可以用 IPC_PRIVATE 来让系统创建一个独一无二的，也可以从 ftok() 按照文件的 inode 号生成。System V IPC 其实都是命名的，IPC_PRIVATE 并不能真正实现匿名，只是生成一个不重复的名字罢了。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/the-linux-programming-interface/45-System-V-IPC/ itemprop=url class=post-title-link>45 System V IPC</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-07-24 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-07-24 00:00:00 +0800 CST">2024-07-24
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-03-08T00:00:00+08:00 itemprop=dateModified datetime=2025-03-08T00:00:00+08:00>2025-03-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>System V IPC 对象 <code>xxx_get</code> 来打开（含创建）、<code>xxx_ctl</code> 来控制（含删除）。</p><p>操作 System V IPC 对象需要 key，key 可以用 <code>IPC_PRIVATE</code> 来让系统创建一个独一无二的，也可以从 <code>ftok()</code> 按照文件的 inode 号生成。<strong>System V IPC 其实都是命名的，<code>IPC_PRIVATE</code> 并不能真正实现匿名，只是生成一个不重复的名字罢了</strong>。</p><p>System V IPC 对象具有内核持久性，消息队列和信号量是无连接的（删除立即生效）、共享内存段有引用计数（比较像文件）。</p><p>一些命令：</p><ul><li><code>ipcs</code>：查看当前 System V IPC 对象的使用情况。</li><li><code>ipcs -l</code>：列出 System V IPC 对象的资源上限。</li><li><code>ipcrm -[M|Q|S] key</code> / <code>ipcrm -[m|q|s] id</code>：删除 System V IPC 对象。</li></ul></div><footer class=post-footer><div readmore=false><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/the-linux-programming-interface/45-System-V-IPC/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/the-linux-programming-interface/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/the-linux-programming-interface/>1</a>
<span class="page-number current">2</span>
<a class=page-number href=/the-linux-programming-interface/page/3/>3</a>
<a class=page-number href=/the-linux-programming-interface/page/4/>4</a>
<a class=page-number href=/the-linux-programming-interface/page/5/>5</a>
<a class=page-number href=/the-linux-programming-interface/page/6/>6</a>
<a class=page-number href=/the-linux-programming-interface/page/7/>7</a>
<a class=page-number href=/the-linux-programming-interface/page/8/>8</a>
<a class="extend next" rel=next href=/the-linux-programming-interface/page/3/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>