<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="41 共享库基础"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content="the-linux-programming-interface"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"41-%E5%85%B1%E4%BA%AB%E5%BA%93%E5%9F%BA%E7%A1%80","permalink":"https://hxhue.github.io/the-linux-programming-interface/41-%E5%85%B1%E4%BA%AB%E5%BA%93%E5%9F%BA%E7%A1%80/","title":"41 共享库基础","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>41 共享库基础 - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#操作静态库>操作静态库</a></li><li><a href=#共享库基本介绍>共享库基本介绍</a><ul><li><a href=#创建共享库>创建共享库</a></li><li><a href=#位置独立编码pic>位置独立编码（PIC）</a></li><li><a href=#确定文件是否使用了--fpic-选项编译>确定文件是否使用了 <code>-fPIC</code> 选项编译</a><ul><li><a href=#1-检查目标文件的符号表>1. 检查目标文件的符号表</a></li><li><a href=#2-检查共享库的符号表>2. 检查共享库的符号表</a></li></ul></li></ul></li><li><a href=#动态链接器dynamic-linker>动态链接器（Dynamic Linker）</a></li><li><a href=#ld_library_path-环境变量><code>LD_LIBRARY_PATH</code> 环境变量</a></li><li><a href=#soname>soname</a></li><li><a href=#实用工具>实用工具</a></li><li><a href=#共享库命名规范>共享库命名规范</a></li><li><a href=#安装共享库>安装共享库</a></li><li><a href=#用-ldconfig-管理加载器缓存>用 <code>ldconfig</code> 管理加载器缓存</a><ul><li><a href=#ldconfig-会更新-soname-符号链接但不会更新链接器名称><code>ldconfig</code> 会更新 soname 符号链接，但不会更新链接器名称</a></li><li><a href=#ldconfig-是从-elf-文件的-dt_soname-获取-soname-信息的><code>ldconfig</code> 是从 ELF 文件的 DT_SONAME 获取 soname 信息的</a></li></ul></li><li><a href=#在目标文件中指定搜索目录-rpath>在目标文件中指定搜索目录（<code>-rpath</code>）</a><ul><li><a href=#链接器的--rpath-选项>链接器的 <code>-rpath</code> 选项</a></li><li><a href=#什么时候要用到-runpath>什么时候要用到 RUNPATH？</a></li><li><a href=#ld_run_path><code>LD_RUN_PATH</code></a></li><li><a href=#elf-的-dt_rpath-和-dt_runpath-条目>ELF 的 <code>DT_RPATH</code> 和 <code>DT_RUNPATH</code> 条目</a></li><li><a href=#在--rpath-中使用相对于应用程序的路径>在 <code>-rpath</code> 中使用相对于应用程序的路径</a></li></ul></li><li><a href=#共享库的搜索顺序重要>共享库的搜索顺序（重要）</a></li><li><a href=#运行时符号解析重要>运行时符号解析（重要）</a><ul><li><a href=#复现书中例子>复现书中例子</a></li><li><a href=#个人回忆>个人回忆</a></li></ul></li><li><a href=#控制-linker-链接到动态库还是静态库>控制 linker 链接到动态库还是静态库</a></li><li><a href=#即使不真正依赖也强制链接>即使不真正依赖也强制链接</a></li><li><a href=#符号介入>符号介入</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/41-%E5%85%B1%E4%BA%AB%E5%BA%93%E5%9F%BA%E7%A1%80/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="41 共享库基础"><meta itemprop=description content="操作静态库

静态库可以使用 ar 命令创建和管理（尽管一般不需要我们自己调用 ar 命令）。
创建归档：
ar r libdemo.a mod1.o mod2.o mod3.o
列出归档：
$ ar tv libdemo.a
rw-r--r-- 1000/100 1001016 Nov 15 12:26 2009 mod1.o
rw-r--r-- 1000/100 406668 Nov 15 12:21 2009 mod2.o
rw-r--r-- 1000/100  46672 Nov 15 12:21 2009 mod3.o
从归档中删除内容："></span><header class=post-header><h1 class=post-title itemprop="name headline">41 共享库基础</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-07-19 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-07-19 00:00:00 +0800 CST">2024-07-19
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-04-06T00:00:00+08:00 itemprop=dateModified datetime=2025-04-06T00:00:00+08:00>2025-04-06</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>5799</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>12分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=操作静态库>操作静态库
<a class=header-anchor href=#%e6%93%8d%e4%bd%9c%e9%9d%99%e6%80%81%e5%ba%93></a></h1><p>静态库可以使用 <code>ar</code> 命令创建和管理（尽管一般不需要我们自己调用 <code>ar</code> 命令）。</p><p>创建归档：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>ar r libdemo.a mod1.o mod2.o mod3.o
</span></span></code></pre></div><p>列出归档：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>$ ar tv libdemo.a
</span></span><span style=display:flex><span>rw-r--r-- 1000/100 1001016 Nov 15 12:26 2009 mod1.o
</span></span><span style=display:flex><span>rw-r--r-- 1000/100 406668 Nov 15 12:21 2009 mod2.o
</span></span><span style=display:flex><span>rw-r--r-- 1000/100  46672 Nov 15 12:21 2009 mod3.o
</span></span></code></pre></div><p>从归档中删除内容：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>ar d libdemo.a mod3.o
</span></span></code></pre></div><h1 id=共享库基本介绍>共享库基本介绍
<a class=header-anchor href=#%e5%85%b1%e4%ba%ab%e5%ba%93%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d></a></h1><ol><li><u>虽然共享库的代码是由多个进程共享的，但其中的变量却不是</u>。每个使用库的进程会拥有自己的在库中定义的全局和静态变量的副本。</li><li><u>共享库通常需要使用额外的寄存器来支持位置独立编码（PIC）</u>，在运行时也需要符号解析（重定位）。</li></ol><blockquote><p>DSO 指 dynamic shared object。</p></blockquote><h2 id=创建共享库>创建共享库
<a class=header-anchor href=#%e5%88%9b%e5%bb%ba%e5%85%b1%e4%ba%ab%e5%ba%93></a></h2><p>在 gcc 中使用 <code>-fPIC</code> 来生成位置无关编码的程序，用 <code>-shared</code> 来生成共享库而不是可执行文件。</p><h2 id=位置独立编码pic>位置独立编码（PIC）
<a class=header-anchor href=#%e4%bd%8d%e7%bd%ae%e7%8b%ac%e7%ab%8b%e7%bc%96%e7%a0%81pic></a></h2><p>生成位置独立编码会让程序每次对全局数据（包括变量和函数地址）的访问都相对于一个<strong>偏移</strong>进行（这个偏移其实就是 GOT 表的起始位置）。在一些平台上要生成共享库必须使用 PIC。</p><p><strong>Linux/x86-32 环境中不用 PIC 也能生成共享库，只是这样创建出来的共享库代码不能被多个进程复用内存</strong>，而是在每个进程中都有一份修改后的副本。（<u>外存共享、内存不共享</u>。）</p><h2 id=确定文件是否使用了--fpic-选项编译>确定文件是否使用了 <code>-fPIC</code> 选项编译
<a class=header-anchor href=#%e7%a1%ae%e5%ae%9a%e6%96%87%e4%bb%b6%e6%98%af%e5%90%a6%e4%bd%bf%e7%94%a8%e4%ba%86--fpic-%e9%80%89%e9%a1%b9%e7%bc%96%e8%af%91></a></h2><h3 id=1-检查目标文件的符号表>1. 检查目标文件的符号表
<a class=header-anchor href=#1-%e6%a3%80%e6%9f%a5%e7%9b%ae%e6%a0%87%e6%96%87%e4%bb%b6%e7%9a%84%e7%ac%a6%e5%8f%b7%e8%a1%a8></a></h3><p>如果目标文件（<code>*.o</code>）在编译时使用了 <code>-fPIC</code> 选项，则 <code>nm</code> 或 <code>objdump</code> 命令会有输出：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#586e75># 1</span>
</span></span><span style=display:flex><span>nm mod1.o | grep _GLOBAL_OFFSET_TABLE_
</span></span><span style=display:flex><span><span style=color:#586e75># 如果 nm 的输入是静态库，则会对静态库中的每个目标文件都进行搜索</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75># 2</span>
</span></span><span style=display:flex><span>readelf -s mod1.o | grep _GLOBAL_OFFSET_TABLE_
</span></span></code></pre></div><p>以上两个命令都是读取目标文件的符号表。</p><h3 id=2-检查共享库的符号表>2. 检查共享库的符号表
<a class=header-anchor href=#2-%e6%a3%80%e6%9f%a5%e5%85%b1%e4%ba%ab%e5%ba%93%e7%9a%84%e7%ac%a6%e5%8f%b7%e8%a1%a8></a></h3><p>如果以下任何命令产生了输出，说明共享库中至少有一个目标文件在编译时没有使用 <code>-fPIC</code> 选项。举例：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#586e75># 获取 libc6 的路径</span>
</span></span><span style=display:flex><span>$ realpath <span style=color:#2aa198>&#34;</span><span style=color:#719e07>$(</span>gcc --print-file-name<span style=color:#719e07>=</span>libc.so.6<span style=color:#719e07>)</span><span style=color:#2aa198>&#34;</span>
</span></span><span style=display:flex><span>/usr/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span><span style=color:#586e75># 测试 1</span>
</span></span><span style=display:flex><span>$ readelf -d /usr/lib/x86_64-linux-gnu/libc.so.6 | grep TEXTREL
</span></span><span style=display:flex><span><span style=color:#586e75># 测试 2</span>
</span></span><span style=display:flex><span>$ objdump --all-headers /usr/lib/x86_64-linux-gnu/libc.so.6 | grep TEXTREL
</span></span></code></pre></div><p>字符串 TEXTREL 表示存在一个目标模块，其文本段包含需要运行时重定位的引用。（意思是要么依靠运行时重定位，要么依靠虚拟地址并在访存时加上偏移？）</p><p>说明：</p><ol><li>对共享库文件使用 <code>nm</code> 会提示 no symbol。书上的例子是用 <code>nm</code> 对目标文件提取符号表，不要用错对象。</li><li>/usr/lib/x86_64-linux-gnu/libc.so 是一个链接脚本，不是 ELF 格式的动态链接库。可以用 <code>file</code> 命令来查看文件的类型。</li><li>gcc 还有一个 /usr/lib/x86_64-linux-gnu/libc.a 文件。</li></ol><h1 id=动态链接器dynamic-linker>动态链接器（Dynamic Linker）
<a class=header-anchor href=#%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e5%99%a8dynamic-linker></a></h1><p>动态链接器（Dynamic linker）又被称为动态链接加载器（dynamic linking loader）或运行时加载器（run-time loader）。</p><p><strong>要区分 linker 和 loader（动态链接器）</strong>：前者通常为 ld，是可执行程序；后者通常为 ld.so，是动态链接库。Linker 也被叫做链接编辑器（link editor），在静态链接阶段起作用（这个时候还没形成可执行文件），包括使用共享库在内的所有程序都会经过静态链接阶段。</p><p>一个程序中依赖的所有共享库的列表被称为程序的动态依赖列表（dynamic dependency list）。<strong>链接到共享库的程序至少都会依赖动态链接器</strong>，也常可能会依赖 C 语言标准库（libc.so.6）。</p><blockquote><p>在 wsl 和服务器上测试，发现可执行文件还依赖了 linux-vdso.so.1，但是书上没有列出。</p></blockquote><p>动态链接器路径一般是 /lib/ld-linux.so.2，常常为指向真正动态链接器的符号链接。在我测试的服务器上，这个文件指向 /usr/lib/i386-linux-gnu/ld-2.31.so。在 wsl 中，这个文件不存在，取而代之的是 /usr/lib64/ld-linux-x86-64.so.2，它是指向 /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 的符号链接。</p><h1 id=ld_library_path-环境变量><code>LD_LIBRARY_PATH</code> 环境变量
<a class=header-anchor href=#ld_library_path-%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f></a></h1><p>如果共享库在非标准的位置，可以将路径添加到 <code>LD_LIBRARY_PATH</code> 中使动态链接加载器在加载程序时找到共享库。<code>LD_LIBRARY_PATH</code> 中的路径可以用 <code>:</code> 来分割，如果 <code>LD_LIBRARY_PATH</code> 不为空，但是有一个路径分项为空，则等价于这个路径是当前路径（<code>.</code>）。</p><h1 id=soname>soname
<a class=header-anchor href=#soname></a></h1><p>没有 soname 时，嵌入到可执行文件的名称，还有动态链接器在运行时搜索的名称都是共享库文件的真实名称（real name）。有 soname 时就是 soname 了。soname 提供了一层间接机制，使得可执行文件运行时可以加载相互兼容（soname 相同、实现兼容）的共享库。</p><blockquote><p>给共享库执行 soname 相当于是在说这个共享库支持了某种服务。感觉有点像 Java 的服务提供者框架（Service Provider Interface, SPI）协议。</p></blockquote><p>在生成动态链接库时指定 soname（例子中虽然共享库本身的名字是 libfoo.so 但 soname 是 libbar.so）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>gcc -g -shared -Wl,-soname,libbar.so -o libfoo.so mod1.o mod2.o
</span></span></code></pre></div><p><strong>不指定 soname 时，生成的共享库中是没有 SONAME 这一项记录的</strong>，并不是会和输出文件名相同。</p><p>soname 放在 ELF 的 <code>DT_SONAME</code> 标签中，可以用以下方式搜索到：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -p libfoo.so | grep SONAME
</span></span><span style=display:flex><span>  SONAME      libbar.so
</span></span><span style=display:flex><span>$ readelf -d libfoo.so | grep SONAME
</span></span><span style=display:flex><span> 0x0000000e <span style=color:#719e07>(</span>SONAME<span style=color:#719e07>)</span>      Library soname: <span style=color:#719e07>[</span>libbar.so<span style=color:#719e07>]</span>
</span></span></code></pre></div><p>如果 soname 和文件本身的名字不同，那么还必须做一件事：创建一个和 soname 同名的符号链接，指向文件本身。否则，由于动态链接器查找的是 soname，在 <code>LD_LIBRARY_PATH</code> 下是找不到的。</p><h1 id=实用工具>实用工具
<a class=header-anchor href=#%e5%ae%9e%e7%94%a8%e5%b7%a5%e5%85%b7></a></h1><p><code>ldd a.out</code> 可以显示运行程序所需的依赖。</p><p><code>objdump</code> 和 <code>readelf</code> 可以显示可执行文件、目标文件和共享库中的各种信息。<code>objdump</code> 甚至还能显示汇编代码。<code>objdump</code> 也可以用来显示 ELF 的头部信息，这时功能近似于 <code>readelf</code>。</p><p>nm 命令列举可执行文件或目标库中的符号。</p><h1 id=共享库命名规范>共享库命名规范
<a class=header-anchor href=#%e5%85%b1%e4%ba%ab%e5%ba%93%e5%91%bd%e5%90%8d%e8%a7%84%e8%8c%83></a></h1><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>libname.so.major-id.minor-id
</span></span></code></pre></div><p>如果次要版本中包含了补丁号 / 修订号，那么版本名就不是 x.y，而是 x.y.z（相当于 y.z 是原来的 y）。</p><p>只要主要版本相同，共享库就应该是可以兼容的。因此 soname 只包含共享库的主要版本号，通常作为一个指向以完整版本号为名的共享库的符号链接。比如：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>libdemo.so.1        -&gt; libdemo.so.1.0.2
</span></span><span style=display:flex><span>libdemo.so.2        -&gt; libdemo.so.2.0.0
</span></span><span style=display:flex><span>libreadline.so.5    -&gt; libreadline.so.5.0
</span></span></code></pre></div><p>除了真实名称和 soname，共享库还存在第三个名称：<strong>链接器名称</strong>。</p><div style=overflow-x:auto><table><thead><tr><th>名称</th><th>命名</th><th>用途</th><th>文件类型</th></tr></thead><tbody><tr><td>真实名称（real name）</td><td>libname.so.major.minor\[.patch\]</td><td>共享库本身</td><td>共享库</td></tr><tr><td>soname</td><td>libname.so.major</td><td>链接时把 soname 存入可执行文件的动态依赖列表；加载时用 soname 来查找共享库</td><td>指向真实名称的符号链接</td></tr><tr><td>链接器名称（linker name）</td><td>libname.so</td><td>链接时用 linker name 查找共享库</td><td>指向 soname 文件的符号链接</td></tr></tbody></table></div><p>在生成可执行文件时，将目标文件链接到链接器名称，可以使得动态链接器（loader）能在运行时自动查找最新的共享库。但如果需要使用特定版本的共享库，则应该链接到 soname（带有主要版本号）。</p><h1 id=安装共享库>安装共享库
<a class=header-anchor href=#%e5%ae%89%e8%a3%85%e5%85%b1%e4%ba%ab%e5%ba%93></a></h1><p>生产环境中不应该使用依赖 <code>LD_LIBRARY_PATH</code> 查找共享库的技术，应该把共享库安装到标准的位置。</p><p>标准的库目录包括：</p><ul><li>/usr/lib：大多数标准程序的安装目录（debian 中用 apt 安装共享库就会安装到这里）</li><li>/lib：系统启动需要的库需要放在这里，因为这个时候 /usr/lib 可能还没有被挂载</li><li>/etc/ld.so.conf 中指定的目录（包括 /usr/local/lib）</li></ul><p>通常 soname 和链接器名称都是和“以真实名称命名的共享库文件”在同一个目录下的符号链接，符号链接的形式也是相对寻址：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>mv libdemo.so.1.0.1 /usr/lib
</span></span><span style=display:flex><span><span style=color:#b58900>cd</span> /usr/lib
</span></span><span style=display:flex><span>ln -s libdemo.so.1.0.1 libdemo.so.1
</span></span><span style=display:flex><span>ln -s libdemo.so.1 libdemo.so
</span></span></code></pre></div><h1 id=用-ldconfig-管理加载器缓存>用 <code>ldconfig</code> 管理加载器缓存
<a class=header-anchor href=#%e7%94%a8-ldconfig-%e7%ae%a1%e7%90%86%e5%8a%a0%e8%bd%bd%e5%99%a8%e7%bc%93%e5%ad%98></a></h1><p>ldconfig(8) 维护 /etc/ld.so.cache 缓存，以方便动态链接器快速查找需要的共享库。每次更新缓存时，ldconfig 会从 /lib、/usr/lib 和 /etc/ld.so.conf 中指定的路径来查找共享库。它检查每个库的各个主要版本的最新次要版本（即具有最大的次要版本号的版本）以找出嵌入的 soname，然后在<strong>同一目录</strong>中为每个 soname 创建（或更新）相对符号链接。</p><p>命令选项：</p><ul><li><code>-N</code> 会禁用缓存的重建</li><li><code>-n</code> 会禁用对标准库路径的处理（只对命令行提供的路径处理），同时也带有 <code>-N</code> 的含义，即禁用缓存重建</li><li><code>-X</code> 选项会阻止 soname 符号链接的创建</li><li><code>-v</code> 选项会让 ldconfig 给出更多的信息</li><li><code>-p</code> 选项会直接输出当前缓存的内容、不执行缓存构建操作</li></ul><h2 id=ldconfig-会更新-soname-符号链接但不会更新链接器名称><code>ldconfig</code> 会更新 soname 符号链接，但不会更新链接器名称
<a class=header-anchor href=#ldconfig-%e4%bc%9a%e6%9b%b4%e6%96%b0-soname-%e7%ac%a6%e5%8f%b7%e9%93%be%e6%8e%a5%e4%bd%86%e4%b8%8d%e4%bc%9a%e6%9b%b4%e6%96%b0%e9%93%be%e6%8e%a5%e5%99%a8%e5%90%8d%e7%a7%b0></a></h2><p><strong><code>ldconfig</code> 会通过真实共享库名称更新 soname 符号链接，但是不会更新链接器名称</strong>（以下例子中没有输出 libdemo.so 符号链接），因此，如果需要链接器名称，我们需要手动更新。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span># mv libdemo.so.1.0.1 libdemo.so.2.0.0 /usr/lib
</span></span><span style=display:flex><span># ldconfig -v | grep libdemo
</span></span><span style=display:flex><span>        libdemo.so.1 -&gt; libdemo.so.1.0.1 (changed)
</span></span><span style=display:flex><span>        libdemo.so.2 -&gt; libdemo.so.2.0.0 (changed)
</span></span></code></pre></div><p>如果又安装了 libdemo.so.2.0.1，ldconfig 还能将 libdemo.so.2 修改为指向 libdemo.so.2.0.1 的符号链接，因为 2.0.1 版本是最新的。</p><h2 id=ldconfig-是从-elf-文件的-dt_soname-获取-soname-信息的><code>ldconfig</code> 是从 ELF 文件的 DT_SONAME 获取 soname 信息的
<a class=header-anchor href=#ldconfig-%e6%98%af%e4%bb%8e-elf-%e6%96%87%e4%bb%b6%e7%9a%84-dt_soname-%e8%8e%b7%e5%8f%96-soname-%e4%bf%a1%e6%81%af%e7%9a%84></a></h2><p>ldconfig 用来更新符号链接的 soname 是从共享库文件本身的 DT_SONAME 信息中提取的：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>eric@debian:~/soname$ gcc -fPIC -shared -Wl,-soname,libbar.so.1 -o libfoo.so.1.0.0 foo.c
</span></span><span style=display:flex><span>eric@debian:~/soname$ ls
</span></span><span style=display:flex><span>foo.c  libfoo.so.1.0.0
</span></span><span style=display:flex><span>eric@debian:~/soname$ ldconfig -nv .
</span></span><span style=display:flex><span>.: <span style=color:#719e07>(</span>from &lt;cmdline&gt;:0<span style=color:#719e07>)</span>
</span></span><span style=display:flex><span>        libbar.so.1 -&gt; libfoo.so.1.0.0
</span></span><span style=display:flex><span>eric@debian:~/soname$ ls
</span></span><span style=display:flex><span>foo.c  libbar.so.1  libfoo.so.1.0.0
</span></span></code></pre></div><p>此时，由于没有链接器名称，是无法使用 <code>gcc -fPIC main.c -lbar -L.</code>（假设 main.c 也在当前文件夹）来编译代码的，一定要创建一个链接器名才能成功。（或者直接把共享库作为参数，而不是通过 <code>-lbar</code> 指定共享库。）</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>eric@debian:~/soname$ gcc -fPIC main.c -lbar -L.
</span></span><span style=display:flex><span>/usr/bin/ld: cannot find -lbar: No such file or directory
</span></span><span style=display:flex><span>collect2: error: ld returned <span style=color:#2aa198>1</span> <span style=color:#b58900>exit</span> status
</span></span><span style=display:flex><span>eric@debian:~/soname$ ln -s libbar.so.1 libbar.so
</span></span><span style=display:flex><span>eric@debian:~/soname$ gcc -fPIC main.c -lbar -L.
</span></span><span style=display:flex><span>eric@debian:~/soname$
</span></span></code></pre></div><p>注意：符号链接对 gcc（和任何用默认参数调用 <code>open()</code> 的程序一样）来说是透明的，gcc 看到 <code>-lbar</code> 就会去找 <code>libbar.so</code>，并不关心它本身是共享库、还是一个符号链接。因此，<strong>人为创建“链接器名”符号链接是为了帮助 gcc 正确链接可执行程序，可执行程序依赖的还是 soname 而不是 linker name。一旦找到共享库，生成的可执行文件中记录的动态依赖是 soname，而不是真实名称</strong>，这样方便共享库的次要版本更新。几种共享库名称的对比见上面的表格。</p><h1 id=在目标文件中指定搜索目录-rpath>在目标文件中指定搜索目录（<code>-rpath</code>）
<a class=header-anchor href=#%e5%9c%a8%e7%9b%ae%e6%a0%87%e6%96%87%e4%bb%b6%e4%b8%ad%e6%8c%87%e5%ae%9a%e6%90%9c%e7%b4%a2%e7%9b%ae%e5%bd%95-rpath></a></h1><h2 id=链接器的--rpath-选项>链接器的 <code>-rpath</code> 选项
<a class=header-anchor href=#%e9%93%be%e6%8e%a5%e5%99%a8%e7%9a%84--rpath-%e9%80%89%e9%a1%b9></a></h2><p>静态编辑阶段可以向可执行文件中插入一个运行时搜索共享库的目录列表，方法是使用链接器（linker）的 <code>-rpath</code> 选项向 ELF 中添加 RUNPATH（这里没有说是 ELF 的哪个标签，标签过几个小节就会提到，请留意）。书上的例子：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>gcc -g -Wall -Wl,-rpath,/home/mtk/pdir -o prog prog.c libdemo.so
</span></span></code></pre></div><p>如果要加入多个条目到 RUNPATH 中，需要指定多次 <code>-rpath</code>。</p><h2 id=什么时候要用到-runpath>什么时候要用到 RUNPATH？
<a class=header-anchor href=#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e8%a6%81%e7%94%a8%e5%88%b0-runpath></a></h2><p>用 cmake 编译出来的可执行文件 A 如果链接到了同期用 cmake 编译出来的共享库 B 上，那么它的 RUNPATH 中就会包含 B 生成位置的绝对路径，形如 /workspace/build/，这样就可以在不将共享库安装到系统、也不设置 <code>LD_LIBRARY_PATH</code> 环境变量的情况下测试程序。</p><p>一个共享库也可能会包含 RUNPATH，以方便动态链接器能找到它依赖列表中的共享库。</p><h2 id=ld_run_path><code>LD_RUN_PATH</code>
<a class=header-anchor href=#ld_run_path></a></h2><p>也可以使用 <code>LD_RUN_PATH</code> 环境变量，在构建可执行文件的时候，链接器会将其视为从命令行提供的 <code>-rpath</code> 选项使用。如果显式提供了 <code>-rpath</code> 选项，该环境变量会被忽略。</p><h2 id=elf-的-dt_rpath-和-dt_runpath-条目>ELF 的 <code>DT_RPATH</code> 和 <code>DT_RUNPATH</code> 条目
<a class=header-anchor href=#elf-%e7%9a%84-dt_rpath-%e5%92%8c-dt_runpath-%e6%9d%a1%e7%9b%ae></a></h2><p>使用 <code>-rpath</code> 向 ELF 写入的标签默认为 <code>DT_RPATH</code>，如果链接器同时收到了 <code>--enable-new-dtags</code> 选项，则是向 ELF 写入 <code>DT_RUNPATH</code>。</p><p>这两个标签的区别是：如果程序运行时存在 <code>LD_LIBRARY_PATH</code> 环境变量，在标签为 <code>DT_RPATH</code> 的情况下，<code>LD_LIBRARY_PATH</code> 环境变量优先级更低；在标签为 <code>DT_RUNPATH</code> 的情况下，<code>LD_LIBRARY_PATH</code> 的优先级更高。</p><p>一个 ELF 中可以同时存在 <code>DT_RPATH</code> 和 <code>DT_RUNPATH</code> 条目。这两个条目同时存在时，如果动态链接器能够理解 <code>DT_RUNPATH</code>（过老的动态链接器不能理解），则会把 <code>DT_RPATH</code> 忽略；否则，动态链接器只会认出 <code>DT_RPATH</code>。</p><h2 id=在--rpath-中使用相对于应用程序的路径>在 <code>-rpath</code> 中使用相对于应用程序的路径
<a class=header-anchor href=#%e5%9c%a8--rpath-%e4%b8%ad%e4%bd%bf%e7%94%a8%e7%9b%b8%e5%af%b9%e4%ba%8e%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e7%9a%84%e8%b7%af%e5%be%84></a></h2><p>可以用 <code>${ORIGIN}</code> 或者 <code>$ORIGIN</code> 表示相当于 <mark>ELF 本身的路径</mark>。为了防止 shell 转义，需要用单引号将 <code>$ORIGIN</code> 包裹：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>gcc -Wl,-rpath,<span style=color:#2aa198>&#39;$ORIGIN&#39;</span>/lib ...
</span></span></code></pre></div><p>相当于 ELF 本身的路径 != 相对路径，因为相当路径是相当于工作目录。</p><p>在应用程序依赖了自己的共享库，而应用（及它的共享库）又可能被安装到任意位置时，<code>$ORIGIN</code> 就能派上用场。</p><h1 id=共享库的搜索顺序重要>共享库的搜索顺序（重要）
<a class=header-anchor href=#%e5%85%b1%e4%ba%ab%e5%ba%93%e7%9a%84%e6%90%9c%e7%b4%a2%e9%a1%ba%e5%ba%8f%e9%87%8d%e8%a6%81></a></h1><p>对于 ELF 文件中的每个共享库依赖：</p><ol><li>如果依赖中有 <code>/</code>，说明这是绝对或相对路径，将直接检查该路径，<strong>终止后续搜索</strong>。</li><li>如果 ELF 中有 <code>DT_RPATH</code> 且没有 <code>DT_RUNPATH</code>，则前者发挥作用，按顺序搜索该列表中的路径。</li><li>如果有环境变量 <code>LD_LIBRARY_PATH</code> 且可执行文件不是 set-user/group-ID 程序（为了安全考虑、防止用户诱骗加载同名库），则搜索 <code>LD_LIBRARY_PATH</code> 表示的路径列表。</li><li>如果 ELF 中有 <code>DT_RUNPATH</code>，按顺序搜索该列表中的路径。</li><li>在 /etc/ld.so.cache 文件中搜索共享库。</li><li>搜索 /lib，如果找不到再搜索 /usr/lib。原文：<em>The directories /lib and /usr/lib are searched (in that order).</em></li></ol><h1 id=运行时符号解析重要>运行时符号解析（重要）
<a class=header-anchor href=#%e8%bf%90%e8%a1%8c%e6%97%b6%e7%ac%a6%e5%8f%b7%e8%a7%a3%e6%9e%90%e9%87%8d%e8%a6%81></a></h1><p>书上给了个例子：</p><p><img src=/assets/Pasted%20image%2020240720220108.webp></p><p>按理来说，我们希望 libfoo.so 中定义的 <code>func()</code> 能去调用 libfoo.so 中的 <code>xyz()</code>，但实际上却调用了 prog 中的 <code>xyz()</code>。这是因为程序需要解析符号时，总是在第一次看到符号时进行链接，不管它在哪个库（多个库中可能会有同名的符号），链接后符号就变成“不需要解析”的了。在这个例子中，prog 已经包含了 <code>xyz()</code> 的定义，无需解析；但还缺少 func() 的定义。在运行时加载了 libfoo.so 后，<code>func()</code> 也成功解析了，<code>func()</code> 中调用的 <code>xyz()</code> 因为早就有了，所以没有从 libfoo.so 中取。</p><p>为了改变这种情况，我们在创建 libfoo.so 共享库的时候可以向 ld 指定 <code>-Bsymbolic</code> 选项，要求在编译共享库的时候就尽可能提前绑定内部定义的全局符号，这样生成的程序就不会意外地调用 prog 中的 <code>xyz()</code> 了。<code>ld</code> 命令帮助中写道：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>  -Bno-symbolic               Don&#39;t bind global references locally
</span></span><span style=display:flex><span>  -Bsymbolic                  Bind global references locally
</span></span><span style=display:flex><span>  -Bsymbolic-functions        Bind global function references locally
</span></span></code></pre></div><p>区分 <code>-Bsymbolic</code> 和 <code>-Bsymbolic-functions</code> 让我们意识到主程序中引用的全局变量也是可以在共享库中定义的！</p><p>给 <code>xyz()</code> 函数加上 static 限定符能否避免这种情况？实测可以。</p><h2 id=复现书中例子>复现书中例子
<a class=header-anchor href=#%e5%a4%8d%e7%8e%b0%e4%b9%a6%e4%b8%ad%e4%be%8b%e5%ad%90></a></h2><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>eric@debian:~/resolve$ cat main.c
</span></span><span style=display:flex><span><span style=color:#586e75>#include &lt;stdio.h&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void foo<span style=color:#719e07>(</span>void<span style=color:#719e07>)</span> <span style=color:#719e07>{</span>
</span></span><span style=display:flex><span>    printf<span style=color:#719e07>(</span><span style=color:#2aa198>&#34;main::foo()\n&#34;</span><span style=color:#719e07>)</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void call_foo<span style=color:#719e07>()</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>int main<span style=color:#719e07>()</span> <span style=color:#719e07>{</span>
</span></span><span style=display:flex><span>    call_foo<span style=color:#719e07>()</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>}</span>
</span></span><span style=display:flex><span>eric@debian:~/resolve$ cat foo.c
</span></span><span style=display:flex><span><span style=color:#586e75>#include &lt;stdio.h&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/* static */
</span></span><span style=display:flex><span>void foo<span style=color:#719e07>(</span>void<span style=color:#719e07>)</span> <span style=color:#719e07>{</span>
</span></span><span style=display:flex><span>    printf<span style=color:#719e07>(</span><span style=color:#2aa198>&#34;libfoo.so::foo()\n&#34;</span><span style=color:#719e07>)</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void call_foo<span style=color:#719e07>(</span>void<span style=color:#719e07>)</span> <span style=color:#719e07>{</span>
</span></span><span style=display:flex><span>    foo<span style=color:#719e07>()</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>}</span>
</span></span><span style=display:flex><span>eric@debian:~/resolve$ gcc -fPIC -shared -Wl,-Bsymbolic -o libfoo.so foo.c
</span></span><span style=display:flex><span>eric@debian:~/resolve$ gcc -fPIC main.c libfoo.so
</span></span><span style=display:flex><span>eric@debian:~/resolve$ env <span style=color:#268bd2>LD_LIBRARY_PATH</span><span style=color:#719e07>=</span>. ./a.out
</span></span><span style=display:flex><span>libfoo.so::foo<span style=color:#719e07>()</span>
</span></span><span style=display:flex><span>eric@debian:~/resolve$ gcc -fPIC -shared -o libfoo.so foo.c
</span></span><span style=display:flex><span>eric@debian:~/resolve$ gcc -fPIC main.c libfoo.so
</span></span><span style=display:flex><span>eric@debian:~/resolve$ env <span style=color:#268bd2>LD_LIBRARY_PATH</span><span style=color:#719e07>=</span>. ./a.out
</span></span><span style=display:flex><span>main::foo<span style=color:#719e07>()</span>
</span></span><span style=display:flex><span>eric@debian:~/resolve$ vim foo.c <span style=color:#586e75># 取消对 /* static */ 的注释</span>
</span></span><span style=display:flex><span>eric@debian:~/resolve$ gcc -fPIC -shared -o libfoo.so foo.c
</span></span><span style=display:flex><span>eric@debian:~/resolve$ gcc -fPIC main.c libfoo.so
</span></span><span style=display:flex><span>eric@debian:~/resolve$ env <span style=color:#268bd2>LD_LIBRARY_PATH</span><span style=color:#719e07>=</span>. ./a.out
</span></span><span style=display:flex><span>libfoo.so::foo<span style=color:#719e07>()</span>
</span></span></code></pre></div><p>再来一个例子，这次引用的是全局变量，而不是函数：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>eric@debian:~/resolve$ cat main.c
</span></span><span style=display:flex><span><span style=color:#586e75>#include &lt;stdio.h&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>int <span style=color:#268bd2>bar</span> <span style=color:#719e07>=</span> 4;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>int get_bar<span style=color:#719e07>(</span>void<span style=color:#719e07>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>int main<span style=color:#719e07>()</span> <span style=color:#719e07>{</span>
</span></span><span style=display:flex><span>    printf<span style=color:#719e07>(</span><span style=color:#2aa198>&#34;bar=%d\n&#34;</span>, get_bar<span style=color:#719e07>())</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>}</span>
</span></span><span style=display:flex><span>eric@debian:~/resolve$ cat bar.c
</span></span><span style=display:flex><span>int <span style=color:#268bd2>bar</span> <span style=color:#719e07>=</span> 31;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>int get_bar<span style=color:#719e07>(</span>void<span style=color:#719e07>)</span> <span style=color:#719e07>{</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> bar;
</span></span><span style=display:flex><span><span style=color:#719e07>}</span>
</span></span><span style=display:flex><span>eric@debian:~/resolve$ gcc -fPIC -shared -o libbar.so bar.c
</span></span><span style=display:flex><span>eric@debian:~/resolve$ gcc -fPIC main.c libbar.so
</span></span><span style=display:flex><span>eric@debian:~/resolve$ env <span style=color:#268bd2>LD_LIBRARY_PATH</span><span style=color:#719e07>=</span>. ./a.out
</span></span><span style=display:flex><span><span style=color:#268bd2>bar</span><span style=color:#719e07>=</span><span style=color:#2aa198>4</span>
</span></span><span style=display:flex><span>eric@debian:~/resolve$ gcc -fPIC -shared -Wl,-Bsymbolic -o libbar.so bar.c
</span></span><span style=display:flex><span>eric@debian:~/resolve$ env <span style=color:#268bd2>LD_LIBRARY_PATH</span><span style=color:#719e07>=</span>. ./a.out <span style=color:#586e75># 动态链接的优势：修改共享库之后不需要再次链接主程序</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>bar</span><span style=color:#719e07>=</span><span style=color:#2aa198>31</span>
</span></span></code></pre></div><h2 id=个人回忆>个人回忆
<a class=header-anchor href=#%e4%b8%aa%e4%ba%ba%e5%9b%9e%e5%bf%86></a></h2><p>在某个 C++ 项目中我见到过这样的代码（假设 <code>A</code> 类型不是 POD）：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span>A <span style=color:#719e07>*</span><span style=color:#268bd2>getInstance</span>() {
</span></span><span style=display:flex><span>  <span style=color:#719e07>static</span> A a;
</span></span><span style=display:flex><span>  <span style=color:#719e07>return</span> <span style=color:#719e07>&amp;</span>a;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>与使用全局变量相比有以下好处：</p><ol><li>使用函数而不是变量有更多灵活性（可以加一些副作用或者判断过程）。</li><li>由语言规范保证了全局实例 <code>a</code> 在第一次使用前被初始化。<strong>在 C++ 中，这有助于编排静态初始化的顺序</strong>，另外一个在静态初始化阶段调用此函数进行初始化的全局对象 <code>b</code> 一定是比 <code>a</code> 后初始化的。没有编排静态初始化顺序的例子见
<a href=/posts/programming/cpp/%E8%A6%81%E5%B0%8F%E5%BF%83-C++-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/ title="要小心 C++ 静态初始化顺序">要小心 C++ 静态初始化顺序</a>。</li><li>根据实现来看（可以阅读 <a href=https://godbolt.org/z/97sMbb4sb title=汇编代码 rel="noopener external nofollow noreferrer" target=_blank class=exturl>汇编代码<i class="fa fa-external-link-alt"></i></a>），<strong>函数内</strong>的静态变量有 lazy-init 的效果。写成全局变量则是在 <code>main()</code> 函数进入前就会初始化了。注意：类的方法（无论是静态还是成员方法）也有这种效果，但是类的静态属性就跟在类外定义的一样，会在程序的静态初始化阶段就进行初始化： <a href=https://godbolt.org/z/5b36e9c57 title=https://godbolt.org/z/5b36e9c57 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://godbolt.org/z/5b36e9c57<i class="fa fa-external-link-alt"></i></a> （尝试将一些调用分别修改成 0 次、1 次和 2 次，看看效果）。</li></ol><p>如果把 <code>A a;</code> 写到函数外面，在 <code>getInstance()</code> 里面返回它的指针，则同名 symbol 的风险很大。如果在外面写 <code>static A a;</code>，也会丢掉前面做法 lazy-init 的优势。</p><h1 id=控制-linker-链接到动态库还是静态库>控制 linker 链接到动态库还是静态库
<a class=header-anchor href=#%e6%8e%a7%e5%88%b6-linker-%e9%93%be%e6%8e%a5%e5%88%b0%e5%8a%a8%e6%80%81%e5%ba%93%e8%bf%98%e6%98%af%e9%9d%99%e6%80%81%e5%ba%93></a></h1><p>在静态库和动态库都能找到时，ld 会优先使用动态库。如果要强制选择静态库 / 动态库，可以：</p><ul><li>在 gcc 命令行给出路径名，如 libdemo.a。路径名可以决定性地确定文件，用动态库还是静态库当然也就确定了。</li><li>在 gcc 命令行给出 <code>-static</code> 选项（这是 gcc 的选项，不是 ld 的）。</li><li>给 ld 传入 <code>-Bstatic</code> 选项或者 <code>-Bdynamic</code> 选项（如果在 gcc 上使用则需要写成 <code>-Wl,-Bstatic</code> 或者 <code>-Wl,-Bdynamic</code>）。同一条命令行可以使用多次这样的选项，每次使用都会切换链接类型。</li></ul><p>举例：libc 同时有静态库和动态库版本：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ ls -lh <span style=color:#2aa198>&#34;</span><span style=color:#719e07>$(</span>dirname <span style=color:#2aa198>&#34;</span><span style=color:#719e07>$(</span>gcc --print-file-name libc.a<span style=color:#719e07>)</span><span style=color:#2aa198>&#34;</span><span style=color:#719e07>)</span><span style=color:#2aa198>&#34;</span>|grep <span style=color:#2aa198>&#39;libc\.&#39;</span>
</span></span><span style=display:flex><span>-rw-r--r--  <span style=color:#2aa198>1</span> root root 5.2M May  <span style=color:#2aa198>1</span> 05:07 libc.a
</span></span><span style=display:flex><span>-rw-r--r--  <span style=color:#2aa198>1</span> root root  <span style=color:#2aa198>283</span> May  <span style=color:#2aa198>1</span> 05:07 libc.so
</span></span><span style=display:flex><span>-rwxr-xr-x  <span style=color:#2aa198>1</span> root root 1.9M May  <span style=color:#2aa198>1</span> 05:07 libc.so.6
</span></span></code></pre></div><p>其中 libc.a 是静态库，libc.so.6 是动态库，libc.so 是一个链接器脚本（GNU ld script）。</p><h1 id=即使不真正依赖也强制链接>即使不真正依赖也强制链接
<a class=header-anchor href=#%e5%8d%b3%e4%bd%bf%e4%b8%8d%e7%9c%9f%e6%ad%a3%e4%be%9d%e8%b5%96%e4%b9%9f%e5%bc%ba%e5%88%b6%e9%93%be%e6%8e%a5></a></h1><p>可以给 gcc 传递 <code>-Wl,--no-as-needed</code> 保证一个共享库即使没有提供任何需要链接到的符号，也将其加入到目标文件的依赖列表中。</p><p>相反的选项是 <code>-Wl,--as-needed</code>，这也是默认行为（<code>ld</code> 的 man 手册中如是说）。</p><h1 id=符号介入>符号介入
<a class=header-anchor href=#%e7%ac%a6%e5%8f%b7%e4%bb%8b%e5%85%a5></a></h1><p>参考这个博客 <a href=https://www.bluepuni.com/archives/elf-symbols/ title=https://www.bluepuni.com/archives/elf-symbols/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://www.bluepuni.com/archives/elf-symbols/<i class="fa fa-external-link-alt"></i></a> 。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/the-linux-programming-interface>the-linux-programming-interface</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/the-linux-programming-interface/40-%E7%99%BB%E5%BD%95%E8%AE%B0%E8%B4%A6/ rel=next title="40 登录记账"><i class="fa fa-chevron-left"></i> 40 登录记账</a></div><div class="post-nav-prev post-nav-item"><a href=/the-linux-programming-interface/37-Daemon/ rel=prev title="37 Daemon">37 Daemon
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>