<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="34 进程组、会话和作业控制"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content="the-linux-programming-interface"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"34-%E8%BF%9B%E7%A8%8B%E7%BB%84%E4%BC%9A%E8%AF%9D%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6","permalink":"https://hxhue.github.io/the-linux-programming-interface/34-%E8%BF%9B%E7%A8%8B%E7%BB%84%E4%BC%9A%E8%AF%9D%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/","title":"34 进程组、会话和作业控制","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>34 进程组、会话和作业控制 - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#进程组>进程组</a><ul><li><a href=#进程组和会话的作用>进程组和会话的作用</a></li><li><a href=#进程组获取--设置的-api>进程组获取 / 设置的 API</a></li><li><a href=#在作业控制-shell-中设置进程组>在作业控制 shell 中设置进程组</a></li></ul></li><li><a href=#会话>会话</a><ul><li><a href=#获取会话-id>获取会话 ID</a></li><li><a href=#创建新的会话>创建新的会话</a></li></ul></li><li><a href=#控制终端>控制终端</a></li><li><a href=#前台和后台进程组>前台和后台进程组</a></li><li><a href=#sighup-信号>SIGHUP 信号</a><ul><li><a href=#sighup-信号在终端中的产生>SIGHUP 信号在终端中的产生</a></li><li><a href=#实验验证-shell-创建的后台进程是否会因为-shell-来不及杀而逃过一劫>实验：验证 shell 创建的后台进程是否会因为 shell 来不及杀而逃过一劫</a></li><li><a href=#1-第一次错误>1. 第一次错误</a></li><li><a href=#2-改进实验>2. 改进实验</a></li><li><a href=#3-终于搞对了>3. 终于搞对了</a></li><li><a href=#忽略-sighup-信号>忽略 SIGHUP 信号</a></li></ul></li><li><a href=#作业控制>作业控制</a><ul><li><a href=#sigcont-信号>SIGCONT 信号</a></li><li><a href=#sigttin-和-sigttou-信号>SIGTTIN 和 SIGTTOU 信号</a></li><li><a href=#sigtstp-信号>SIGTSTP 信号</a></li></ul></li><li><a href=#孤儿进程组orphaned-process-group>孤儿进程组（Orphaned Process Group）</a><ul><li><a href=#为什么要设计孤儿进程组的概念>为什么要设计孤儿进程组的概念</a></li><li><a href=#孤儿进程组和停止信号>孤儿进程组和停止信号</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/the-linux-programming-interface/34-%E8%BF%9B%E7%A8%8B%E7%BB%84%E4%BC%9A%E8%AF%9D%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="34 进程组、会话和作业控制"><meta itemprop=description content="进程组

进程组和会话的作用

进程组和会话的主要作用是 shell 的作业控制。一个以 ;（或者什么都没有）结尾的命令会启用一个前台进程组，一个以 & 结尾的命令会启用一个后台进程组。在终端（窗口环境中的控制终端实际上是一个伪终端）中键入特殊字符发送信号时，信号会发给前台进程组的中的所有进程。"></span><header class=post-header><h1 class=post-title itemprop="name headline">34 进程组、会话和作业控制</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-07-13 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-07-13 00:00:00 +0800 CST">2024-07-13
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-09-07T00:00:00+08:00 itemprop=dateModified datetime=2024-09-07T00:00:00+08:00>2024-09-07</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/the-linux-programming-interface itemprop=url rel=index><span itemprop=name>the-linux-programming-interface</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>4502</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>9分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=进程组>进程组
<a class=header-anchor href=#%e8%bf%9b%e7%a8%8b%e7%bb%84></a></h1><h2 id=进程组和会话的作用>进程组和会话的作用
<a class=header-anchor href=#%e8%bf%9b%e7%a8%8b%e7%bb%84%e5%92%8c%e4%bc%9a%e8%af%9d%e7%9a%84%e4%bd%9c%e7%94%a8></a></h2><p>进程组和会话的主要作用是 shell 的作业控制。一个以 <code>;</code>（或者什么都没有）结尾的命令会启用一个前台进程组，一个以 <code>&</code> 结尾的命令会启用一个后台进程组。在终端（窗口环境中的控制终端实际上是一个伪终端）中键入特殊字符发送信号时，信号会发给前台进程组的中的所有进程。</p><p>通常 shell 和 login(1) 会通过系统调用设置进程组和会话号。</p><h2 id=进程组获取--设置的-api>进程组获取 / 设置的 API
<a class=header-anchor href=#%e8%bf%9b%e7%a8%8b%e7%bb%84%e8%8e%b7%e5%8f%96--%e8%ae%be%e7%bd%ae%e7%9a%84-api></a></h2><p>可以通过 <code>pid_t getpgrp(void)</code> 获得当前进程的进程组 ID，通过 <code>setpgid(pid, pgid)</code> 来设置给定进程的进程组 ID。这两个函数的后缀不同，是因为历史原因。</p><p>对于 <code>setpgid</code>，如果两个参数指定了同一个进程，那么就会创建一个新的线程组；否则，指定的进程会被移动到给定的线程组中。<code>pid</code> 参数只能用来指定调用进程和其中一个子进程，而 <code>pgid</code> 参数必须是会话中的进程。另外，一个进程在子进程执行 <code>exec()</code> 之后就不能对其设置进程组 ID 了。</p><h2 id=在作业控制-shell-中设置进程组>在作业控制 shell 中设置进程组
<a class=header-anchor href=#%e5%9c%a8%e4%bd%9c%e4%b8%9a%e6%8e%a7%e5%88%b6-shell-%e4%b8%ad%e8%ae%be%e7%bd%ae%e8%bf%9b%e7%a8%8b%e7%bb%84></a></h2><p>一个任务（即一个命令或一组以管道符连接的命令）中的所有进程必须被放置在一个进程组中。实际上 shell 进程需要将其他任务的进程组号设置为第一个任务的进程号。</p><p>同时，由于我们不清楚 <code>fork()</code> 之后父子进程的调度顺序，所以我们在 <code>fork()</code> 后的父进程和子进程后都要对子进程设置进程组号，并在父进程中忽略 <code>EACCES</code> 错误（因为子进程可能已经执行了 <code>exec()</code>）。在父进程中也要设置子进程的进程组号，可能是因为父进程后面的逻辑还会依赖进程组的使用。</p><h1 id=会话>会话
<a class=header-anchor href=#%e4%bc%9a%e8%af%9d></a></h1><h2 id=获取会话-id>获取会话 ID
<a class=header-anchor href=#%e8%8e%b7%e5%8f%96%e4%bc%9a%e8%af%9d-id></a></h2><p>会话是进程组的集合。通过系统调用 <code>getsid(pid)</code> 可以获得进程号为 pid 的进程的会话号。少数系统上只有当前进程和给定的进程处于同一个会话当中时，才能获取给定进程的会话 ID，在 Linux 上没有这个限制。</p><h2 id=创建新的会话>创建新的会话
<a class=header-anchor href=#%e5%88%9b%e5%bb%ba%e6%96%b0%e7%9a%84%e4%bc%9a%e8%af%9d></a></h2><p>使用无参的 <code>setsid()</code> 函数可以创建一个新的会话。<em>这个函数在命名上有点奇怪，尽管它的名字中带有 <code>set</code>，但并不代表会用参数去设置会话 ID，反而是创建了新的会话</em>。</p><p>用 <code>setsid()</code> 创建新会话后，调用进程会成为会话和进程组中的首个进程。正因此，如果调用进程已经是进程组的首个进程，那么 <code>setsid()</code> 系统调用就会报错（设想进程组的组长都跑了，怎么对进程组正常管理呢？）。一般通过 <code>fork()</code> 之后让子进程创建新会话、退出父进程的方法来确保不会发生这样的调用错误。</p><p>创建的新会话还会和以前的控制终端断开连接，从而没有控制终端（需要以后再分配）。</p><h1 id=控制终端>控制终端
<a class=header-anchor href=#%e6%8e%a7%e5%88%b6%e7%bb%88%e7%ab%af></a></h1><p>一个会话最多可以关联一个控制终端，一个终端也最多成为一个会话的控制终端。控制终端需要由会话的首进程完成关联，这时该进程也成为终端的控制进程。控制进程通常是一个 shell。</p><ul><li>在 System V（包括 Linux）中，<mark><strong>会话首进程</strong>如果没有控制终端，在打开一个没有和其他会话关联的终端时，会将其作为会话的控制终端</mark>。在调用 <code>open()</code> 时指定 <code>O_NOCTTY</code> 标记可以防止终端成为会话的控制终端。</li><li>在 BSD 中，<strong>会话首进程</strong>可以通过 <code>ioctl(fd, TIOCSCTTY)</code> 来完成到描述符为 fd 的终端设备的关联；Linux 也支持用 <code>ioctl()</code> 来关联控制终端，但是这个操作在其他非 BSD 系统中不常见。</li></ul><p>当进程所在的会话关联有控制终端时，进程可以通过打开文件 /dev/tty 来打开其控制终端（例如，<code>getpass()</code> 函数就会打开 /dev/tty 文件）。</p><p>如果进程从会话继承了控制终端，想要和其断开连接，可以使用 <code>ioctl(fd, TIOCNOTTY)</code>。这样便不能再打开 /dev/tty 文件。</p><p>如果终端退出，那么内核会向终端的控制进程发送 SIGHUP。如果控制进程退出，那么会话（和会话中的所有进程）就会和终端断开连接，内核还会向前台进程组的所有成员发送 SIGHUP 和 SIGCONT 信号来通知控制终端的丢失。</p><h1 id=前台和后台进程组>前台和后台进程组
<a class=header-anchor href=#%e5%89%8d%e5%8f%b0%e5%92%8c%e5%90%8e%e5%8f%b0%e8%bf%9b%e7%a8%8b%e7%bb%84></a></h1><p>前台进程组可以通过标准输入 / 输出流和终端交互（这既是性质又是定义）。Shell 进程会监控前台进程组的状态，如果前台进程组完成执行，就会将自己移动到前台。</p><p>为了支持<strong>控制终端的前台进程组</strong>的切换，有以下的系统调用：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;unistd.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>pid_t</span> <span style=color:#268bd2>tcgetpgrp</span>(<span style=color:#dc322f>int</span> fd);
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>tcsetpgrp</span>(<span style=color:#dc322f>int</span> fd, <span style=color:#dc322f>pid_t</span> pgrp);
</span></span></code></pre></div><h1 id=sighup-信号>SIGHUP 信号
<a class=header-anchor href=#sighup-%e4%bf%a1%e5%8f%b7></a></h1><h2 id=sighup-信号在终端中的产生>SIGHUP 信号在终端中的产生
<a class=header-anchor href=#sighup-%e4%bf%a1%e5%8f%b7%e5%9c%a8%e7%bb%88%e7%ab%af%e4%b8%ad%e7%9a%84%e4%ba%a7%e7%94%9f></a></h2><p>首先，<strong>终端断开时，控制进程会收到 SIGHUP 信号和 SIGCONT 信号</strong>。而 shell（常作为终端的控制进程）会注册信号处理器，从而在退出前将 SIGHUP 发给它创建的各个任务。信号只会发送给 shell 所在的进程组，如果有任务将自己转移到了新的进程组（比如使用 <code>setpgid(0, 0)</code>），即便是在同一会话中也不会收到 shell 发来的 SIGHUP 信号。</p><blockquote><p>举例：终端驱动器检测到连接断开（调制解调器或终端行上的信号丢失）；关闭终端窗口，与该窗口关联的伪终端的文件描述符随之关闭。</p></blockquote><p>其次，<strong>如果控制进程终止了，内核就会将 SIGHUP（和一个 SIGCONT，Linux 会这样做，但是 SUSv3 没规定）发给前台进程组的所有进程</strong>。这里不管控制进程终止的原因，它可以是正常退出，也可能是因为处理了 SIGHUP 后退出的。书上的原句：</p><blockquote><p>If the controlling process terminates for any reason, then the foreground process group is signaled with SIGHUP.</p></blockquote><p>一些 shell 在退出时也会向后台任务（而不只是前台任务）发送 SIGHUP，比如 bash 和 Korn shell。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>终端断开  ---&gt;  内核给控制进程发 SIGHUP
</span></span><span style=display:flex><span>                      |
</span></span><span style=display:flex><span>                      | 可能导致
</span></span><span style=display:flex><span>                      ▼ 
</span></span><span style=display:flex><span>                  控制进程终止   ---&gt;  内核给前台进程组发 SIGHUP
</span></span><span style=display:flex><span>                      |
</span></span><span style=display:flex><span>                      |
</span></span><span style=display:flex><span>                      ▼
</span></span><span style=display:flex><span>如果是 shell 正常退出（exit/^D）或者优雅退出（处理 SIGHUP 信号），
</span></span><span style=display:flex><span>它还会给它管理的进程（同一个进程组）发 SIGHUP。
</span></span></code></pre></div><h2 id=实验验证-shell-创建的后台进程是否会因为-shell-来不及杀而逃过一劫>实验：验证 shell 创建的后台进程是否会因为 shell 来不及杀而逃过一劫
<a class=header-anchor href=#%e5%ae%9e%e9%aa%8c%e9%aa%8c%e8%af%81-shell-%e5%88%9b%e5%bb%ba%e7%9a%84%e5%90%8e%e5%8f%b0%e8%bf%9b%e7%a8%8b%e6%98%af%e5%90%a6%e4%bc%9a%e5%9b%a0%e4%b8%ba-shell-%e6%9d%a5%e4%b8%8d%e5%8f%8a%e6%9d%80%e8%80%8c%e9%80%83%e8%bf%87%e4%b8%80%e5%8a%ab></a></h2><p>问题：如果 shell 有后台进程，我们向 shell 发送 SIGKILL 终止它，它没有机会发送 SIGHUP，而内核只会向控制终端的前台进程组发送 SIGHUP，这是否会让 shell 之前创建的后台进程得到保留？</p><h2 id=1-第一次错误>1. 第一次错误
<a class=header-anchor href=#1-%e7%ac%ac%e4%b8%80%e6%ac%a1%e9%94%99%e8%af%af></a></h2><p>错误的实验方法：为了防止 shell 直接被杀没了，我使用 <code>bash</code> 命令再次进入 bash，在其中运行 <code>sleep 1000</code>，杀掉 bash 本身之后，sleep 进程被 init 收养。不过奇怪的是，这个 init 的命令是 /init，进程号为 211。而进程号为 1 的进程同样是 init，命令是 /sbin/init。用 <code>ps -p 212 -o pid,ppid,cmd</code> 这样的方法重复几次发现有一条 211 -> 210 -> 2 -> 1 的进程链，后者为前者的父进程，而沿途的进程名都是 init。</p><p>这个实验的错误之处在于：我杀掉的 bash 不属于控制终端。不过还是能从中得出这样的结论，即控制进程还在，父进程被杀了，子进程会被 init 收养，而且负责收养的 init 进程并不一定是 1 号进程。这个可能和 wsl 内核的实现有关系，见 <a href=https://github.com/microsoft/WSL/issues/5176 title="issue 5176" rel="noopener external nofollow noreferrer" target=_blank class=exturl>issue 5176<i class="fa fa-external-link-alt"></i></a>。</p><h2 id=2-改进实验>2. 改进实验
<a class=header-anchor href=#2-%e6%94%b9%e8%bf%9b%e5%ae%9e%e9%aa%8c></a></h2><p>我现在直接拿 wsl 的登陆 shell 做测试，开了两个终端。其中一个终端运行 <code>sleep 1000</code>，另外一个终端杀死前一个终端的 shell，结果 sleep 进程作为前台进程组的一员也被杀掉了，这符合预期。然后用同样的方法让终端 1 运行 <code>sleep 1000 &</code>，终端 2 杀死终端 1 的 shell（也是终端的控制进程），结果 sleep 作为后台进程组的一员也被杀了。这是为什么？</p><p>我后来发现我查找进程的方式有错误。我之前使用的是 <code>ps a</code> 来列举 wsl 下的进程（因为 wsl 没有运行桌面环境，所以进程数很少，一页就能列完），但是 <code>ps a</code> 只能列举出和终端关联的进程。网页 <a href=https://unix.stackexchange.com/a/106848/ title=https://unix.stackexchange.com/a/106848/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://unix.stackexchange.com/a/106848/<i class="fa fa-external-link-alt"></i></a> 中有这样的信息：</p><blockquote><p>a = show processes for all users
u = display the process&rsquo;s user/owner
x = <strong>also show processes not attached to a terminal</strong></p></blockquote><p>实际上 <code>ps</code> 似乎是只能列出当前会话的进程，而 <code>ps a</code> 可以列出所有会话的进程。我开了 2 个 wsl 终端，登陆的是同一个用户，所以说 <code>a</code> 选项的用户应该不是“Linux 用户”的意思。</p><h2 id=3-终于搞对了>3. 终于搞对了
<a class=header-anchor href=#3-%e7%bb%88%e4%ba%8e%e6%90%9e%e5%af%b9%e4%ba%86></a></h2><p>使用 <code>ps aux</code> 就能发现之前的 sleep 进程了。同样追溯一下它的父进程，有 <code>886600 (sleep) -> 886529 (/init) -> 1 (/sbin/init)</code> 的父进程链（可能和 wsl 有关）。</p><h2 id=忽略-sighup-信号>忽略 SIGHUP 信号
<a class=header-anchor href=#%e5%bf%bd%e7%95%a5-sighup-%e4%bf%a1%e5%8f%b7></a></h2><p>nohup(1) 创建的进程会忽略 SIGHUP。</p><p>Bash 内置的 <code>disown</code> 命令则可以将一个任务从 shell 的任务列表中删除，这样 shell 在退出时就不会给这个任务发送信号了。为了避免内核向这个任务发送信号，这个任务必须是后台任务。</p><h1 id=作业控制>作业控制
<a class=header-anchor href=#%e4%bd%9c%e4%b8%9a%e6%8e%a7%e5%88%b6></a></h1><h2 id=sigcont-信号>SIGCONT 信号
<a class=header-anchor href=#sigcont-%e4%bf%a1%e5%8f%b7></a></h2><p>一般来说，非特权进程只有在<strong>真实</strong>或<strong>有效用户 ID</strong> 和另外一个进程的<strong>真实</strong>或<strong>保存的设置用户 ID</strong>（saved set-user-ID）相等时，才能向它发送信号。但是 SIGCONT 是个特例，如果目标进程和当前进程处在同一个会话中，也可以发送。因为用户可能会运行一个 set-user-ID 程序并改变进程的真实用户 ID，但我们仍需要用终端控制它。</p><h2 id=sigttin-和-sigttou-信号>SIGTTIN 和 SIGTTOU 信号
<a class=header-anchor href=#sigttin-%e5%92%8c-sigttou-%e4%bf%a1%e5%8f%b7></a></h2><p>后台任务读取终端就会收到 SIGTTIN 信号而停止（stop，可以被恢复），但它们仍然是可以写终端的。如果还想禁止后台任务写终端，可以给终端设置 TOSTOP 标志，这样它们写终端时就会收到 SIGTTOU 信号而停止。</p><p>对于后台任务，<strong>如果阻塞或者忽略了 STGTTIN 或 SIGTTOU，对应的信号就不会发送</strong>（这样应该也不会产生 pending 的信号？）：</p><ul><li>如果阻塞或者忽略了 SIGTTIN，<code>read()</code> 该失败的时候还是会失败，但是程序不会停止。</li><li>如果阻塞或者忽略了 SIGTTOU，<code>write()</code> 和其他尝试修改控制终端属性的操作（比如 <code>tcsetpgrp()</code> / <code>tcsetattr()</code> / <code>tcflush()</code> 等）会成功。</li></ul><h2 id=sigtstp-信号>SIGTSTP 信号
<a class=header-anchor href=#sigtstp-%e4%bf%a1%e5%8f%b7></a></h2><p>Screen-handling 程序（如 <code>vi</code> 和 <code>less</code>）要正确处理 SIGTSTP 信号，因为它们会改变终端的一些设置（比如光标和显示方式），所以在被停止前要将这些设置恢复。</p><p>信号处理器的操作顺序有一些讲究（英文书 P724）：</p><ol><li>保存 <code>errno</code>。</li><li><u>完成信号处理</u>。</li><li>将 SIGTSTP 的信号处理方式恢复成默认。</li><li>用 <code>raise()</code> 给自己发送 SIGTSTP 信号。</li><li>修改信号掩码，允许发送 SIGTSTP 信号。因为上一步已经发送了信号，这一步在返回之前就会收到信号而暂停程序执行。</li><li>程序恢复后，<strong>立即再次阻塞 SIGTSTP 信号</strong>。不用解开阻塞，因为信号处理器的调用者在处理这个信号的时候就会保存信号掩码，并在信号处理器函数返回时恢复信号掩码。</li><li>再次注册当前的信号处理函数。</li><li>恢复 <code>errno</code>。</li></ol><p>注册 SIGTSTP 信号处理器时：</p><ol><li>先获取旧的信号处理器，看看旧的信号处理器是不是 SIG_IGN。如果是，则可能表示父进程希望我们不注册信号处理器（<em>this prevents an application from attempting to handle these signals if it is started from a non-job-control shell</em>）。这是一条通则，即我们应该尊重父进程对信号的忽略。比如在没有作业控制的 shell 中，用来表示后台任务时可能也会把 SIGINT 和 SIGTERM 的忽略方式设置为 SIG_IGN；用户可能会使用 nohup(1) 让进程忽略 SIGHUP 信号。</li><li><code>sa.sa_flags</code> 还有个 <code>SA_RESTART</code> 标志，这是因为我们希望接收到 SIGTSTP 信号而中断执行的系统调用能够自动重启。</li></ol><div class="markdown-alert markdown-alert-note"><p class=markdown-alert-title><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>Note</p><p>如果第 6 步阻塞 SIGTSTP（即便时间间隔已经非常短了）还是晚于另外一个 SIGTSTP 信号的接收，那么程序又会再次进入暂停状态。</p></div><h1 id=孤儿进程组orphaned-process-group>孤儿进程组（Orphaned Process Group）
<a class=header-anchor href=#%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b%e7%bb%84orphaned-process-group></a></h1><p>一个进程组不是孤儿进程组当且仅当它至少有一个进程的父进程在不同的进程组，但是在同一个会话中。（ 对于一般的 shell 任务进程组，每个进程的父进程是 shell，这就满足了在不同的进程组、但是在同一个会话中的条件，所以不是孤儿。）</p><p>根据定义，一个 session leader 处在孤儿进程组中，因为 <code>setsid()</code> 会创建一个新会话和新进程组。</p><h2 id=为什么要设计孤儿进程组的概念>为什么要设计孤儿进程组的概念
<a class=header-anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%ae%be%e8%ae%a1%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b%e7%bb%84%e7%9a%84%e6%a6%82%e5%bf%b5></a></h2><p>假设 shell 创建了一个任务，这个任务有个父进程创建了子进程，随后父进程退出，子进程继续运行。这个时候 shell 不知道子进程的存在（因为子进程不是由 shell 创建的），所以 shell 不可能去管理这个子进程。这个子进程就成了孤儿、被 init 收养，这个子进程所在的进程组也成了孤儿进程组。</p><p>即便孤儿进程组中一个被停止的进程有一个仍然存活但是处于不同会话中的父进程，这个父进程也会因为信号发送限制不能跨会话向其发送 SIGCONT 信号，导致无法将子进程从停止状态恢复。</p><p>因此，孤儿进程组的进程实际上是没有进程管得了（或者说知道要去管理）的状态。设计了孤儿进程组的概念之后，内核可以在进程组成为孤儿进程组时，检查是否有进程是停止状态，如果有则向孤儿进程组中的成员发送 SIGHUP 和 SIGCONT。（如果没有进程是停止状态，则不会发送这些信号。）</p><h2 id=孤儿进程组和停止信号>孤儿进程组和停止信号
<a class=header-anchor href=#%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b%e7%bb%84%e5%92%8c%e5%81%9c%e6%ad%a2%e4%bf%a1%e5%8f%b7></a></h2><p>因为孤儿进程组没有进程去管，所以内核不希望其中的进程停止，在父进程退出时检查到进程组变成孤儿、且有进程在停止状态时会发送 SIGHUP 和 SIGCONT 也是这个原因。</p><p>那如果有信号会把孤儿进程组中的进程停止呢？这个时候内核会避免发送 SIGTTIN 和 SIGTTOU 信号，比如 <code>read()</code> 和 <code>write()</code> 失败时不发送这些信号，而是返回 EIO 错误。同样，如果孤儿进程组中的进程还是收到了停止信号，信号会悄无声息被丢弃。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/the-linux-programming-interface>the-linux-programming-interface</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/the-linux-programming-interface/35-%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6/ rel=next title="35 进程优先级与实时调度"><i class="fa fa-chevron-left"></i> 35 进程优先级与实时调度</a></div><div class="post-nav-prev post-nav-item"><a href=/the-linux-programming-interface/29.3-%E7%94%A8-kill-%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%E7%BB%99%E7%89%B9%E5%AE%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B0%9D%E8%AF%95/ rel=prev title="29.3 用 `kill` 发送信号给特定线程的尝试">29.3 用 `kill` 发送信号给特定线程的尝试
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>