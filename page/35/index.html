<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Bluegill"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content><meta name=google-site-verification content="hwfud_ndcnJHe2Jz7ClToP1nuUA3k7FqZv-0VpFAHjg"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":true,"isPage":false,"path":"hxhue.github.io","permalink":"https://hxhue.github.io/","title":"Bluegill","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class="hvr-icon-pulse menu-item-active" rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/cpp/cppreference-%E5%8D%8F%E7%A8%8B%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="cppreference 协程例子理解"><meta itemprop=description content="我的理解是：C++ 的协程是无栈的，这意味着协程只是计算任务，仅在运行时需要栈，在 suspend 之后就会保存状态并脱离栈。要想要跨线程转移计算任务（比如实现工作窃取池），只需要将离栈协程在另外一个线程上 resume 即可。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/programming/cpp/cppreference-%E5%8D%8F%E7%A8%8B%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3/ itemprop=url class=post-title-link>cppreference 协程例子理解</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-04-08T00:00:00+08:00 itemprop=dateModified datetime=2024-04-08T00:00:00+08:00>2024-04-08</time></span></div></div></header><div class=post-body itemprop=articleBody><p>我的理解是：C++ 的协程是无栈的，这意味着协程只是计算任务，仅在运行时需要栈，在 suspend 之后就会保存状态并脱离栈。要想要跨线程转移计算任务（比如实现工作窃取池），只需要将离栈协程在另外一个线程上 resume 即可。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;coroutine&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;iostream&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdexcept&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;thread&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#719e07>auto</span> <span style=color:#268bd2>switch_to_new_thread</span>(std<span style=color:#719e07>::</span>jthread<span style=color:#719e07>&amp;</span> out)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#719e07>struct</span> <span style=color:#268bd2>awaitable</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#719e07>::</span>jthread<span style=color:#719e07>*</span> p_out;
</span></span><span style=display:flex><span>        <span style=color:#dc322f>bool</span> await_ready() { <span style=color:#719e07>return</span> <span style=color:#b58900>false</span>; }
</span></span><span style=display:flex><span>        <span style=color:#dc322f>void</span> await_suspend(std<span style=color:#719e07>::</span>coroutine_handle<span style=color:#719e07>&lt;&gt;</span> h)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            std<span style=color:#719e07>::</span>jthread<span style=color:#719e07>&amp;</span> out <span style=color:#719e07>=</span> <span style=color:#719e07>*</span>p_out;
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (out.joinable())
</span></span><span style=display:flex><span>                <span style=color:#719e07>throw</span> std<span style=color:#719e07>::</span>runtime_error(<span style=color:#2aa198>&#34;Output jthread parameter not empty&#34;</span>);
</span></span><span style=display:flex><span>            out <span style=color:#719e07>=</span> std<span style=color:#719e07>::</span>jthread([h] { h.resume(); });
</span></span><span style=display:flex><span>            <span style=color:#586e75>// Potential undefined behavior: accessing potentially destroyed *this
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>            <span style=color:#586e75>// std::cout &lt;&lt; &#34;New thread ID: &#34; &lt;&lt; p_out-&gt;get_id() &lt;&lt; &#39;\n&#39;;
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>            std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#34;New thread ID: &#34;</span> <span style=color:#719e07>&lt;&lt;</span> out.get_id() <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#39;\n&#39;</span>; <span style=color:#586e75>// this is OK
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        }
</span></span><span style=display:flex><span>        <span style=color:#dc322f>void</span> await_resume() {}
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> awaitable{<span style=color:#719e07>&amp;</span>out};
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>struct</span> <span style=color:#268bd2>task</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#719e07>struct</span> <span style=color:#268bd2>promise_type</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        task <span style=color:#268bd2>get_return_object</span>() { <span style=color:#719e07>return</span> {}; }
</span></span><span style=display:flex><span>        std<span style=color:#719e07>::</span>suspend_never initial_suspend() { <span style=color:#719e07>return</span> {}; }
</span></span><span style=display:flex><span>        std<span style=color:#719e07>::</span>suspend_never final_suspend() <span style=color:#719e07>noexcept</span> { <span style=color:#719e07>return</span> {}; }
</span></span><span style=display:flex><span>        <span style=color:#dc322f>void</span> <span style=color:#268bd2>return_void</span>() {}
</span></span><span style=display:flex><span>        <span style=color:#dc322f>void</span> <span style=color:#268bd2>unhandled_exception</span>() {}
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>task <span style=color:#268bd2>resuming_on_new_thread</span>(std<span style=color:#719e07>::</span>jthread<span style=color:#719e07>&amp;</span> out)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#34;Coroutine started on thread: &#34;</span> <span style=color:#719e07>&lt;&lt;</span> std<span style=color:#719e07>::</span>this_thread<span style=color:#719e07>::</span>get_id() <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#719e07>co_await</span> switch_to_new_thread(out);
</span></span><span style=display:flex><span>    <span style=color:#586e75>// awaiter destroyed here
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#34;Coroutine resumed on thread: &#34;</span> <span style=color:#719e07>&lt;&lt;</span> std<span style=color:#719e07>::</span>this_thread<span style=color:#719e07>::</span>get_id() <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>jthread out;
</span></span><span style=display:flex><span>    resuming_on_new_thread(out);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可能结果：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>Coroutine started on thread: 139972277602112
</span></span><span style=display:flex><span>New thread ID: 139972267284224
</span></span><span style=display:flex><span>Coroutine resumed on thread: 139972267284224
</span></span></code></pre></div><p><img src=/assets/cpp_coroutine_resuming_on_new_thread%20(1).svg></p></div><footer class=post-footer><div readmore=false><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/programming/cpp/cppreference-%E5%8D%8F%E7%A8%8B%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/01-Function-Templates/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 01 Function Templates"><meta itemprop=description content="2023 年 5 月 7 日
两个 type traits

std::decay_t 可以去引用、去限定符、函数/数组变指针；std::common_type_t 用三元运算符获得更“宽泛”类型。
函数模板默认参数

模板默认参数可以放在最前面，不像普通函数只能把带有默认值的参数放在最后。而且函数模板可以明确指定开头几个参数，让后面的参数由推导规则生成。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/01-Function-Templates/ itemprop=url class=post-title-link>CTTCG 01 Function Templates</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-04-08T00:00:00+08:00 itemprop=dateModified datetime=2024-04-08T00:00:00+08:00>2024-04-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>2023 年 5 月 7 日</p><h1 id=两个-type-traits>两个 type traits
<a class=header-anchor href=#%e4%b8%a4%e4%b8%aa-type-traits></a></h1><p><code>std::decay_t</code> 可以去引用、去限定符、函数/数组变指针；<code>std::common_type_t</code> 用三元运算符获得更“宽泛”类型。</p><h1 id=函数模板默认参数>函数模板默认参数
<a class=header-anchor href=#%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0></a></h1><p>模板默认参数可以放在最前面，不像普通函数只能把带有默认值的参数放在最后。而且函数模板可以明确指定开头几个参数，让后面的参数由推导规则生成。</p><h1 id=函数重载参数匹配优先级>函数重载参数匹配优先级
<a class=header-anchor href=#%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd%e5%8f%82%e6%95%b0%e5%8c%b9%e9%85%8d%e4%bc%98%e5%85%88%e7%ba%a7></a></h1><h2 id=优先级排序>优先级排序
<a class=header-anchor href=#%e4%bc%98%e5%85%88%e7%ba%a7%e6%8e%92%e5%ba%8f></a></h2><ol><li>perfect match</li><li>decay，或者修改指针的内外层 const 属性（volatile 应该也算吧？）
比如 <code>char *</code> 到 <code>char const *</code></li><li>promotion，比 int 小的转到 int 或更大的整数，或者 float 到 double。
举例：bool 到 char 不是 promotion，而是 standard conversion</li><li>standard conversion，包括 <strong>int to float</strong>，<strong>子类（值/引用/指针）向基类（值/引用/指针）转换</strong></li><li>用户定义的转换，包括标准库的类</li><li>与可变长参数列表匹配，也就是 <code>(...)</code>
例外：<code>f(...)</code> <strong>和</strong> <code>f(void)</code> <strong>参数类型是同级别的</strong>，因为没有提供参数，编译器不知道哪一个匹配更合适。</li></ol><p>以上参数匹配<strong>不涉及到值类型、左引用、右引用的区别</strong>。只要引用属性能够匹配，就不区分优先级。比如同时匹配到 <code>f(int)</code> 和 <code>f(int &)</code> 编译器就会抱怨函数调用 ambiguous。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/01-Function-Templates/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/02-Class-Templates/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 02 Class Templates"><meta itemprop=description content="2023 年 5 月 7 日
定义位置

类模板只能在全局或者类声明中定义，不能在块或者函数中定义。
类模板外函数定义的写法

类模板中定义函数，T 类型参数可以省略；在类模板中声明，但在外提供函数定义，就需要在定义处给出完整的类型参数："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/02-Class-Templates/ itemprop=url class=post-title-link>CTTCG 02 Class Templates</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>2023 年 5 月 7 日</p><h1 id=定义位置>定义位置
<a class=header-anchor href=#%e5%ae%9a%e4%b9%89%e4%bd%8d%e7%bd%ae></a></h1><p>类模板只能在全局或者类声明中定义，不能在块或者函数中定义。</p><h1 id=类模板外函数定义的写法>类模板外函数定义的写法
<a class=header-anchor href=#%e7%b1%bb%e6%a8%a1%e6%9d%bf%e5%a4%96%e5%87%bd%e6%95%b0%e5%ae%9a%e4%b9%89%e7%9a%84%e5%86%99%e6%b3%95></a></h1><p>类模板中定义函数，T 类型参数可以省略；在类模板中声明，但在外提供函数定义，就需要在定义处给出完整的类型参数：</p><p><code>template&lt;typename T> void Stack&lt;T /* 不能省略 */>::push (T const& elem) { /* impl */ }</code></p><p>一个例外是析构函数和构造函数的名称处，因为这里不表类型，而是表示函数名。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/02-Class-Templates/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/03-Nontype-Template-Parameters/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 03 Nontype Template Parameters"><meta itemprop=description content="模板参数也可以不是类型，而是值。
非类型参数推导只对直接调用有效

模板函数的类型推导只对立即调用有效，而对算法模板这类需要提前知道类型信息的场合无效。比如：
std::transform (source.begin(), source.end(), // start and end of source
                dest.begin(),     // start of destination
                addValue<5,int>); // operation
上面代码中尽管 addValue 的参数可能可以推导出来，但由于 std::transform 要求提前知道函数的类型，去掉参数之后代码无法编译。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/03-Nontype-Template-Parameters/ itemprop=url class=post-title-link>CTTCG 03 Nontype Template Parameters</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>模板参数也可以不是类型，而是值。</p><h1 id=非类型参数推导只对直接调用有效>非类型参数推导只对直接调用有效
<a class=header-anchor href=#%e9%9d%9e%e7%b1%bb%e5%9e%8b%e5%8f%82%e6%95%b0%e6%8e%a8%e5%af%bc%e5%8f%aa%e5%af%b9%e7%9b%b4%e6%8e%a5%e8%b0%83%e7%94%a8%e6%9c%89%e6%95%88></a></h1><p>模板函数的类型推导只对立即调用有效，而对算法模板这类需要提前知道类型信息的场合无效。比如：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#719e07>::</span>transform (source.begin(), source.end(), <span style=color:#586e75>// start and end of source
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                dest.begin(),     <span style=color:#586e75>// start of destination
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                addValue<span style=color:#719e07>&lt;</span><span style=color:#2aa198>5</span>,<span style=color:#dc322f>int</span><span style=color:#719e07>&gt;</span>); <span style=color:#586e75>// operation
</span></span></span></code></pre></div><p>上面代码中尽管 <code>addValue</code> 的参数可能可以推导出来，但由于 <code>std::transform</code> 要求提前知道函数的类型，去掉参数之后代码无法编译。</p><h1 id=非类型参数的类型限制>非类型参数的类型限制
<a class=header-anchor href=#%e9%9d%9e%e7%b1%bb%e5%9e%8b%e5%8f%82%e6%95%b0%e7%9a%84%e7%b1%bb%e5%9e%8b%e9%99%90%e5%88%b6></a></h1><p><strong>非类型参数不能是浮点数（未来可能可以）。只能是整数、nullptr、指针或左值引用。</strong></p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/03-Nontype-Template-Parameters/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/04-Variadic-Templates/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 04 Variadic Templates"><meta itemprop=description content="
  可变长表达式可以对参数包逐个处理。与折叠表达式（相当于函数式编程中的 reduce，但如果用上逗号表达式就能表达 foreach）不同，可变长表达式（相当于函数式编程中的 map）不会改变参数数量，允许的形式也比折叠表达式宽松一点。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/04-Variadic-Templates/ itemprop=url class=post-title-link>CTTCG 04 Variadic Templates</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-05-14T00:00:00+08:00 itemprop=dateModified datetime=2024-05-14T00:00:00+08:00>2024-05-14</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><blockquote><p>可变长表达式可以对参数包逐个处理。与折叠表达式（相当于函数式编程中的 <strong>reduce</strong>，但如果用上逗号表达式就能表达 <strong>foreach</strong>）不同，可变长表达式（相当于函数式编程中的 <strong>map</strong>）不会改变参数数量，允许的形式也比折叠表达式宽松一点。</p></blockquote><h1 id=参数包parameter-pack和可变长模板>参数包（Parameter Pack）和可变长模板
<a class=header-anchor href=#%e5%8f%82%e6%95%b0%e5%8c%85parameter-pack%e5%92%8c%e5%8f%af%e5%8f%98%e9%95%bf%e6%a8%a1%e6%9d%bf></a></h1><p>模板函数可以指定参数包，用 <code>sizeof…()</code> 运算符可以获得参数包的数量。<strong>至少有一个参数包的模板称为可变长模板（variadic template）</strong>。</p><h2 id=0-pack-expansion参数传递>0 Pack Expansion：参数传递
<a class=header-anchor href=#0-pack-expansion%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92></a></h2><p>参数传递。</p><div class="markdown-alert markdown-alert-note"><p class=markdown-alert-title><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>Note</p><p>2024 年 2 月 20 日：除了作为函数参数之外，还能用作初始化列表（花括号）的参数。</p></div><h2 id=1-递归逐个处理>1 递归：逐个处理
<a class=header-anchor href=#1-%e9%80%92%e5%bd%92%e9%80%90%e4%b8%aa%e5%a4%84%e7%90%86></a></h2><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;iostream&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span><span style=color:#dc322f>void</span> <span style=color:#268bd2>print</span> ()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T, <span style=color:#719e07>typename</span>... Types<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> print (T firstArg, Types... args)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> firstArg <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#39;\n&#39;</span>; <span style=color:#586e75>// print first argument
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    print(args...);                <span style=color:#586e75>// call print() for remaining arguments
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/04-Variadic-Templates/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/05-Tricky-Basics/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 05 Tricky Basics"><meta itemprop=description content="1 使用关键字引导编译器了解成员类型

template<typename T>
class MyClass {
public:
    void foo() {
        typename T::SubType* ptr;
    }
}
上面的的代码中加了 typename 关键字用来表示 SubType 这个成员是一个类型。否则由于缺乏类型信息，编译器会认为该成员是某个数据域，从而构成了乘法表达式。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/05-Tricky-Basics/ itemprop=url class=post-title-link>CTTCG 05 Tricky Basics</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-03-08T00:00:00+08:00 itemprop=dateModified datetime=2025-03-08T00:00:00+08:00>2025-03-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1-使用关键字引导编译器了解成员类型>1 使用关键字引导编译器了解成员类型
<a class=header-anchor href=#1-%e4%bd%bf%e7%94%a8%e5%85%b3%e9%94%ae%e5%ad%97%e5%bc%95%e5%af%bc%e7%bc%96%e8%af%91%e5%99%a8%e4%ba%86%e8%a7%a3%e6%88%90%e5%91%98%e7%b1%bb%e5%9e%8b></a></h1><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>MyClass</span> {
</span></span><span style=display:flex><span><span style=color:#719e07>public</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>    <span style=color:#dc322f>void</span> foo() {
</span></span><span style=display:flex><span>        <span style=color:#719e07>typename</span> T<span style=color:#719e07>::</span>SubType<span style=color:#719e07>*</span> ptr;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的的代码中加了 <code>typename</code> 关键字用来表示 <code>SubType</code> 这个成员是一个类型。否则由于缺乏类型信息，编译器会认为该成员是某个数据域，从而构成了乘法表达式。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> N<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> printBitset (std<span style=color:#719e07>::</span>bitset<span style=color:#719e07>&lt;</span>N<span style=color:#719e07>&gt;</span> <span style=color:#719e07>const</span><span style=color:#719e07>&amp;</span> bs) {
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> bs.<span style=color:#719e07>template</span> to_string<span style=color:#719e07>&lt;</span><span style=color:#dc322f>char</span>, std<span style=color:#719e07>::</span>char_traits<span style=color:#719e07>&lt;</span><span style=color:#dc322f>char</span><span style=color:#719e07>&gt;</span>, std<span style=color:#719e07>::</span>allocator<span style=color:#719e07>&lt;</span><span style=color:#dc322f>char</span><span style=color:#719e07>&gt;&gt;</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的 template 关键字在 <code>to_string</code> 前作解释，表示 <code>to_string</code> 是一个函数模板，否则后面的尖括号会被认为是小于运算符，而不是函数模板参数的开始标志。</p><h1 id=2-正确初始化模板类的成员>2 正确初始化模板类的成员
<a class=header-anchor href=#2-%e6%ad%a3%e7%a1%ae%e5%88%9d%e5%a7%8b%e5%8c%96%e6%a8%a1%e6%9d%bf%e7%b1%bb%e7%9a%84%e6%88%90%e5%91%98></a></h1><p>在模板类中为了保证成员被正确初始化，应该使用 {} 初始化的语法，因为无论 T 是什么类型，这种初始化方式都是可行的。此外 {} 也能用在数据成员定义处，或者构造函数初始化列表中：</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/05-Tricky-Basics/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/06-Move-Semantics-and-enable_if/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 06 Move Semantics and enable_if"><meta itemprop=description content="Perfect forwarding:
template<typename T>
void f (T&& val) {
    g(std::forward<T>(val)); // perfect forward val to g()
}
注意，完美转发只对模板参数有效，对依赖于模板参数的类型也是无效的，比如：typename T::iterator&& 是无效的，仍表示严格的右值引用。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/06-Move-Semantics-and-enable_if/ itemprop=url class=post-title-link>CTTCG 06 Move Semantics and enable_if</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>Perfect forwarding:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> f (T<span style=color:#719e07>&amp;&amp;</span> val) {
</span></span><span style=display:flex><span>    g(std<span style=color:#719e07>::</span>forward<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span>(val)); <span style=color:#586e75>// perfect forward val to g()
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>注意，完美转发只对模板参数有效，对依赖于模板参数的类型也是无效的，比如：<code>typename T::iterator&&</code> 是无效的，仍表示严格的右值引用。</p><p>完美转发也不能加 const 属性。添加 const 属性后表示常右值引用（而且这种形式很少被使用）。</p><h1 id=尝试用完美转发简化代码>尝试用完美转发简化代码
<a class=header-anchor href=#%e5%b0%9d%e8%af%95%e7%94%a8%e5%ae%8c%e7%be%8e%e8%bd%ac%e5%8f%91%e7%ae%80%e5%8c%96%e4%bb%a3%e7%a0%81></a></h1><p>设想一个 Person 类，里面只有一个 <code>std::string</code> 类型的 name 数据。已经实现了复制构造函数和移动构造函数。从数据的构造函数有 <code>std::string &&</code> 和 <code>std::string const &</code> 两个重载版本。使用完美转发可以同时写出匹配这两种参数的函数模板，减少代码量。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/06-Move-Semantics-and-enable_if/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/07-By-Value-or-by-Reference/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 07 By Value or by Reference"><meta itemprop=description content="传值：T

有 decay。
传左值引用：T &

注意遇到数组时可能需要 decay。
注意 T 类型可能是常量，导致 T & 其实是常引用。这样的参数不能被修改，因而不能作为传出参数。可以使用 concept 限定参数非常量："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/07-By-Value-or-by-Reference/ itemprop=url class=post-title-link>CTTCG 07 By Value or by Reference</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-04-08T00:00:00+08:00 itemprop=dateModified datetime=2024-04-08T00:00:00+08:00>2024-04-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=传值t>传值：<code>T</code>
<a class=header-anchor href=#%e4%bc%a0%e5%80%bct></a></h1><p>有 decay。</p><h1 id=传左值引用t->传左值引用：<code>T &</code>
<a class=header-anchor href=#%e4%bc%a0%e5%b7%a6%e5%80%bc%e5%bc%95%e7%94%a8t-></a></h1><p>注意遇到数组时可能需要 decay。</p><p>注意 <code>T</code> 类型可能是常量，导致 <code>T &</code> 其实是常引用。这样的参数不能被修改，因而不能作为传出参数。可以使用 concept 限定参数非常量：</p><p><img src=/assets/e66f40f02b68770a1db6edfa2aed29f9.webp></p><h1 id=传转发引用t->传转发引用：<code>T &&</code>
<a class=header-anchor href=#%e4%bc%a0%e8%bd%ac%e5%8f%91%e5%bc%95%e7%94%a8t-></a></h1><p>这是 T 唯一可能匹配到引用类型的情况。如果 T 本身就是引用类型，就不能用它创建值类型的同类数据。解决方法有：① 用 type traits 去除引用属性 ② 使用 auto，因为 auto 默认不会匹配到引用。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/07-By-Value-or-by-Reference/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/08-Compile-Time-Programming/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 08 Compile-Time Programming"><meta itemprop=description content="模板元编程

略。
constexpr 函数

在 C++11 中只能使用一条语句，而在 C++14 之后可以使用的语句变得丰富。constexpr 函数允许编译期优化，但不阻止运行期使用。作为对比，C++20 consteval 只能在编译期使用。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/08-Compile-Time-Programming/ itemprop=url class=post-title-link>CTTCG 08 Compile-Time Programming</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-04-08T00:00:00+08:00 itemprop=dateModified datetime=2024-04-08T00:00:00+08:00>2024-04-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=模板元编程>模板元编程
<a class=header-anchor href=#%e6%a8%a1%e6%9d%bf%e5%85%83%e7%bc%96%e7%a8%8b></a></h1><p>略。</p><h1 id=constexpr-函数><code>constexpr</code> 函数
<a class=header-anchor href=#constexpr-%e5%87%bd%e6%95%b0></a></h1><p>在 C++11 中只能使用一条语句，而在 C++14 之后可以使用的语句变得丰富。<code>constexpr</code> 函数允许编译期优化，但不阻止运行期使用。作为对比，C++20 <code>consteval</code> 只能在编译期使用。</p><p>应用：e.g. 常量表达式函数可以计算出一些基本信息，比如判断一个整数是否为素数，以此做为另一个模板类偏特化的依据。</p><h1 id=sfinae>SFINAE
<a class=header-anchor href=#sfinae></a></h1><p><code>substitution failure is not an error</code></p><p>有一些地方需要注意：寻找函数 candidates 时只会考虑函数模板的函数签名，不会考虑函数体。用 C++14 auto 省略掉返回值类型之后，也不会考虑返回值类型。如果匹配完成之后函数体不能编译，编译器就会报错。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/08-Compile-Time-Programming/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/09-Using-Templates-in-Practice/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 09 Using Templates in Practice"><meta itemprop=description content="包含模型 - The Inclusion Model

通常模板需要被包含在头文件中工作。
注意：函数模板完全特化之后也需要 inline 才能够在头文件中使用，否则会出现不同的翻译单元有重复定义的情况。
改进一：precompiled headers

可以把 pch 理解为编译器中间工作状态的一个 dump。编译器可以在读取到某些源代码之后保存其状态，包括符号表等。如果两个文件中有公共的前缀代码（比如一个标准库的头文件就包含了数千行公共代码），编译器就可以读取预先保存的状态，从而跳过对于这些代码的处理。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/09-Using-Templates-in-Practice/ itemprop=url class=post-title-link>CTTCG 09 Using Templates in Practice</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=包含模型---the-inclusion-model>包含模型 - The Inclusion Model
<a class=header-anchor href=#%e5%8c%85%e5%90%ab%e6%a8%a1%e5%9e%8b---the-inclusion-model></a></h1><p>通常模板需要被包含在头文件中工作。</p><p>注意：函数模板完全特化之后也需要 inline 才能够在头文件中使用，否则会出现不同的翻译单元有重复定义的情况。</p><h1 id=改进一precompiled-headers>改进一：precompiled headers
<a class=header-anchor href=#%e6%94%b9%e8%bf%9b%e4%b8%80precompiled-headers></a></h1><p>可以把 pch 理解为编译器中间工作状态的一个 dump。编译器可以在读取到某些源代码之后保存其状态，包括符号表等。如果两个文件中有公共的前缀代码（比如一个标准库的头文件就包含了数千行公共代码），编译器就可以读取预先保存的状态，从而跳过对于这些代码的处理。</p><p>很遗憾的是前缀的判定是必须完全相同，即便改变头文件的包含顺序，其中与宏相关的定义也可能结果不同。由于宏无法从模块中导出，模块将可能解决这一痛点。</p><h1 id=改进二explicit-template-instantiation>改进二：explicit template instantiation
<a class=header-anchor href=#%e6%94%b9%e8%bf%9b%e4%ba%8cexplicit-template-instantiation></a></h1><p>只在头文件中留模板函数的声明，而不是定义。然后在其他的源文件中提供特化的定义。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/09-Using-Templates-in-Practice/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/page/34/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/page/31/>31</a>
<a class=page-number href=/page/32/>32</a>
<a class=page-number href=/page/33/>33</a>
<a class=page-number href=/page/34/>34</a>
<span class="page-number current">35</span>
<a class=page-number href=/page/36/>36</a>
<a class=page-number href=/page/37/>37</a>
<a class=page-number href=/page/38/>38</a>
<a class=page-number href=/page/39/>39</a>
<a class="extend next" rel=next href=/page/36/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>