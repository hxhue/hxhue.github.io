<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Bluegill"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content><meta name=google-site-verification content="hwfud_ndcnJHe2Jz7ClToP1nuUA3k7FqZv-0VpFAHjg"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":true,"isPage":false,"path":"hxhue.github.io","permalink":"https://hxhue.github.io/","title":"Bluegill","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class="hvr-icon-pulse menu-item-active" rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/10-Basic-Template-Terminology/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 10 Basic Template Terminology"><meta itemprop=description content="Class Template v.s. Template Class

前者是生成类的模板，后者既可以指模板，又可以指从模板生成的类。
Substitution, Instantiation, and Specialization


参数替代是模板生成相应对象（即实例化）的一个中间环节。
实例化是从模板生成相应对象的动作。
特化是和模板形式相似但匹配程度更高的对象。特化分为实例化（生成式特化）和显式特化（explicit specialization，即人为提供特化函数）。

Declarations versus Definitions

函数、类或变量等有了名字，但是定义不完整，就算作声明。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/10-Basic-Template-Terminology/ itemprop=url class=post-title-link>CTTCG 10 Basic Template Terminology</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=class-template-vs-template-class>Class Template v.s. Template Class
<a class=header-anchor href=#class-template-vs-template-class></a></h1><p>前者是生成类的模板，后者既可以指模板，又可以指从模板生成的类。</p><h1 id=substitution-instantiation-and-specialization>Substitution, Instantiation, and Specialization
<a class=header-anchor href=#substitution-instantiation-and-specialization></a></h1><ul><li>参数替代是模板生成相应对象（即实例化）的一个中间环节。</li><li>实例化是从模板生成相应对象的动作。</li><li>特化是和模板形式相似但匹配程度更高的对象。特化分为实例化（生成式特化）和显式特化（explicit specialization，即人为提供特化函数）。</li></ul><h1 id=declarations-versus-definitions>Declarations versus Definitions
<a class=header-anchor href=#declarations-versus-definitions></a></h1><p>函数、类或变量等有了名字，但是定义不完整，就算作声明。</p><p>对变量初始化，或者缺少 extern 修饰符（specifier）时，声明就变成了定义。</p><h1 id=the-one-definition-ruleodr>The One-Definition Rule（ODR）
<a class=header-anchor href=#the-one-definition-ruleodr></a></h1><ul><li>Ordinary (i.e., not templates) noninline functions and member functions, as well as (noninline)
global variables and static data members should be defined only once across the whole program. 非内联函数和成员函数、（非内联的）全局和（非内联的）静态变量在整个程序中只能定义一次。</li><li>Class types (including structs and unions), templates (including partial specializations but not full specializations), and inline functions and variables should be defined at most once per translation unit, and all these definitions should be identical. 类和不完整的模板、内联函数和变量每个翻译单元中最多定义一次，整个程序中的多个定义必须完全相等。</li></ul></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/10-Basic-Template-Terminology/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/11-Generic-Libraries/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 11 Generic Libraries"><meta itemprop=description content="Callables

Callable 有很多：函数、函数指针、成员函数、lambda 表达式（函数对象特例）、函数对象（Functor）等。
lambda 表达式

lambda 是函数对象。当捕获列表没有参数的时候，lambda 还有一个转换成一般函数指针的隐式转换操作符。在无捕获列表的 lambda 前加上 + 符号，能使得 lambda 变成函数指针也就是这个道理。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/11-Generic-Libraries/ itemprop=url class=post-title-link>CTTCG 11 Generic Libraries</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-04-08T00:00:00+08:00 itemprop=dateModified datetime=2024-04-08T00:00:00+08:00>2024-04-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=callables>Callables
<a class=header-anchor href=#callables></a></h1><p>Callable 有很多：函数、函数指针、成员函数、lambda 表达式（函数对象特例）、函数对象（Functor）等。</p><h2 id=lambda-表达式>lambda 表达式
<a class=header-anchor href=#lambda-%e8%a1%a8%e8%be%be%e5%bc%8f></a></h2><p>lambda 是函数对象。当捕获列表没有参数的时候，lambda 还有一个转换成一般函数指针的隐式转换操作符。在无捕获列表的 lambda 前加上 <code>+</code> 符号，能使得 lambda 变成函数指针也就是这个道理。</p><h2 id=stdinvoke><code>std::invoke</code>
<a class=header-anchor href=#stdinvoke></a></h2><p>支持 Callable 并不简单，因为需要考虑到成员函数的调用需要通过 this 指针来完成。C++17 提供了 <code>std::invoke</code> 来将这些操作统一起来，只需要把 this 指针当作第一个参数传入。</p><h2 id=surrogate-function---从类型隐式转换得来>Surrogate Function - 从类型隐式转换得来
<a class=header-anchor href=#surrogate-function---%e4%bb%8e%e7%b1%bb%e5%9e%8b%e9%9a%90%e5%bc%8f%e8%bd%ac%e6%8d%a2%e5%be%97%e6%9d%a5></a></h2><p>Dummy/Surrogate function（哑函数/替代函数）指的是某一个函数对象还具有一个到普通函数引用或者普通函数指针的隐式转换，这个转换好的函数就是替代函数。替代函数用到了一次隐式转换，所以在参数匹配均不优于函数对象的其他<code>()</code>操作符重载时不会被选中。但若替代函数是更好的替代，将出现函数使用 ambiguous 的情况。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>IndirectFunctor</span> {
</span></span><span style=display:flex><span>   <span style=color:#719e07>public</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>    <span style=color:#dc322f>void</span> <span style=color:#719e07>operator</span>()(<span style=color:#dc322f>double</span>, <span style=color:#dc322f>double</span>) <span style=color:#719e07>const</span> {}
</span></span><span style=display:flex><span>    <span style=color:#719e07>operator</span> <span style=color:#268bd2>auto</span> () <span style=color:#719e07>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> <span style=color:#719e07>+</span>[](<span style=color:#dc322f>double</span>, <span style=color:#dc322f>int</span>) {};
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>activate</span>(IndirectFunctor <span style=color:#719e07>const</span><span style=color:#719e07>&amp;</span> funcObj) {
</span></span><span style=display:flex><span>    funcObj(<span style=color:#2aa198>3</span>, <span style=color:#2aa198>5</span>); <span style=color:#586e75>// ERROR: ambiguous
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/11-Generic-Libraries/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/12-Fundamentals-in-Depth/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 12 Fundamentals in Depth"><meta itemprop=description content="1 参数化声明

模板分类

模板有四类：类模板、函数模板、变量模板、别名模板。其中别名模板是：








变量模板其实可以不需要 inline（但是最好加上）

C++17 中静态和全局变量都能够用 inline 来修饰。这也意味着类中的静态变量不必在类中声明、类外初始化（非头文件），而是可以在类中直接写 inline。之前笔记里面提到的问题里，inline 加不加都没有关系，因为变量模板本身可以在多个翻译单元中出现。P179"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/12-Fundamentals-in-Depth/ itemprop=url class=post-title-link>CTTCG 12 Fundamentals in Depth</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-01-05T00:00:00+08:00 itemprop=dateModified datetime=2025-01-05T00:00:00+08:00>2025-01-05</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1-参数化声明>1 参数化声明
<a class=header-anchor href=#1-%e5%8f%82%e6%95%b0%e5%8c%96%e5%a3%b0%e6%98%8e></a></h1><h2 id=模板分类>模板分类
<a class=header-anchor href=#%e6%a8%a1%e6%9d%bf%e5%88%86%e7%b1%bb></a></h2><p>模板有四类：类模板、函数模板、变量模板、别名模板。其中别名模板是：</p><p><img src=/assets/8be842c59c3eec8f5932e5043b2fd31f.webp></p><h2 id=变量模板其实可以不需要-inline但是最好加上>变量模板其实可以不需要 inline（但是最好加上）
<a class=header-anchor href=#%e5%8f%98%e9%87%8f%e6%a8%a1%e6%9d%bf%e5%85%b6%e5%ae%9e%e5%8f%af%e4%bb%a5%e4%b8%8d%e9%9c%80%e8%a6%81-inline%e4%bd%86%e6%98%af%e6%9c%80%e5%a5%bd%e5%8a%a0%e4%b8%8a></a></h2><p>C++17 中静态和全局变量都能够用 inline 来修饰。这也意味着类中的静态变量不必在类中声明、类外初始化（非头文件），而是可以在类中直接写 inline。之前笔记里面提到的问题里，inline 加不加都没有关系，因为变量模板本身可以在多个翻译单元中出现。P179</p><h2 id=嵌套模板的非原地定义>嵌套模板的非原地定义
<a class=header-anchor href=#%e5%b5%8c%e5%a5%97%e6%a8%a1%e6%9d%bf%e7%9a%84%e9%9d%9e%e5%8e%9f%e5%9c%b0%e5%ae%9a%e4%b9%89></a></h2><p>想要给类模板中的模板在类外提供定义是比较复杂的，需要嵌套模板参数描述：</p><p><img src=/assets/e750ed75305bf3e74154ae9efa985b71.webp></p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/12-Fundamentals-in-Depth/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/13-Names-in-Templates/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 13 Names in Templates"><meta itemprop=description content="名字查找：普通查找和 ADL

普通查找和 ADL 是同时进行的，不存在优先级差异。这些被找到的函数被放在一起参与重载决议。如果没有因为一般性的重载决议规则决出优劣，则会引发 ambiguous 指代错误。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/13-Names-in-Templates/ itemprop=url class=post-title-link>CTTCG 13 Names in Templates</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-01-05T00:00:00+08:00 itemprop=dateModified datetime=2025-01-05T00:00:00+08:00>2025-01-05</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=名字查找普通查找和-adl>名字查找：普通查找和 ADL
<a class=header-anchor href=#%e5%90%8d%e5%ad%97%e6%9f%a5%e6%89%be%e6%99%ae%e9%80%9a%e6%9f%a5%e6%89%be%e5%92%8c-adl></a></h1><p>普通查找和 ADL 是同时进行的，不存在优先级差异。这些被找到的函数被放在一起参与重载决议。如果没有因为一般性的重载决议规则决出优劣，则会引发 ambiguous 指代错误。</p><h2 id=ordinary-lookup-内部名称遮盖外部名称的规则>Ordinary lookup: 内部名称遮盖外部名称的规则
<a class=header-anchor href=#ordinary-lookup-%e5%86%85%e9%83%a8%e5%90%8d%e7%a7%b0%e9%81%ae%e7%9b%96%e5%a4%96%e9%83%a8%e5%90%8d%e7%a7%b0%e7%9a%84%e8%a7%84%e5%88%99></a></h2><p><img src=/assets/a3588f0047d856bc7a0c4194c5b57fb5.webp></p><h2 id=adl-考虑参数类型所在名字空间的函数和操作符重载>ADL: 考虑参数类型所在名字空间的函数和操作符重载
<a class=header-anchor href=#adl-%e8%80%83%e8%99%91%e5%8f%82%e6%95%b0%e7%b1%bb%e5%9e%8b%e6%89%80%e5%9c%a8%e5%90%8d%e5%ad%97%e7%a9%ba%e9%97%b4%e7%9a%84%e5%87%bd%e6%95%b0%e5%92%8c%e6%93%8d%e4%bd%9c%e7%ac%a6%e9%87%8d%e8%bd%bd></a></h2><p>相关类型有很多规则，比如指针会引入其指向类型的名字空间、类会引入外围类（如果是一个内部类）和基类的名字空间、函数会引入其参数和返回值的名字空间等（P219）。特例是 hidden friends，可以直接定义在类中。</p><p>ADL 失效的情况：① 调用前给函数名加上括号，这样就必须先找到函数。② 函数模板在 C++20 之前除非在外部声明函数模板（参数列表可以不同），否则也无法被找到。因为在还没有看参数的情况下，函数模板没有被引入；还没有看参数列表的情况下不知道这个是函数模板；不知道这个是函数模板的情况下会把参数列表的头尾理解成大于和小于操作符。这是一种鸡生蛋蛋生鸡的问题。③ <strong>ADL 会忽略 using 声明，只考虑真正存在于名字空间的函数。</strong></p><p>ADL 只会通过参数（也就是显式调用）引入额外的函数和操作符，其他情况下这些名称是不会被自动引入的，比如取一个和参数相关的函数指针。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/13-Names-in-Templates/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/15-Template-Argument-Deduction/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 15 Template Argument Deduction"><meta itemprop=description content="2023 年 5 月 17 日
推导上下文：Deduced Context

P272 书上

依赖于模板类型的子类型不是推导上下文。比如 typename X<N>::I 不是。而 X<N>::* 这样的指向成员的指针没有用到子类型，所以是推导上下文。
非类型模板参数的非平凡表达式不是推导上下文。比如模板 S 和参数 I，S<I+1> 无法提供推导信息。

如何推导出模板参数


从参数列表中推导（推导能力是有限制的，比如不能从 typename T::iterator 参数中推出 T 的类型）
函数模板被取地址时，可以从要求的返回值类型推导：

template<typename T>
void f(T, T);

void (*pf)(char, char) = &amp;f; // f的参数T由函数指针的类型确定

隐式转换操作符模板的类型参数 T 由需要转换时所需的类型决定。

模板尝试匹配的时候不适用 common type。 比如两个 T 类型分别被认为是 int 和 double 时，会导致模板替换失败，而不是把 T 认为是 double。比如"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/15-Template-Argument-Deduction/ itemprop=url class=post-title-link>CTTCG 15 Template Argument Deduction</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-04-08T00:00:00+08:00 itemprop=dateModified datetime=2024-04-08T00:00:00+08:00>2024-04-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>2023 年 5 月 17 日</p><h1 id=推导上下文deduced-context>推导上下文：Deduced Context
<a class=header-anchor href=#%e6%8e%a8%e5%af%bc%e4%b8%8a%e4%b8%8b%e6%96%87deduced-context></a></h1><p>P272 书上</p><ul><li>依赖于模板类型的子类型不是推导上下文。比如 <code>typename X&lt;N>::I</code> 不是。而 <code>X&lt;N>::*</code> 这样的指向成员的指针没有用到子类型，所以是推导上下文。</li><li>非类型模板参数的非平凡表达式不是推导上下文。比如模板 <code>S</code> 和参数 <code>I</code>，<code>S&lt;I+1></code> 无法提供推导信息。</li></ul><h1 id=如何推导出模板参数>如何推导出模板参数
<a class=header-anchor href=#%e5%a6%82%e4%bd%95%e6%8e%a8%e5%af%bc%e5%87%ba%e6%a8%a1%e6%9d%bf%e5%8f%82%e6%95%b0></a></h1><ol><li>从参数列表中推导（推导能力是有限制的，比如不能从 <code>typename T::iterator</code> 参数中推出 <code>T</code> 的类型）</li><li>函数模板被取地址时，可以从要求的返回值类型推导：</li></ol><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> f(T, T);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> (<span style=color:#719e07>*</span>pf)(<span style=color:#dc322f>char</span>, <span style=color:#dc322f>char</span>) <span style=color:#719e07>=</span> <span style=color:#719e07>&amp;</span>f; <span style=color:#586e75>// f的参数T由函数指针的类型确定
</span></span></span></code></pre></div></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/15-Template-Argument-Deduction/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/16-Specializations-and-Overloading/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 16 Specializations and Overloading"><meta itemprop=description content="大部分都不需要专门总结，因此这一小节为空。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/16-Specializations-and-Overloading/ itemprop=url class=post-title-link>CTTCG 16 Specializations and Overloading</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>大部分都不需要专门总结，因此这一小节为空。</p></div><footer class=post-footer><div readmore=false><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/16-Specializations-and-Overloading/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/17-Future-Directions/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 17 Future Directions"><meta itemprop=description content="这一章讲的是对未来的展望。
浮点数和字符串作为模板参数

浮点数在 gcc C++20 是可以作为非类型模板参数（NTTP）的；clang 不支持。目前 C++ compiler support - cppreference.com 上也看不到相关的支持项目。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/17-Future-Directions/ itemprop=url class=post-title-link>CTTCG 17 Future Directions</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>这一章讲的是对未来的展望。</p><h1 id=浮点数和字符串作为模板参数>浮点数和字符串作为模板参数
<a class=header-anchor href=#%e6%b5%ae%e7%82%b9%e6%95%b0%e5%92%8c%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%bd%9c%e4%b8%ba%e6%a8%a1%e6%9d%bf%e5%8f%82%e6%95%b0></a></h1><p>浮点数在 gcc C++20 是可以作为非类型模板参数（NTTP）的；clang 不支持。目前 <a href=https://en.cppreference.com/w/cpp/compiler_support title="C++ compiler support - cppreference.com" rel="noopener external nofollow noreferrer" target=_blank class=exturl>C++ compiler support - cppreference.com<i class="fa fa-external-link-alt"></i></a> 上也看不到相关的支持项目。</p><p>字符串字面量在 C++20 只能通过隐式转换成简单的对象实现模板参数。<u>15/特例：变参列表/参数包</u> 一节有描述。字符数组则是早就可以作为模板参数，尽管作为引用其 linkage 在 C++11 和 C++14 有额外的要求。</p><p>当前 class type 和浮点数没有作为非模板参数得到全面的支持，原因很可能是<strong>相等性比较</strong>在<strong>链接</strong>阶段很难进行（浮点数的标准可能不同，或者因为精度缺失会误判；类可能会重载比较操作符）。</p><h1 id=减少类模板-pack-expansion-的限制>减少类模板 pack expansion 的限制
<a class=header-anchor href=#%e5%87%8f%e5%b0%91%e7%b1%bb%e6%a8%a1%e6%9d%bf-pack-expansion-%e7%9a%84%e9%99%90%e5%88%b6></a></h1><p>目前不能在类模板参数中使用多个 pack expansion，而且使用时也必须把它放在最末尾的位置；不仅模板参数声明是这样，填充类模板参数也是这样。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/17-Future-Directions/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/18-The-Polymorphic-Power-of-Templates/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 18 The Polymorphic Power of Templates"><meta itemprop=description content="C++ 的多态有两类：bounded dynamic polymorphism 和 unbounded static polymorphism。前者 bounded 指的是虚函数有基类的接口，其行为有一定约束；后者 unbounded 指的是模板采用类型替换的方式生成代码。为了给静态多态提供约束，可以使用 enable_if 或 concept。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/18-The-Polymorphic-Power-of-Templates/ itemprop=url class=post-title-link>CTTCG 18 The Polymorphic Power of Templates</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>C++ 的多态有两类：bounded <strong>dynamic</strong> polymorphism 和 unbounded <strong>static</strong> polymorphism。前者 bounded 指的是虚函数有基类的接口，其行为有一定约束；后者 unbounded 指的是模板采用类型替换的方式生成代码。为了给静态多态提供约束，可以使用 enable_if 或 concept。</p></div><footer class=post-footer><div readmore=false><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/18-The-Polymorphic-Power-of-Templates/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/19-Implementing-Traits/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 19 Implementing Traits"><meta itemprop=description content="Trait 分类

不一定大家都这么叫，但是为了方便，我规定下面的术语：

Type Trait：包含一个 type alias。
Value Trait：包含一个 value 静态成员，可以是任何基本类型，含义和具体 Trait 相关。
Predicate Trait：包含一个 value 静态成员，类型为 bool，含义为条件是否被满足。

书中有分为 property trait 和 policy trait 两大类。前者包含我所称的 type trait 和 value trait，含义是类型本身的固有信息；后者表示根据一个特定类型选择某种映射，其含义和要实现的行为有关，文中的例子是对 size 小的参数选择原类型，对 size 大的参数选择引用类型。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/19-Implementing-Traits/ itemprop=url class=post-title-link>CTTCG 19 Implementing Traits</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-04-08T00:00:00+08:00 itemprop=dateModified datetime=2024-04-08T00:00:00+08:00>2024-04-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=trait-分类>Trait 分类
<a class=header-anchor href=#trait-%e5%88%86%e7%b1%bb></a></h1><p>不一定大家都这么叫，但是为了方便，我规定下面的术语：</p><ul><li>Type Trait：包含一个 type alias。</li><li>Value Trait：包含一个 value 静态成员，可以是任何基本类型，含义和具体 Trait 相关。</li><li>Predicate Trait：包含一个 value 静态成员，类型为 bool，含义为条件是否被满足。</li></ul><p>书中有分为 property trait 和 policy trait 两大类。前者包含我所称的 type trait 和 value trait，含义是类型本身的固有信息；后者表示根据一个特定类型选择某种映射，其含义和要实现的行为有关，文中的例子是对 size 小的参数选择原类型，对 size 大的参数选择引用类型。</p><h1 id=traits-vs-policies>Traits v.s. Policies
<a class=header-anchor href=#traits-vs-policies></a></h1><p>例子是累加算法的模板实现。</p><p>Traits 一般表示和类型有关的静态的信息；Policies 表示行为。累加例子中 Traits 包含加法结果的类型，而 Policies 则包含了加法的执行过程。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/19-Implementing-Traits/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/19.1-%E7%94%A8-SFINAE-%E5%AE%9E%E7%8E%B0-Traits/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 19.1 用 SFINAE 实现 Traits"><meta itemprop=description content="原理是用 SFINAE 机制安全地匹配几个函数或函数模板，然后再通过函数匹配信息将结果（true or false）嵌入 Trait 类中。Trait 约束条件被包含在函数模板的声明中。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/cpp-templates-the-complete-guide/19.1-%E7%94%A8-SFINAE-%E5%AE%9E%E7%8E%B0-Traits/ itemprop=url class=post-title-link>CTTCG 19.1 用 SFINAE 实现 Traits</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-04-08T00:00:00+08:00 itemprop=dateModified datetime=2024-04-08T00:00:00+08:00>2024-04-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>原理是用 SFINAE 机制安全地匹配几个函数或函数模板，然后再通过函数匹配信息将结果（true or false）嵌入 Trait 类中。Trait 约束条件被包含在函数模板的声明中。</p><p>实现 traits 最核心的要点是<strong>模拟</strong>被替换类型的行为，然后让行为不满足的那些替换被 SFINAE 筛掉。</p><h1 id=函数返回基本类型--静态常量定义>函数返回基本类型 → 静态常量定义
<a class=header-anchor href=#%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b--%e9%9d%99%e6%80%81%e5%b8%b8%e9%87%8f%e5%ae%9a%e4%b9%89></a></h1><p>类模板实例化时会调用 <code>test</code> 函数，如果条件命中则优先匹配 <code>char test(void *)</code>，否则匹配另外一个。通过判断匹配到的函数的返回值类型可以确定条件是否被命中。这里的条件是类型 <code>T</code> 可以默认构造。</p><p><img src=/assets/0380dc83afe69c80f565536ffb2d9cae.webp></p><p>⚠ 如果把第一个 <code>test</code> 的参数 <code>U</code> 去掉，默认参数改成 <code>typename = decltype(T())</code>，就无法编译。因为 T 会在实例化时被替代过去，导致函数模板本身定义有错误。这个过程没有发生在函数模板匹配阶段，不会受到 SFINAE 的保护。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/cpp-templates-the-complete-guide/19.1-%E7%94%A8-SFINAE-%E5%AE%9E%E7%8E%B0-Traits/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/page/35/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/page/32/>32</a>
<a class=page-number href=/page/33/>33</a>
<a class=page-number href=/page/34/>34</a>
<a class=page-number href=/page/35/>35</a>
<span class="page-number current">36</span>
<a class=page-number href=/page/37/>37</a>
<a class=page-number href=/page/38/>38</a>
<a class=page-number href=/page/39/>39</a>
<a class=page-number href=/page/40/>40</a>
<a class="extend next" rel=next href=/page/37/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>