<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="CTTCG 15 Template Argument Deduction"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content="cpp,cpp-templates-the-complete-guide"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"15-Template-Argument-Deduction","permalink":"https://hxhue.github.io/cpp-templates-the-complete-guide/15-Template-Argument-Deduction/","title":"CTTCG 15 Template Argument Deduction","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>CTTCG 15 Template Argument Deduction - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#推导上下文deduced-context>推导上下文：Deduced Context</a></li><li><a href=#如何推导出模板参数>如何推导出模板参数</a></li><li><a href=#特例初始化列表>特例：初始化列表</a></li><li><a href=#特例变参列表参数包>特例：变参列表/参数包</a></li><li><a href=#特例字面量操作符模板>特例：字面量操作符模板</a><ul><li><a href=#整数-n>整数 n</a></li><li><a href=#浮点数-f>浮点数 f</a></li><li><a href=#字符串-str长度为-len>字符串 str，长度为 len</a></li><li><a href=#字符-ch>字符 ch</a></li></ul></li><li><a href=#特例默认参数>特例：默认参数</a></li><li><a href=#引用类型>引用类型</a></li><li><a href=#完美转发>完美转发</a><ul><li><a href=#类型推导>类型推导</a></li><li><a href=#禁用完美转发>禁用完美转发</a></li></ul></li><li><a href=#立即上下文immediate-context>立即上下文（immediate context）</a><ul><li><a href=#类模板定义不是立即上下文>类模板定义不是立即上下文</a></li><li><a href=#异常声明不是立即上下文>异常声明不是立即上下文</a></li></ul></li><li><a href=#auto-关键字>auto 关键字</a><ul><li><a href=#构造一个能够操作对象成员自增的-handle>构造一个能够操作对象成员自增的 handle</a></li><li><a href=#强制-auto-推导中所有参数类型一致>强制 <code>auto...</code> 推导中所有参数类型一致</a></li><li><a href=#decltypeauto><code>decltype(auto)</code></a></li><li><a href=#使用一个-auto-声明多个变量>使用一个 <code>auto</code> 声明多个变量</a></li><li><a href=#返回值用-auto-推导但函数有多个分支>返回值用 <code>auto</code> 推导，但函数有多个分支</a></li><li><a href=#auto-类型推导构成循环依赖><code>auto</code> 类型推导构成循环依赖</a></li></ul></li><li><a href=#结构化绑定structured-binding>结构化绑定（Structured Binding）</a></li><li><a href=#class-template-argument-deduction-ctad>Class template argument deduction (CTAD)</a><ul><li><a href=#单括号初始化更偏向复制移动构造>单括号初始化更偏向复制/移动构造</a></li><li><a href=#原始模板类有隐式推导规则>原始模板类有隐式推导规则</a></li><li><a href=#injected-class-names>Injected Class Names</a></li><li><a href=#forwarding-references>Forwarding References</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/cpp-templates-the-complete-guide/15-Template-Argument-Deduction/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CTTCG 15 Template Argument Deduction"><meta itemprop=description content="2023 年 5 月 17 日
推导上下文：Deduced Context

P272 书上

依赖于模板类型的子类型不是推导上下文。比如 typename X<N>::I 不是。而 X<N>::* 这样的指向成员的指针没有用到子类型，所以是推导上下文。
非类型模板参数的非平凡表达式不是推导上下文。比如模板 S 和参数 I，S<I+1> 无法提供推导信息。

如何推导出模板参数


从参数列表中推导（推导能力是有限制的，比如不能从 typename T::iterator 参数中推出 T 的类型）
函数模板被取地址时，可以从要求的返回值类型推导：

template<typename T>
void f(T, T);

void (*pf)(char, char) = &amp;f; // f的参数T由函数指针的类型确定

隐式转换操作符模板的类型参数 T 由需要转换时所需的类型决定。

模板尝试匹配的时候不适用 common type。 比如两个 T 类型分别被认为是 int 和 double 时，会导致模板替换失败，而不是把 T 认为是 double。比如"></span><header class=post-header><h1 class=post-title itemprop="name headline">CTTCG 15 Template Argument Deduction</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-04-08T00:00:00+08:00 itemprop=dateModified datetime=2024-04-08T00:00:00+08:00>2024-04-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-templates-the-complete-guide itemprop=url rel=index><span itemprop=name>cpp-templates-the-complete-guide</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>4035</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>9分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><p>2023 年 5 月 17 日</p><h1 id=推导上下文deduced-context>推导上下文：Deduced Context
<a class=header-anchor href=#%e6%8e%a8%e5%af%bc%e4%b8%8a%e4%b8%8b%e6%96%87deduced-context></a></h1><p>P272 书上</p><ul><li>依赖于模板类型的子类型不是推导上下文。比如 <code>typename X&lt;N>::I</code> 不是。而 <code>X&lt;N>::*</code> 这样的指向成员的指针没有用到子类型，所以是推导上下文。</li><li>非类型模板参数的非平凡表达式不是推导上下文。比如模板 <code>S</code> 和参数 <code>I</code>，<code>S&lt;I+1></code> 无法提供推导信息。</li></ul><h1 id=如何推导出模板参数>如何推导出模板参数
<a class=header-anchor href=#%e5%a6%82%e4%bd%95%e6%8e%a8%e5%af%bc%e5%87%ba%e6%a8%a1%e6%9d%bf%e5%8f%82%e6%95%b0></a></h1><ol><li>从参数列表中推导（推导能力是有限制的，比如不能从 <code>typename T::iterator</code> 参数中推出 <code>T</code> 的类型）</li><li>函数模板被取地址时，可以从要求的返回值类型推导：</li></ol><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> f(T, T);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> (<span style=color:#719e07>*</span>pf)(<span style=color:#dc322f>char</span>, <span style=color:#dc322f>char</span>) <span style=color:#719e07>=</span> <span style=color:#719e07>&amp;</span>f; <span style=color:#586e75>// f的参数T由函数指针的类型确定
</span></span></span></code></pre></div><ol><li><strong>隐式转换操作符模板</strong>的类型参数 T 由需要转换时所需的类型决定。</li></ol><p><em>模板尝试匹配的时候不适用 common type。</em> 比如两个 T 类型分别被认为是 int 和 double 时，会导致模板替换失败，而不是把 T 认为是 double。比如</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span> <span style=color:#719e07>&lt;</span><span style=color:#719e07>class</span> <span style=color:#268bd2>T</span><span style=color:#719e07>&gt;</span> T max(T a, T b) { <span style=color:#719e07>return</span> a <span style=color:#719e07>&gt;</span> b <span style=color:#719e07>?</span> a : b; }
</span></span></code></pre></div><p>调用 <code>max(1, 3.0)</code> 就会失败，而调用 <code>max&lt;double>(1, 3.0)</code> 才能成功（模板参数被人为指定之后就允许隐式类型转换了）。</p><h1 id=特例初始化列表>特例：初始化列表
<a class=header-anchor href=#%e7%89%b9%e4%be%8b%e5%88%9d%e5%a7%8b%e5%8c%96%e5%88%97%e8%a1%a8></a></h1><p>初始化列表没有确定的类型，因此不能绑定在参数类型 T 上面。但是如果参数类型为 <code>std::initializer_list&lt;T></code>，则能够尝试绑定（当所有元素类型相同时成功）。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;initializer_list&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#586e75>// 如果把参数类型从初始化列表改成 T 就会推导失败
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T<span style=color:#719e07>&gt;</span> <span style=color:#dc322f>void</span> f(std<span style=color:#719e07>::</span>initializer_list<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span>) {}
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    f({<span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span>, <span style=color:#2aa198>5</span>, <span style=color:#2aa198>7</span>, <span style=color:#2aa198>9</span>});               <span style=color:#586e75>// OK: T is deduced to int
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    f({’a’, ’e’, ’i’, ’o’, ’u’, <span style=color:#2aa198>42</span>}); <span style=color:#586e75>// ERROR: T deduced to both char and int
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>同时，<code>auto primes = { 2, 3, 5, 7 };</code> 创建的是 <code>std::initializer_list&lt;int></code> 类型的数据。在 C++17 之后，去掉其中的 <code>=</code> 就无法编译。C++17 对去掉 <code>=</code> 的 <code>auto x{?};</code> 初始化倾向于推导为单个元素，而之前统一推导为 <code>std::initializer&lt;?></code> ：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>auto</span> oops { <span style=color:#2aa198>0</span>, <span style=color:#2aa198>8</span>, <span style=color:#2aa198>15</span> }; <span style=color:#586e75>// ERROR in C++17. OK before C++17
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>auto</span> val { <span style=color:#2aa198>2</span> };         <span style=color:#586e75>// OK: val has type int in C++17,
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                        <span style=color:#586e75>// or type std::intializer_list&lt;int&gt; before C++17
</span></span></span></code></pre></div><p>在函数中使用 <code>auto</code> 推导，同时又返回初始化列表，则无法编译，因为无法确定具体类型。</p><h1 id=特例变参列表参数包>特例：变参列表/参数包
<a class=header-anchor href=#%e7%89%b9%e4%be%8b%e5%8f%98%e5%8f%82%e5%88%97%e8%a1%a8%e5%8f%82%e6%95%b0%e5%8c%85></a></h1><p>简单情景：匹配 0 或多个剩余参数。</p><p>pack expansion：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T, <span style=color:#719e07>typename</span> U<span style=color:#719e07>&gt;</span> <span style=color:#719e07>class</span> <span style=color:#268bd2>pair</span> { };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// **匹配能力**：第一参数相同的零个或多个 pair
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T, <span style=color:#719e07>typename</span>... Rest<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> h1(pair<span style=color:#719e07>&lt;</span>T, Rest<span style=color:#719e07>&gt;</span> <span style=color:#719e07>const</span><span style=color:#719e07>&amp;</span>...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// 由于 pack expansion 中有两个 parameter pack，因此 Ts 和 Rest 的参数数量必须一致
</span></span></span><span style=display:flex><span><span style=color:#586e75>// **匹配能力**：任意参数的零个或多个 pair
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span>... Ts, <span style=color:#719e07>typename</span>... Rest<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> h2(pair<span style=color:#719e07>&lt;</span>Ts, Rest<span style=color:#719e07>&gt;</span> <span style=color:#719e07>const</span><span style=color:#719e07>&amp;</span>...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>foo</span>(pair<span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span>, <span style=color:#dc322f>float</span><span style=color:#719e07>&gt;</span> pif, pair<span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span>, <span style=color:#dc322f>double</span><span style=color:#719e07>&gt;</span> pid, pair<span style=color:#719e07>&lt;</span><span style=color:#dc322f>double</span>, <span style=color:#dc322f>double</span><span style=color:#719e07>&gt;</span> pdd)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    h1(pif, pid);
</span></span><span style=display:flex><span>    <span style=color:#586e75>// OK: deduces T to int, Rest to {float, double}
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    h2(pif, pid);
</span></span><span style=display:flex><span>    <span style=color:#586e75>// OK: deduces Ts to {int, int}, Rest to {float, double}
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    h1(pif, pdd);
</span></span><span style=display:flex><span>    <span style=color:#586e75>// ERROR: T deduced to int from the 1st arg, but to double from the 2nd
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    h2(pif, pdd);
</span></span><span style=display:flex><span>    <span style=color:#586e75>// OK: deduces Ts to {int, double}, Rest to {float, double}
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>传递变参，而不是做 pack expansion：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span>... Types<span style=color:#719e07>&gt;</span> <span style=color:#719e07>class</span> <span style=color:#268bd2>Tuple</span> { };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// **匹配能力**：参数完全相同的2个tuple
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span>... Types<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#dc322f>bool</span> f1(Tuple<span style=color:#719e07>&lt;</span>Types...<span style=color:#719e07>&gt;</span>, Tuple<span style=color:#719e07>&lt;</span>Types...<span style=color:#719e07>&gt;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// **匹配能力**：任意参数的2个tuple
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span>... Types1, <span style=color:#719e07>typename</span>... Types2<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#dc322f>bool</span> f2(Tuple<span style=color:#719e07>&lt;</span>Types1...<span style=color:#719e07>&gt;</span>, Tuple<span style=color:#719e07>&lt;</span>Types2...<span style=color:#719e07>&gt;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>bar</span>(Tuple<span style=color:#719e07>&lt;</span><span style=color:#dc322f>short</span>, <span style=color:#dc322f>int</span>, <span style=color:#dc322f>long</span><span style=color:#719e07>&gt;</span> sv,
</span></span><span style=display:flex><span>         Tuple<span style=color:#719e07>&lt;</span><span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>short</span>, <span style=color:#dc322f>unsigned</span>, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span><span style=color:#719e07>&gt;</span> uv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    f1(sv, sv); <span style=color:#586e75>// OK: Types is deduced to {short, int, long}
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    f2(sv, sv); <span style=color:#586e75>// OK: Types1 is deduced to {short, int, long},
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                <span style=color:#586e75>// Types2 is deduced to {short, int, long}
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    f1(sv, uv); <span style=color:#586e75>// ERROR: Types is deduced to {short, int, long} from the 1st arg, but
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                <span style=color:#586e75>// to {unsigned short, unsigned, unsigned long} from the 2nd
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    f2(sv, uv); <span style=color:#586e75>// OK: Types1 is deduced to {short, int, long},
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                <span style=color:#586e75>// Types2 is deduced to {unsigned short, unsigned, unsigned long}
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个比上面一组代码容易理解一点。</p><p>还能为参数包显式指定前几个参数类型：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>f</span>(Ts ... ps) {}
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    f<span style=color:#719e07>&lt;</span><span style=color:#dc322f>double</span>, <span style=color:#dc322f>int</span><span style=color:#719e07>&gt;</span>(<span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span>); <span style=color:#586e75>// OK
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>这是一个偏特化。第一个参数被转换成了 <code>1.0</code>。</p><h1 id=特例字面量操作符模板>特例：字面量操作符模板
<a class=header-anchor href=#%e7%89%b9%e4%be%8b%e5%ad%97%e9%9d%a2%e9%87%8f%e6%93%8d%e4%bd%9c%e7%ac%a6%e6%a8%a1%e6%9d%bf></a></h1><p>字面量有四类：整数、浮点数、字符串、字符。字面量操作符匹配的前提是字面量本身合法（如果不是合法数字，就需要用字符串表示），匹配的优先级则如下：</p><h2 id=整数-n>整数 n
<a class=header-anchor href=#%e6%95%b4%e6%95%b0-n></a></h2><ol><li><p>找接受参数 <code>unsigned long long</code> 的重载，若有则调用 <code>operator ""X(n ULL)</code>。</p></li><li><p>找 <em>a raw literal operator or a numeric literal operator template, but not both</em>。</p><p>前者参数为 <code>const char *</code>，调用形式为 <code>operator""X("n")</code>。后者模板参数是 <code>&lt;char ...></code> ，调用形式为 <code>operator""X&lt;'c1', 'c 2', 'c3'..., 'ck '>()</code>，也就是把字面量的每个字符拆开的变参模板。</p><p>两者不得同时被找到，否则无法区分优劣。</p></li></ol><p>类型匹配 > 当成字符串 = 拆成字符传入模板。</p><h2 id=浮点数-f>浮点数 f
<a class=header-anchor href=#%e6%b5%ae%e7%82%b9%e6%95%b0-f></a></h2><ol><li>找接受参数 <code>long double</code> 的重载，若有则调用 <code>operator ""X(f L)</code>。</li><li>剩余过程和整数的 2、3 相同。</li></ol><h2 id=字符串-str长度为-len>字符串 str，长度为 len
<a class=header-anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2-str%e9%95%bf%e5%ba%a6%e4%b8%ba-len></a></h2><ol><li>C++20：如果有参数能够和字符串字面量匹配，可以直接调用这个模板 <code>operator ""X&lt;str>()</code>。</li><li>尝试 <code>operator ""X (str, len)</code>。</li></ol><p>注意整数和浮点数可以匹配上形如 <code>unsigned operator ""_w(const char*);</code> 的重载，但是因为该重载没有长度参数，所以字符串匹配不上。</p><p>C++20 新增的匹配规则构造起来也比较困难：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;array&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;iostream&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span><span style=color:#719e07>template</span> <span style=color:#719e07>&lt;</span>size_t N<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#719e07>struct</span> <span style=color:#268bd2>string_literal</span> {
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>array<span style=color:#719e07>&lt;</span><span style=color:#dc322f>char</span>, N<span style=color:#719e07>&gt;</span> arr_{};
</span></span><span style=display:flex><span>    <span style=color:#719e07>constexpr</span> <span style=color:#268bd2>string_literal</span>(<span style=color:#719e07>const</span> <span style=color:#dc322f>char</span> (<span style=color:#719e07>&amp;</span>in)[N]) {
</span></span><span style=display:flex><span>        std<span style=color:#719e07>::</span>copy(in, in <span style=color:#719e07>+</span> N, arr_.begin());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>template</span> <span style=color:#719e07>&lt;</span>string_literal str<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#719e07>auto</span> <span style=color:#719e07>operator</span><span style=color:#2aa198>&#34;&#34;</span> _len() {
</span></span><span style=display:flex><span>    <span style=color:#719e07>static_assert</span>(str.arr_.size() <span style=color:#719e07>&gt;</span> <span style=color:#2aa198>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> str.arr_.size() <span style=color:#719e07>-</span> <span style=color:#2aa198>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#34;34&#34;</span>_len <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果使用普通的数组去匹配字符串字面量，就匹配不上。（C++17 可以采用预先分配 constexpr 字符数组的方式进行一些模板操作，而且 C++17 也没有 linkage 要求，但是这不能被直接用在字面量上，所以操作起来很麻烦）。</p><p>其实这条新规则不重要吧？除非需要覆盖原规则，把第二条规则定义为 constexpr 就行了。（<code>std::string</code> 不能作为 consteval 函数的返回值，但是 <code>std::string_view</code> 可以）但是 C++20 这样就允许（用一种曲折的方式）把字符串字面量直接作为模板参数了。</p><h2 id=字符-ch>字符 ch
<a class=header-anchor href=#%e5%ad%97%e7%ac%a6-ch></a></h2><p>尝试 <code>operator ""X(ch)</code>。</p><h1 id=特例默认参数>特例：默认参数
<a class=header-anchor href=#%e7%89%b9%e4%be%8b%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0></a></h1><p>默认参数不能用于推导参数：</p><p><img src=/assets/f7479b8da246316d6819d3674ab5e98d.webp></p><h1 id=引用类型>引用类型
<a class=header-anchor href=#%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b></a></h1><ol><li>不可以直接引用引用：</li></ol><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#719e07>const</span><span style=color:#719e07>&amp;</span> r <span style=color:#719e07>=</span> <span style=color:#2aa198>42</span>;
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#719e07>const</span><span style=color:#719e07>&amp;</span> <span style=color:#719e07>&amp;</span> ref2ref <span style=color:#719e07>=</span> i; <span style=color:#586e75>// ERROR: reference to reference is invalid
</span></span></span><span style=display:flex><span><span style=color:#586e75>// 注意编译会认出这是对引用的引用，而不是认为它是右值引用
</span></span></span></code></pre></div><ol><li>通过 decltype、类型别名、模板等方式得到的引用可以参与引用坍塌。</li><li>对引用类型的 cv 限定相当于不限定，并不会报错。（<code>const</code> / <code>volatile</code>）</li></ol><h1 id=完美转发>完美转发
<a class=header-anchor href=#%e5%ae%8c%e7%be%8e%e8%bd%ac%e5%8f%91></a></h1><h2 id=类型推导>类型推导
<a class=header-anchor href=#%e7%b1%bb%e5%9e%8b%e6%8e%a8%e5%af%bc></a></h2><p>完美转发之前会对类型进行推导，这相当于禁止了类型之间的隐式转换，这可能会导致一些问题：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>g</span>(<span style=color:#dc322f>int</span><span style=color:#719e07>*</span>);
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>g</span>(...); <span style=color:#586e75>// 应当是最次的选择
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T<span style=color:#719e07>&gt;</span> <span style=color:#dc322f>void</span> forwardToG(T<span style=color:#719e07>&amp;&amp;</span> x)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    g(std<span style=color:#719e07>::</span>forward<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span>(x)); <span style=color:#586e75>// forward x to g()
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>foo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    g(<span style=color:#2aa198>0</span>);          <span style=color:#586e75>// calls g(int*)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    forwardToG(<span style=color:#2aa198>0</span>); <span style=color:#586e75>// eventually calls g(...)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>上面代码中经过模板捕获后参数 <code>T</code> 的类型认为是 <code>int</code>，而 <code>x</code> 的类型被认为是 <code>int &&</code>。<code>int</code> 类型不能和函数 <code>g</code> 的第一个重载版本匹配。这和直接调用 <code>g(0)</code> 效果不同。<strong>C++11 引入的</strong> <code>nullptr</code> <strong>本身具有类型，用在这种情况更加合适</strong>。</p><p>本小节提到的对 <code>decltype(auto)</code> 的使用可以参考前面的章节：
<a href=/cpp-templates-the-complete-guide/11-Generic-Libraries/#%e5%ae%8c%e7%be%8e%e8%bd%ac%e5%8f%91 title=完美转发>完美转发</a>。</p><h2 id=禁用完美转发>禁用完美转发
<a class=header-anchor href=#%e7%a6%81%e7%94%a8%e5%ae%8c%e7%be%8e%e8%bd%ac%e5%8f%91></a></h2><p><code>T&&</code> 形式用来表达完美转发，那么怎么表达单纯的右值引用呢？可以用 <code>std::enable_if</code> 来判断：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#719e07>typename</span> std<span style=color:#719e07>::</span>enable_if<span style=color:#719e07>&lt;!</span>std<span style=color:#719e07>::</span>is_lvalue_reference<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;::</span>value<span style=color:#719e07>&gt;::</span>type
</span></span><span style=display:flex><span>rvalues(T<span style=color:#719e07>&amp;&amp;</span>);
</span></span></code></pre></div><h1 id=立即上下文immediate-context>立即上下文（immediate context）
<a class=header-anchor href=#%e7%ab%8b%e5%8d%b3%e4%b8%8a%e4%b8%8b%e6%96%87immediate-context></a></h1><p>摘自原文：</p><p><img src=/assets/5ffedbd0cc91ad5dbbc9ae38a044d43f.webp></p><p><strong>在立即上下文中发生的替代错误不是错误（SFINAE）</strong>，不在其中发生的错误被视作真正的错误，无法编译。</p><h2 id=类模板定义不是立即上下文>类模板定义不是立即上下文
<a class=header-anchor href=#%e7%b1%bb%e6%a8%a1%e6%9d%bf%e5%ae%9a%e4%b9%89%e4%b8%8d%e6%98%af%e7%ab%8b%e5%8d%b3%e4%b8%8a%e4%b8%8b%e6%96%87></a></h2><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>Array</span> {
</span></span><span style=display:flex><span><span style=color:#719e07>public</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>using</span> iterator <span style=color:#719e07>=</span> T<span style=color:#719e07>*</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> f(<span style=color:#719e07>typename</span> Array<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;::</span>iterator first, <span style=color:#719e07>typename</span> Array<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;::</span>iterator last) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> f(T<span style=color:#719e07>*</span>, T<span style=color:#719e07>*</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    f<span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span><span style=color:#719e07>&amp;&gt;</span>(<span style=color:#2aa198>0</span>, <span style=color:#2aa198>0</span>); <span style=color:#586e75>// ERROR
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>第一个 <code>f</code> 把 <code>T</code> 类型作为参数传给了另外一个模板 <code>Array</code>，又由于这个模板可能被特化，因而不能确定其 <code>iterator</code> 的具体类型。<em>这个模板声明中对</em> <code>T</code> <em>的类型没有任何约束，同时也不能从参数中推导出来 T 的类型，只有通过显式传入模板参数才可能启用</em>。第二个 <code>f</code> 要求可以 <code>T</code> 类型有对应的指针类型。</p><p>上面的代码中手动选择了 <code>int &</code> 类型，该类型和函数模板的第二个形式无法匹配，却和第一个能够匹配（因为第一个 <code>f</code> 对 <code>T</code> 没有任何要求）。但是在实例化时又遇到了 <code>int &*</code> 这样的非法类型，因而会出现编译错误。<em>这种出错的情况好像无论是用 enable_if 还是用 concept 都无法回避。</em> 用 type traits 和 concept 能够处理的只有对 current instantiation 的判断。</p><p>如果添加一个和第二个 <code>f</code> 相似，但是参数列表改成 <code>(...)</code> 的函数模板，则也能够在给定参数类型时匹配（不给就同样无法推导类型），但是由于 <code>varargs</code> 的优先级太低，所以编译器仍然会选中第一个 <code>f</code> ，然后在实例化时编译错误。</p><h2 id=异常声明不是立即上下文>异常声明不是立即上下文
<a class=header-anchor href=#%e5%bc%82%e5%b8%b8%e5%a3%b0%e6%98%8e%e4%b8%8d%e6%98%af%e7%ab%8b%e5%8d%b3%e4%b8%8a%e4%b8%8b%e6%96%87></a></h2><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>f</span>(T, <span style=color:#dc322f>int</span>) <span style=color:#719e07>noexcept</span>(nonexistent(T())); <span style=color:#586e75>// #1
</span></span></span><span style=display:flex><span><span style=color:#586e75>// 用 throw(typename T::Nonexistent) 也是被选中但是不能编译
</span></span></span><span style=display:flex><span><span style=color:#586e75>// 不过显式异常声明已经在 C++17 被移除了
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#719e07>template</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>f</span>(T, ...); <span style=color:#586e75>// #2 (C-style vararg function)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#dc322f>void</span> <span style=color:#268bd2>test</span>(<span style=color:#dc322f>int</span> i) {
</span></span><span style=display:flex><span>    f(i, i); <span style=color:#586e75>// ERROR: chooses #1 , but the expression nonexistent(T()) is ill-formed
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>上面代码中 <code>#1</code> 会被选中，因为异常声明不是立即上下文。</p><h1 id=auto-关键字>auto 关键字
<a class=header-anchor href=#auto-%e5%85%b3%e9%94%ae%e5%ad%97></a></h1><p>C++17 允许在模板中使用 auto 关键字。就算不在模板中使用，<code>auto</code> 本身也多少带点模板推导的意味。</p><h2 id=构造一个能够操作对象成员自增的-handle>构造一个能够操作对象成员自增的 handle
<a class=header-anchor href=#%e6%9e%84%e9%80%a0%e4%b8%80%e4%b8%aa%e8%83%bd%e5%a4%9f%e6%93%8d%e4%bd%9c%e5%af%b9%e8%b1%a1%e6%88%90%e5%91%98%e8%87%aa%e5%a2%9e%e7%9a%84-handle></a></h2><p><img src=/assets/15885c4217279a0cdf53e2064b5c49fb.webp></p><p><img src=/assets/163bf876df84759769551820439b10ae.webp></p><h2 id=强制-auto-推导中所有参数类型一致>强制 <code>auto...</code> 推导中所有参数类型一致
<a class=header-anchor href=#%e5%bc%ba%e5%88%b6-auto-%e6%8e%a8%e5%af%bc%e4%b8%ad%e6%89%80%e6%9c%89%e5%8f%82%e6%95%b0%e7%b1%bb%e5%9e%8b%e4%b8%80%e8%87%b4></a></h2><p><img src=/assets/10c1cbc02178d0f6d25296ab8c56cf6f.webp></p><p>缺点是不能表达空参数。</p><h2 id=decltypeauto><code>decltype(auto)</code>
<a class=header-anchor href=#decltypeauto></a></h2><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;type_traits&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span><span style=color:#719e07>const</span> <span style=color:#dc322f>int</span> four <span style=color:#719e07>=</span> <span style=color:#2aa198>4</span>;
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#719e07>auto</span> f <span style=color:#719e07>=</span> []() <span style=color:#719e07>-&gt;</span> <span style=color:#dc322f>int</span> { <span style=color:#719e07>return</span> <span style=color:#2aa198>5</span>; };
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>add_const_t<span style=color:#719e07>&lt;</span><span style=color:#719e07>decltype</span>(f())<span style=color:#719e07>&gt;</span> x <span style=color:#719e07>=</span> f();
</span></span><span style=display:flex><span>    <span style=color:#719e07>decltype</span>(<span style=color:#719e07>auto</span>) y <span style=color:#719e07>=</span> f();
</span></span><span style=display:flex><span>    <span style=color:#586e75>// decltype(auto) const z = f(); // error
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>decltype</span>(<span style=color:#719e07>auto</span>) a <span style=color:#719e07>=</span> (four);
</span></span><span style=display:flex><span>    <span style=color:#719e07>decltype</span>(<span style=color:#719e07>auto</span>) b <span style=color:#719e07>=</span> four;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>decltype(auto)</code> 只能直接使用，不能添加 <code>const</code> 之类的修饰符（<code>auto</code> 可以）。</li><li>加括号会相当于从 <code>T</code> 到 <code>T &</code> 的变换。比如 <code>a</code> 是 <code>const int &</code> 类型，而 <code>b</code> 是 <code>const int</code> 类型。</li></ul><h2 id=使用一个-auto-声明多个变量>使用一个 <code>auto</code> 声明多个变量
<a class=header-anchor href=#%e4%bd%bf%e7%94%a8%e4%b8%80%e4%b8%aa-auto-%e5%a3%b0%e6%98%8e%e5%a4%9a%e4%b8%aa%e5%8f%98%e9%87%8f></a></h2><p>不推荐，因为会共享同一个参数 <code>T</code>。</p><p><img src=/assets/f369bf78c8c9fc1e1635fb7191277855.webp></p><p>上面第三行推导失败，因为字符类型做算数运算会被整型提升，然后 e 和 f 的类型就不匹配了。</p><h2 id=返回值用-auto-推导但函数有多个分支>返回值用 <code>auto</code> 推导，但函数有多个分支
<a class=header-anchor href=#%e8%bf%94%e5%9b%9e%e5%80%bc%e7%94%a8-auto-%e6%8e%a8%e5%af%bc%e4%bd%86%e5%87%bd%e6%95%b0%e6%9c%89%e5%a4%9a%e4%b8%aa%e5%88%86%e6%94%af></a></h2><p><img src=/assets/70abb13ded526610a99c2975e853ed49.webp></p><p>类型无法推导。</p><h2 id=auto-类型推导构成循环依赖><code>auto</code> 类型推导构成循环依赖
<a class=header-anchor href=#auto-%e7%b1%bb%e5%9e%8b%e6%8e%a8%e5%af%bc%e6%9e%84%e6%88%90%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96></a></h2><p><img src=/assets/feab583f2cedeb032daacf73cd454706.webp></p><h1 id=结构化绑定structured-binding>结构化绑定（Structured Binding）
<a class=header-anchor href=#%e7%bb%93%e6%9e%84%e5%8c%96%e7%bb%91%e5%ae%9astructured-binding></a></h1><p><a href=https://en.cppreference.com/w/cpp/language/structured_binding title="Structured binding declaration (since C++17) - cppreference.com" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Structured binding declaration (since C++17) - cppreference.com<i class="fa fa-external-link-alt"></i></a></p><p><strong>结构化绑定的要求比聚合类的限制要弱一些</strong>，需要满足三个条件之一：</p><ol><li>C-style 数组。</li><li>提供了模板方法重载，使得类型能够表现得像 tuple 一样的那些类。</li><li>其他满足条件的类：<ul><li>不能有匿名 union 成员。</li><li>如果类型有非 public 成员，需要上下文有访问权限（e.g. 子类方法访 protected 成员，友元函数等）。</li></ul></li></ol><p><img src=/assets/1a0439f3069b768a3386ba415946732a.webp></p><p>可以绑定数组或者对数组的引用：</p><p><img src=/assets/4c173a6ec5f48dcf85b0815731d237bd.webp></p><p>可以绑定 <em>std::tuple-like classes</em> 。比如为类 <code>M</code> 添加绑定，需要增加：</p><ol><li><code>template&lt;> struct std::tuple_size&lt;M> { ? value = ?; };</code> 即 <code>std::tuple_size</code> 类模板的特化，使用静态常量提供元组的长度。</li><li><code>template&lt;> struct std::tuple_element&lt;0, M> { using type = ?; };</code> 即为每个元素说明类型。这里只说明了第 0 个元素类型，后面的省略了。使用偏特化则可以同时说明多个类型。（不过一行一个类型复制粘贴真的很简单）</li><li>特化 <code>get</code> 函数模板：</li></ol><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span><span style=color:#719e07>&gt;</span> <span style=color:#719e07>auto</span> get(M);
</span></span><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;&gt;</span> <span style=color:#719e07>auto</span> get<span style=color:#719e07>&lt;</span><span style=color:#2aa198>0</span><span style=color:#719e07>&gt;</span>(M) { <span style=color:#719e07>return</span> <span style=color:#2aa198>42</span>; }
</span></span><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;&gt;</span> <span style=color:#719e07>auto</span> get<span style=color:#719e07>&lt;</span><span style=color:#2aa198>1</span><span style=color:#719e07>&gt;</span>(M) { <span style=color:#719e07>return</span> <span style=color:#2aa198>7.0</span>; }
</span></span></code></pre></div><p>实际代码看上去还是比较紧凑的：</p><p><img src=/assets/0d5d1096f56a07a271fe3f835d028923.webp></p><h1 id=class-template-argument-deduction-ctad>Class template argument deduction (CTAD)
<a class=header-anchor href=#class-template-argument-deduction-ctad></a></h1><p><a href=https://en.cppreference.com/w/cpp/language/class_template_argument_deduction title="Class template argument deduction (CTAD) (since C++17) - cppreference.com" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Class template argument deduction (CTAD) (since C++17) - cppreference.com<i class="fa fa-external-link-alt"></i></a></p><p>这让创建一些类型变得更加简单：</p><p><a href=https://en.cppreference.com/w/cpp/utility/pair title=std::pair rel="noopener external nofollow noreferrer" target=_blank class=exturl>std::pair<i class="fa fa-external-link-alt"></i></a> <code>p(2, 4.5); // deduces to std::pair&lt;int, double> p(2, 4.5);</code></p><p><a href=https://en.cppreference.com/w/cpp/utility/tuple title=std::tuple rel="noopener external nofollow noreferrer" target=_blank class=exturl>std::tuple<i class="fa fa-external-link-alt"></i></a> <code>t(4, 3, 2.5); // same as auto t = std::make_tuple(4, 3, 2.5);</code></p><p>Deduction guide 可见：
<a href=/cpp-templates-the-complete-guide/02-Class-Templates/ title="02 Class Templates">02 Class Templates</a>。</p><h2 id=单括号初始化更偏向复制移动构造>单括号初始化更偏向复制/移动构造
<a class=header-anchor href=#%e5%8d%95%e6%8b%ac%e5%8f%b7%e5%88%9d%e5%a7%8b%e5%8c%96%e6%9b%b4%e5%81%8f%e5%90%91%e5%a4%8d%e5%88%b6%e7%a7%bb%e5%8a%a8%e6%9e%84%e9%80%a0></a></h2><p>单元素的括号初始化（brace initializer）和多元素的括号初始化推导规则不同。单元素的会优先推导成模板类以确保复制或移动行为的发生：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#719e07>::</span>vector v{<span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span>}; <span style=color:#586e75>// vector&lt;int&gt;, not surprising
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>std<span style=color:#719e07>::</span>vector w2{v, v};   <span style=color:#586e75>// vector&lt;vector&lt;int&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>std<span style=color:#719e07>::</span>vector w1{v};      <span style=color:#586e75>// **vector&lt;int&gt;** !!!
</span></span></span></code></pre></div><h2 id=原始模板类有隐式推导规则>原始模板类有隐式推导规则
<a class=header-anchor href=#%e5%8e%9f%e5%a7%8b%e6%a8%a1%e6%9d%bf%e7%b1%bb%e6%9c%89%e9%9a%90%e5%bc%8f%e6%8e%a8%e5%af%bc%e8%a7%84%e5%88%99></a></h2><p>每个原始类模板（primary class template）的构造函数都有隐式的 deduction guide，除非参数不在 deduced context 中。（即便显式声明了这样的推导规则，也无法匹配上；也可以认为是每个原始类模板都有规则，只是匹配失败了。）</p><h2 id=injected-class-names>Injected Class Names
<a class=header-anchor href=#injected-class-names></a></h2><p><img src=/assets/c3de7e86b0aba0681f1fd0901a5af562.webp></p><p>在 C++14 中带注释行的 <code>X</code> 指的是被注入的类名。但是按照 C++17 的 <code>CTAD</code> 也可以指隐式推导的类名 <code>X</code>，这样其参数就不一定和注入类名一致。<strong>为了不和原来的代码冲突，此时规定一律使用注入的类名。</strong></p><h2 id=forwarding-references>Forwarding References
<a class=header-anchor href=#forwarding-references></a></h2><p>假设有两条规则：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T<span style=color:#719e07>&gt;</span> Y(T <span style=color:#719e07>const</span><span style=color:#719e07>&amp;</span>) <span style=color:#719e07>-&gt;</span> Y<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span>; <span style=color:#586e75>// #1
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>template</span><span style=color:#719e07>&lt;</span><span style=color:#719e07>typename</span> T<span style=color:#719e07>&gt;</span> Y(T<span style=color:#719e07>&amp;&amp;</span>) <span style=color:#719e07>-&gt;</span> Y<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span>;      <span style=color:#586e75>// #2
</span></span></span></code></pre></div><p>在面对非 <code>const</code> 左值引用时，<code>#2</code> 的匹配度更高（<code>#1</code> 需要添加 <code>const</code> 属性），这有时候会有意外的结果。因此在 <code>T</code> 本身为类模板的参数时禁用了其对引用的匹配（P319）：</p><blockquote><p>The C++ standardization committee therefore decided to disable the special deduction rule for T&& when performing deduction for implicit deduction guides if the T was originally a class template parameter (as opposed to a constructor template parameter; for those, the special deduction rule remains).</p></blockquote></div><footer class=post-footer><div class=post-tags><a href=/tags/cpp>cpp
</a><a href=/tags/cpp-templates-the-complete-guide>cpp-templates-the-complete-guide</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/cpp-templates-the-complete-guide/13-Names-in-Templates/ rel=next title="CTTCG 13 Names in Templates"><i class="fa fa-chevron-left"></i> CTTCG 13 Names in Templates</a></div><div class="post-nav-prev post-nav-item"><a href=/cpp-templates-the-complete-guide/16-Specializations-and-Overloading/ rel=prev title="CTTCG 16 Specializations and Overloading">CTTCG 16 Specializations and Overloading
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>