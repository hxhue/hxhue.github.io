<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Bluegill</title><link>https://hxhue.github.io/posts/</link><description>Recent content in Posts on Bluegill</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sat, 04 Oct 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://hxhue.github.io/posts/rss.xml" rel="self" type="application/rss+xml"/><item><title>CUDA_DEVICE_MAX_CONNECTIONS</title><link>https://hxhue.github.io/posts/ai-infra/CUDA_DEVICE_MAX_CONNECTIONS/</link><pubDate>Sun, 07 Sep 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/ai-infra/CUDA_DEVICE_MAX_CONNECTIONS/</guid><description>&lt;h1 id="环境变量解释">环境变量解释
&lt;a class="header-anchor" href="#%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e8%a7%a3%e9%87%8a">&lt;/a>
&lt;/h1>&lt;p>&lt;code>CUDA_DEVICE_MAX_CONNECTIONS&lt;/code> 这个环境变量在 Megatron-LM 源码中经常见到，主要是用来控制硬件调度 kernel 的顺序，以尽可能提高通信计算重叠场景的重叠率。&lt;/p>
&lt;p>&lt;a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-environment-variables" title="英伟达文档 cuda-environment-variables" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >英伟达文档 cuda-environment-variables&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 说明了 &lt;code>CUDA_DEVICE_MAX_CONNECTIONS&lt;/code> 默认为 8，可以设置为 1 到 32 的整数值，表示计算和拷贝队列的数量。（同样还有 &lt;code>CUDA_DEVICE_MAX_COPY_CONNECTIONS&lt;/code> 表示对拷贝队列的设置（优先级高于 &lt;code>CUDA_DEVICE_MAX_CONNECTION&lt;/code>）。）&lt;a href="https://forums.developer.nvidia.com/t/cuda-device-max-connections-and-pci-e-traffic/262962/2" title="论坛回复" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >论坛回复&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 指出这个环境变量表示有多少个硬件队列和 CUDA 流发生映射关系。（如果这个值不够大则流之间存在虚假依赖。这样一来，设置为 1 就能完全保证 kernel 执行顺序和发起顺序一致。设置为 32 则尽可能设法让不同的流并发执行 kernels。）&lt;/p></description></item><item><title>Megatron-LM 论文 PP 和 VPP 画法疑问</title><link>https://hxhue.github.io/posts/ai-infra/Megatron-LM-%E8%AE%BA%E6%96%87-PP-%E5%92%8C-VPP-%E7%94%BB%E6%B3%95%E7%96%91%E9%97%AE/</link><pubDate>Sun, 07 Sep 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/ai-infra/Megatron-LM-%E8%AE%BA%E6%96%87-PP-%E5%92%8C-VPP-%E7%94%BB%E6%B3%95%E7%96%91%E9%97%AE/</guid><description>&lt;h1 id="问题">问题
&lt;a class="header-anchor" href="#%e9%97%ae%e9%a2%98">&lt;/a>
&lt;/h1>&lt;p>见到过两种画法：一是 device 1 调度到 PP*VPP 个微批次之后继续调度，二是 device 1 调度到 PP*VPP 微批次之后就停下了。&lt;/p>
&lt;h1 id="来源-1megatron-lm-论文">来源 1：Megatron-LM 论文
&lt;a class="header-anchor" href="#%e6%9d%a5%e6%ba%90-1megatron-lm-%e8%ae%ba%e6%96%87">&lt;/a>
&lt;/h1>&lt;p>这个是 Megatron 的论文 Efficient Large-Scale Language Model Training on GPU Clusters Using Megatron-LM 第 3 页 &lt;a href="https://arxiv.org/pdf/2104.04473" title="https://arxiv.org/pdf/2104.04473" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://arxiv.org/pdf/2104.04473&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> ，同时显示了交错和非交错状态下 1F1B 的调度方式。&lt;/p></description></item><item><title>大模型训练通信要解决哪些问题？（个人总结）</title><link>https://hxhue.github.io/posts/ai-infra/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E9%80%9A%E4%BF%A1%E8%A6%81%E8%A7%A3%E5%86%B3%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 07 Sep 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/ai-infra/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E9%80%9A%E4%BF%A1%E8%A6%81%E8%A7%A3%E5%86%B3%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</guid><description>&lt;h1 id="结构图">结构图
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84%e5%9b%be">&lt;/a>
&lt;/h1>&lt;p>






&lt;img src="https://hxhue.github.io/posts/ai-infra/assets/Pasted%20image%2020250907125720.webp" width="600">&lt;/p>
&lt;h1 id="加速通信">加速通信
&lt;a class="header-anchor" href="#%e5%8a%a0%e9%80%9f%e9%80%9a%e4%bf%a1">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>减少给定操作的通信量
&lt;ul>
&lt;li>低精度训练&lt;/li>
&lt;li>先量化再通信
&lt;ul>
&lt;li>DeepSeek V3 dispatch 时先把 BF16 量化到 FP8，通信量减少一半。但因为 combine 通信中带有规约，所以不适合用 FP8。&lt;/li>
&lt;li>MegaScale-MoE 在 AllGather 派发器的 combine 阶段用 &lt;strong>(a)&lt;/strong> 量化到 FP8 + &lt;strong>(b)&lt;/strong> AlltoAll + &lt;strong>(c)&lt;/strong> FP32 累加器规约 来代替原先的 ReduceScatter 通信，通信量减少一半、loss 正常。ReduceScatter 时每个 rank 只需要收到自己分区的所有数据并完成规约即可（不像 AllGather 接口需要所有数据），用 AlltoAll + 接收后本地规约也能替代。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通信去重
&lt;ul>
&lt;li>DeepEP&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>减少通信
&lt;ul>
&lt;li>尽可能使用效率更高的并行方式，比如用 Ulysses SP 代替 TP 可以从理论上大大降低通信。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="保持计算流忙碌">保持计算流忙碌
&lt;a class="header-anchor" href="#%e4%bf%9d%e6%8c%81%e8%ae%a1%e7%ae%97%e6%b5%81%e5%bf%99%e7%a2%8c">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>通信计算重叠
&lt;ul>
&lt;li>Megatron-LM 现在对 DP/TP/CP/PP/EP 均有通信重叠功能
&lt;ul>
&lt;li>部分选项依赖 &lt;code>CUDA_DEVICE_MAX_CONNECTIONS&lt;/code>&lt;/li>
&lt;li>部分选项依赖交错 1F1B 调度&lt;/li>
&lt;li>Megatron CP 的通信计算重叠强制打开、无选项可以关闭&lt;/li>
&lt;li>Megatron 1F1B + EP A2A overlap 是 2025.8 才加入的新功能，但在 2025.3 已有人提出&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DualPipe 用前反向两个微批次的前后向来重叠&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>负载均衡
&lt;ul>
&lt;li>DP/PP 负载均衡
&lt;ul>
&lt;li>ByteScale 的工作很有启发性&lt;/li>
&lt;li>Ernie 4.5 也做了 DP 上的子序列重排&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EP 负载均衡
&lt;ul>
&lt;li>token drop、辅助 loss、expert bias&lt;/li>
&lt;li>专家动态调整，这一类工作很多&lt;/li>
&lt;li>样本动态调整，如 NetMoE&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CP 负载均衡
&lt;ul>
&lt;li>Ulysses SP&lt;/li>
&lt;li>Megatron CP 未考虑子序列打包的问题，ByteScale 做了一些处理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>消除卡间同步
&lt;ul>
&lt;li>ZeroBubble 后校验&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>DeepSeek V3 MLA</title><link>https://hxhue.github.io/posts/ai-infra/DeepSeek-V3-MLA/</link><pubDate>Thu, 21 Aug 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/ai-infra/DeepSeek-V3-MLA/</guid><description>&lt;p>下图标注了 MLA 的一种计算方式，橙色虚线部分可以被包裹到重计算中，入口为 q1，kv1 和 k_rope1（不保存 kv1 和 k_rope1 而是保存 kv1_and_k_rope 也可以，它们的大小一样，没区别）。&lt;code>flash_attn&lt;/code> 比较特殊，除了保存输入之外还会保存输出。&lt;/p></description></item><item><title>MoE Parallel Folding、ETP 和 DeepEP</title><link>https://hxhue.github.io/posts/ai-infra/MoE-Parallel-FoldingETP-%E5%92%8C-DeepEP/</link><pubDate>Mon, 18 Aug 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/ai-infra/MoE-Parallel-FoldingETP-%E5%92%8C-DeepEP/</guid><description>&lt;p>DeepEP 假设了本地 node 用 NVLINK 连接的卡数为 8，因此 EP 必须在最内层。Megatron 在 MoEFlexTokenDispatcher 接入 DeepEP，也必须满足这个假设。&lt;/p>
&lt;p>在 &lt;a href="https://arxiv.org/html/2504.14960v2" title="MoE Parallel Folding" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >MoE Parallel Folding&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 下，MoE 层的 CP 消失，排在 EP 内层的只有 TP，Megatron 是如何处理 ETP &amp;gt; 1 的情况的？它将 routing map 展开了 tp_size 份，直接用 DeepEP 分发（&lt;strong>这个时候使用 TP-EP 组而不是 EP 组，大小为 &lt;code>ep_size * tp_size&lt;/code>&lt;/strong>），这样就满足了 DeepEP 的假设，实质上利用 DeepEP 把 TP 的通信也做了。&lt;/p></description></item><item><title>NVIDIA 博客：NCCL 2.12 PXN 优化</title><link>https://hxhue.github.io/posts/ai-infra/NVIDIA-%E5%8D%9A%E5%AE%A2NCCL-2.12-PXN-%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 18 Aug 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/ai-infra/NVIDIA-%E5%8D%9A%E5%AE%A2NCCL-2.12-PXN-%E4%BC%98%E5%8C%96/</guid><description>&lt;h2 id="文章总结">文章总结
&lt;a class="header-anchor" href="#%e6%96%87%e7%ab%a0%e6%80%bb%e7%bb%93">&lt;/a>
&lt;/h2>&lt;p>&lt;a href="https://developer.nvidia.com/blog/doubling-all2all-performance-with-nvidia-collective-communication-library-2-12/" title="https://developer.nvidia.com/blog/doubling-all2all-performance-with-nvidia-collective-communication-library-2-12/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://developer.nvidia.com/blog/doubling-all2all-performance-with-nvidia-collective-communication-library-2-12/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;div class="markdown-alert markdown-alert-caution">
 &lt;p class="markdown-alert-title">&lt;svg class="octicon octicon-stop mr-2" viewBox="0 0 16 16" width="16" height="16"
 aria-hidden="true">
 &lt;path
 d="M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
 &lt;/path>
 &lt;/svg>内容由 AI 生成&lt;/p></description></item><item><title>diff 两个文件夹</title><link>https://hxhue.github.io/posts/cli/bash/diff-%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9/</link><pubDate>Thu, 10 Jul 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/diff-%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>diff -bur folderA/ folderB/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>-r&lt;/code> 表示递归，&lt;code>-b&lt;/code> 表示忽略空白字符，&lt;code>-u&lt;/code> 表示输出统一样式（也就是 git diff 常见的样式，会比默认样式容易阅读）。&lt;/p></description></item><item><title>PyTorch C++ 代码生成</title><link>https://hxhue.github.io/posts/programming/python/2.-PyTorch-C++-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</link><pubDate>Mon, 30 Jun 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/2.-PyTorch-C++-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</guid><description>&lt;h1 id="一些问题">一些问题
&lt;a class="header-anchor" href="#%e4%b8%80%e4%ba%9b%e9%97%ae%e9%a2%98">&lt;/a>
&lt;/h1>&lt;p>为什么有些会生成 at::cuda 名字空间的函数，有些不会？（待解决）&lt;/p>
&lt;h1 id="提要">提要
&lt;a class="header-anchor" href="#%e6%8f%90%e8%a6%81">&lt;/a>
&lt;/h1>&lt;p>&lt;strong>本文说明了 &lt;code>m.impl(&amp;quot;index_put.out&amp;quot;, ...)&lt;/code> 到 &lt;code>at::native::index_put&lt;/code> 的调用路径&lt;/strong>。结合 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/posts/programming/python/1.-PyTorch-C&amp;#43;&amp;#43;-%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91/" title="PyTorch C&amp;#43;&amp;#43; 函数派发" >PyTorch C++ 函数派发&lt;/a> 中 &lt;code>at::native::index_put_&lt;/code> → &lt;code>at::_index_put_impl_&lt;/code> → &lt;code>index_put_stub&lt;/code> 的调用路径，补全了从 m.impl 到 stub 的全路径。&lt;/p></description></item><item><title>PyTorch C++ 函数派发</title><link>https://hxhue.github.io/posts/programming/python/1.-PyTorch-C++-%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91/</link><pubDate>Mon, 30 Jun 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/1.-PyTorch-C++-%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91/</guid><description>&lt;h1 id="stub-注册流程">Stub 注册流程
&lt;a class="header-anchor" href="#stub-%e6%b3%a8%e5%86%8c%e6%b5%81%e7%a8%8b">&lt;/a>
&lt;/h1>&lt;p>所有的 stub 定义几乎都在 aten/src/ATen/native/DispatchStub.h 文件，可以慢慢看。里面有段注释：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// Implements instruction set specific function dispatch.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// Kernels that may make use of specialized instruction sets (e.g. AVX2) are
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// compiled multiple times with different compiler flags (e.g. -mavx2). A
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// DispatchStub contains a table of function pointers for a kernel. At runtime,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// the fastest available kernel is chosen based on the features reported by
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// cpuinfo.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// Example:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// In native/MyKernel.h:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// using fn_type = void(*)(const Tensor&amp;amp; x);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// DECLARE_DISPATCH(fn_type, stub)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// In native/MyKernel.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// DEFINE_DISPATCH(stub);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// In native/cpu/MyKernel.cpp:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// namespace {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// // use anonymous namespace so that different cpu versions won&amp;#39;t conflict
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// void kernel(const Tensor&amp;amp; x) { ... }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// REGISTER_DISPATCH(stub, &amp;amp;kernel);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// To call:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// stub(kCPU, tensor);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// TODO: CPU instruction set selection should be folded into whatever
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// the main dispatch mechanism is.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// Supported device types for registration:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// - CPU: Central Processing Unit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// - CUDA: NVIDIA GPUs
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// - HIP: AMD GPUs
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// - MPS: Apple Silicon GPUs (Metal Performance Shaders)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// - MTIA: Meta Training and Inference Devices
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// - XPU: Intel GPUs
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// - HPU: Reserved for HPU (Intel Gaudi) device types
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// - PrivateUse1: Reserved for private/custom device types
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// If you want to update the list of supported devices, add a new dispatch_ptr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// member in DispatchStubImpl.h and update the get_call_ptr switch.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// As well you will need to update the inlined list in &amp;#39;is_device_supported`
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// ignore warnings about DispatchStub::DEFAULT, AVX, AVX2 defined elsewhere
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="dispatchstub-模板基类定义">&lt;code>DispatchStub&lt;/code> 模板基类定义
&lt;a class="header-anchor" href="#dispatchstub-%e6%a8%a1%e6%9d%bf%e5%9f%ba%e7%b1%bb%e5%ae%9a%e4%b9%89">&lt;/a>
&lt;/h1>&lt;p>见 aten/src/ATen/native/DispatchStub.h。&lt;code>DispatchStub&lt;/code> 类型为：&lt;/p></description></item><item><title>在服务器上使用 sing-box 代理</title><link>https://hxhue.github.io/posts/cli/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8-sing-box-%E4%BB%A3%E7%90%86/</link><pubDate>Thu, 01 May 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8-sing-box-%E4%BB%A3%E7%90%86/</guid><description>&lt;h1 id="背景">背景
&lt;a class="header-anchor" href="#%e8%83%8c%e6%99%af">&lt;/a>
&lt;/h1>&lt;p>服务器上面不能科学上网。以前都是直接 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/posts/cli/ssh/ssh-%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%A4%96%E7%BD%91/" title="用 ssh 做代理转发" >用 ssh 做代理转发&lt;/a> 的，但是现在在校外只能使用 rvpn，连接非常不稳定，也无法大流量传输文件，只能考虑在服务器上直接上网。&lt;/p></description></item><item><title>实验室服务器故障（续）</title><link>https://hxhue.github.io/posts/systems/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%85%E9%9A%9C%E7%BB%AD/</link><pubDate>Sun, 27 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%85%E9%9A%9C%E7%BB%AD/</guid><description>&lt;h1 id="背景">背景
&lt;a class="header-anchor" href="#%e8%83%8c%e6%99%af">&lt;/a>
&lt;/h1>&lt;p>本文是 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/posts/systems/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8-ssh-%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5/" title="实验室服务器 ssh 无法连接" >实验室服务器 ssh 无法连接&lt;/a> 的后续。&lt;/p>
&lt;p>今天同学又告诉我发生了类似的情况，师兄已经在找人维修。&lt;/p>
&lt;p>我连接上去看了服务器重启时间约 10 点。又看了几个信息：&lt;/p></description></item><item><title>验证父进程被杀死后僵尸会被 init 进程收养</title><link>https://hxhue.github.io/posts/systems/Linux/%E9%AA%8C%E8%AF%81%E7%88%B6%E8%BF%9B%E7%A8%8B%E8%A2%AB%E6%9D%80%E6%AD%BB%E5%90%8E%E5%83%B5%E5%B0%B8%E4%BC%9A%E8%A2%AB-init-%E8%BF%9B%E7%A8%8B%E6%94%B6%E5%85%BB/</link><pubDate>Mon, 21 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E9%AA%8C%E8%AF%81%E7%88%B6%E8%BF%9B%E7%A8%8B%E8%A2%AB%E6%9D%80%E6%AD%BB%E5%90%8E%E5%83%B5%E5%B0%B8%E4%BC%9A%E8%A2%AB-init-%E8%BF%9B%E7%A8%8B%E6%94%B6%E5%85%BB/</guid><description>&lt;h1 id="过程">过程
&lt;a class="header-anchor" href="#%e8%bf%87%e7%a8%8b">&lt;/a>
&lt;/h1>&lt;p>首先，创建一个 docker 容器，其 entrypoint 不是可回收子进程（init-like）的命令，也不要加上 &lt;code>--init&lt;/code> 选项。这样即便僵尸被 init 进程收养，也不会被马上回收，方便观察。&lt;/p></description></item><item><title>Python 多进程脚本的常见问题</title><link>https://hxhue.github.io/posts/programming/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%84%9A%E6%9C%AC%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 20 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%84%9A%E6%9C%AC%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="占用过多内存">占用过多内存
&lt;a class="header-anchor" href="#%e5%8d%a0%e7%94%a8%e8%bf%87%e5%a4%9a%e5%86%85%e5%ad%98">&lt;/a>
&lt;/h1>&lt;p>TL;DR：大多是具体脚本的问题，不好处理。有的是没有及时 gc，有的是把所有数据全部载入内存之后（假设了内存足够大）才开始处理。&lt;/p>
&lt;p>我是遇到了这样一个问题：
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/%E7%9F%A5%E8%AF%86%E5%88%86%E7%B1%BB/1.-%E8%AE%B0%E5%BD%95/projects/megatron-lm/megatron-lm/#%e8%b5%84%e6%ba%90%e5%8d%a0%e7%94%a8%e5%a4%a7%e6%9c%89%e5%83%b5%e5%b0%b8" title="megatron-lm huggingface 教程运行时资源占用大、有僵尸" >megatron-lm huggingface 教程运行时资源占用大、有僵尸&lt;/a>（&lt;span style="color:red">2025/4/22 文章还在修改中，尚未公开&lt;/span>）。&lt;/p></description></item><item><title>tmux attach 的时候出现转义字符序列</title><link>https://hxhue.github.io/posts/developer/tmux-attach-%E7%9A%84%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97/</link><pubDate>Sun, 20 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/tmux-attach-%E7%9A%84%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97/</guid><description>&lt;p>Windows Terminal 的问题，换成 Alacritty 就好了。&lt;/p>
&lt;p>不过 Alacritty 又有别的问题，在 vim 中粘贴文本的时候 &lt;code>\r\n&lt;/code> 会被转换成 &lt;code>\n\n&lt;/code>，导致换行数量加倍，每两行中间会多出来一个空行。参考 &lt;a href="https://github.com/alacritty/alacritty/issues/2324#issuecomment-2408742541" title="WSL &amp;#43; ConPTY &amp;#43; vim -&amp;gt; paste with blanks lines · Issue #2324 · alacritty/alacritty" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >WSL + ConPTY + vim -&amp;gt; paste with blanks lines · Issue #2324 · alacritty/alacritty&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 在 vim 中 &lt;code>：set term=ansi&lt;/code> 可以工作。&lt;/p></description></item><item><title>实验室服务器 ssh 无法连接</title><link>https://hxhue.github.io/posts/systems/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8-ssh-%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5/</link><pubDate>Fri, 18 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8-ssh-%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5/</guid><description>&lt;h1 id="事情由来">事情由来
&lt;a class="header-anchor" href="#%e4%ba%8b%e6%83%85%e7%94%b1%e6%9d%a5">&lt;/a>
&lt;/h1>&lt;p>实验室在今年初安装了两台新的服务器，IP 最后一个段分别为 149 和 150，后文将用这两个数字来指代服务器。据说 149 服务器网络出现故障。&lt;/p>
&lt;h1 id="检查网络配置非原因可以跳过">检查网络配置（非原因，可以跳过）
&lt;a class="header-anchor" href="#%e6%a3%80%e6%9f%a5%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae%e9%9d%9e%e5%8e%9f%e5%9b%a0%e5%8f%af%e4%bb%a5%e8%b7%b3%e8%bf%87">&lt;/a>
&lt;/h1>&lt;p>用 &lt;code>journalctl&lt;/code> 看日志说 dhcp4 失败。包失败的，服务器都是静态 ip，没有配置 dhcp 服务器。为什么明明是静态 ip 却要尝试使用 dhcp 服务器呢？&lt;/p></description></item><item><title>VS Code 远程文件传输慢，寻找替代方案</title><link>https://hxhue.github.io/posts/cli/ssh/VS-Code-%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%85%A2%E5%AF%BB%E6%89%BE%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 14 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/ssh/VS-Code-%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%85%A2%E5%AF%BB%E6%89%BE%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</guid><description>&lt;h1 id="说明">说明
&lt;a class="header-anchor" href="#%e8%af%b4%e6%98%8e">&lt;/a>
&lt;/h1>&lt;p>从 Windows 的资源管理器拖动文件到连接到远程服务器的 VS Code 窗口，或者从 VS Code 文件目录下载文件，速度都比 scp 慢得多（3M/s VS 20M/s）。此文章尝试寻求其他替代方案。&lt;/p></description></item><item><title>draw.io 图像导出的几个问题</title><link>https://hxhue.github.io/posts/unsorted/draw.io-%E5%9B%BE%E5%83%8F%E5%AF%BC%E5%87%BA%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 11 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/unsorted/draw.io-%E5%9B%BE%E5%83%8F%E5%AF%BC%E5%87%BA%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="起因">起因
&lt;a class="header-anchor" href="#%e8%b5%b7%e5%9b%a0">&lt;/a>
&lt;/h1>&lt;p>今天同门遇到了一些 draw.io 图像导出的问题，我和他一起分析定位了原因。&lt;/p>
&lt;h1 id="drawio-论文画图三宗罪">draw.io 论文画图三宗罪
&lt;a class="header-anchor" href="#drawio-%e8%ae%ba%e6%96%87%e7%94%bb%e5%9b%be%e4%b8%89%e5%ae%97%e7%bd%aa">&lt;/a>
&lt;/h1>&lt;p>截至 2025/4/13：&lt;/p>
&lt;ol>
&lt;li>导出 pdf 兼容性不好，得用旧版或者 ghostscript 转换。&lt;/li>
&lt;li>把 px 和 pt 混为一谈。&lt;/li>
&lt;li>px 的单位支持小数，导出时四舍五入，导致和预览时效果不一致。&lt;/li>
&lt;/ol>
&lt;p>我确实也承认 draw.io 方便，但有些地方还是很痛苦的。其他备选项：PowerPoint、Visio。&lt;/p></description></item><item><title>Python 的绝对导入和相对导入</title><link>https://hxhue.github.io/posts/programming/python/Python-%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%AF%BC%E5%85%A5%E5%92%8C%E7%9B%B8%E5%AF%B9%E5%AF%BC%E5%85%A5/</link><pubDate>Fri, 11 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/Python-%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%AF%BC%E5%85%A5%E5%92%8C%E7%9B%B8%E5%AF%B9%E5%AF%BC%E5%85%A5/</guid><description>&lt;p>&lt;strong>绝对导入&lt;/strong>需要包在 &lt;code>sys.path&lt;/code> 中，可以通过环境变量 &lt;code>PYTHONPATH&lt;/code> 来增加一些搜索路径。&lt;/p>
&lt;p>&lt;strong>相对导入&lt;/strong>需要当前在一个子包内。&lt;a href="https://stackoverflow.com/questions/16981921/relative-imports-in-python-3" title="Relative imports in Python 3 - Stack Overflow" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Relative imports in Python 3 - Stack Overflow&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 这个回答就说明如果直接运行一个包含了 &lt;code>import .xx&lt;/code> 或者 &lt;code>from .xx import xx&lt;/code> 的脚本就会失败，&lt;strong>我的直观感受&lt;/strong>是这样的文件只能出现在比 main 文件（&lt;code>__name__&lt;/code> 为 &lt;code>__main__&lt;/code> 的那个文件，也就是入口文件）更深的文件夹下。相对导入有助于避免 sys.path 中出现更靠前的搜索路径，且该路径包含同名包，导致真正要导入的包被覆盖。&lt;/p></description></item><item><title>zsh 中添加命令执行计时</title><link>https://hxhue.github.io/posts/cli/zsh/zsh-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%AE%A1%E6%97%B6/</link><pubDate>Fri, 11 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/zsh/zsh-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%AE%A1%E6%97%B6/</guid><description>&lt;p>&lt;a href="https://gist.github.com/knadh/123bca5cfdae8645db750bfb49cb44b0" title="Elapsed and execution time for commands in ZSH" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Elapsed and execution time for commands in ZSH&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>在 ~/.zshrc 文件中添加：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">function&lt;/span> preexec&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">timer&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#719e07">$(($(&lt;/span>date +%s%0N&lt;span style="color:#719e07">)&lt;/span>&lt;span style="color:#719e07">/&lt;/span>&lt;span style="color:#2aa198">1000000&lt;/span>&lt;span style="color:#719e07">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">function&lt;/span> precmd&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">[&lt;/span> &lt;span style="color:#268bd2">$timer&lt;/span> &lt;span style="color:#719e07">]&lt;/span>; &lt;span style="color:#719e07">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">now&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#719e07">$(($(&lt;/span>date +%s%0N&lt;span style="color:#719e07">)&lt;/span>&lt;span style="color:#719e07">/&lt;/span>&lt;span style="color:#2aa198">1000000&lt;/span>&lt;span style="color:#719e07">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">elapsed&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#719e07">$((&lt;/span>&lt;span style="color:#268bd2">$now&lt;/span>&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#268bd2">$timer&lt;/span>&lt;span style="color:#719e07">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b58900">export&lt;/span> &lt;span style="color:#268bd2">RPROMPT&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#34;%F{cyan}&lt;/span>&lt;span style="color:#2aa198">${&lt;/span>&lt;span style="color:#268bd2">elapsed&lt;/span>&lt;span style="color:#2aa198">}&lt;/span>&lt;span style="color:#2aa198">ms %{&lt;/span>&lt;span style="color:#268bd2">$reset_color&lt;/span>&lt;span style="color:#2aa198">%}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b58900">unset&lt;/span> timer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;mark>2025/4/20 缺点：计时显示在一行最后，每次复制终端文本会把这个时间一并复制了&lt;/mark>，而且这一行相当长导致时间显示在第二行（折行），让人摸不着头脑这个多余的文本是哪里来的。&lt;/p></description></item><item><title>libstdc++ 和 libc++ 中字符串倍增比较</title><link>https://hxhue.github.io/posts/programming/cpp/libstdc++-%E5%92%8C-libc++-%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%8D%E5%A2%9E%E6%AF%94%E8%BE%83/</link><pubDate>Sun, 06 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libstdc++-%E5%92%8C-libc++-%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%8D%E5%A2%9E%E6%AF%94%E8%BE%83/</guid><description>&lt;p>&lt;a href="https://godbolt.org/z/n8hns47M8" title="https://godbolt.org/z/n8hns47M8" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://godbolt.org/z/n8hns47M8&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>string str &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;hello&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;String: &lt;/span>&lt;span style="color:#cb4b16">\&amp;#34;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#cb4b16">\&amp;#34;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Length: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str.&lt;span style="color:#268bd2">length&lt;/span>() &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Capacity: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str.&lt;span style="color:#268bd2">capacity&lt;/span>() &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Size: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#719e07">sizeof&lt;/span>(str) &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> str &lt;span style="color:#719e07">+=&lt;/span> &lt;span style="color:#2aa198">&amp;#34; world!。。。。&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">String: &lt;/span>&lt;span style="color:#cb4b16">\&amp;#34;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#cb4b16">\&amp;#34;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Length: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str.&lt;span style="color:#268bd2">length&lt;/span>() &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Capacity: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str.&lt;span style="color:#268bd2">capacity&lt;/span>() &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Size: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#719e07">sizeof&lt;/span>(str) &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> str &lt;span style="color:#719e07">+=&lt;/span> str;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">String: &lt;/span>&lt;span style="color:#cb4b16">\&amp;#34;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#cb4b16">\&amp;#34;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Length: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str.&lt;span style="color:#268bd2">length&lt;/span>() &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Capacity: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> str.&lt;span style="color:#268bd2">capacity&lt;/span>() &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Size: &amp;#34;&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#719e07">sizeof&lt;/span>(str) &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到 libstdc++ 中的 capacity 的增长方式是 15 → 30 → 60。一开始 SSO 缓冲区只能容纳 16 个字符，最后一个字符是 &lt;code>'\0'&lt;/code>，因此初始状态下只能容纳 15 个非空字符，capacity 为 15。而后面倍增的时候会直接按照非 &lt;code>'\0'&lt;/code> 字符的最大容量来做倍增，而非按照实际缓冲区容量做倍增（即 15 → 31 → 63 这样的路径）。&lt;/p></description></item><item><title>博客主题选择、个性化设置</title><link>https://hxhue.github.io/posts/unsorted/%E4%B8%BB%E9%A2%98%E9%80%89%E6%8B%A9%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE/</link><pubDate>Sat, 05 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/unsorted/%E4%B8%BB%E9%A2%98%E9%80%89%E6%8B%A9%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE/</guid><description>&lt;p>主题是 &lt;a href="https://github.com/Hugo-next/Hugo-theme-next" title="Hugo-theme-next" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Hugo-theme-next&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>，有一些修改。虽然支持夜间模式，但是不太会调色，有一些自定义的样式在夜间模式下效果不好。所有颜色都是保证在日间模式下易读而选择的，如果夜间模式难以阅读可以切换回来。因为动画速率太慢，调快也觉得晃眼，就关掉了。&lt;/p></description></item><item><title>从按下开机键起，操作系统启动过程</title><link>https://hxhue.github.io/posts/systems/Linux/%E4%BB%8E%E6%8C%89%E4%B8%8B%E5%BC%80%E6%9C%BA%E9%94%AE%E8%B5%B7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</link><pubDate>Sat, 05 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E4%BB%8E%E6%8C%89%E4%B8%8B%E5%BC%80%E6%9C%BA%E9%94%AE%E8%B5%B7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</guid><description>&lt;p>&lt;a href="https://developer.aliyun.com/article/1123943" title="揭秘linux系统启动流程，面试官问起来再也不怕了-阿里云开发者社区" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >揭秘linux系统启动流程，面试官问起来再也不怕了-阿里云开发者社区&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>BIOS -&amp;gt; MBR -&amp;gt; Boot Loader (e.g. GRUB) -&amp;gt; kernel -&amp;gt; mount initramfs as / -&amp;gt; /init
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> / \ / |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UEFI -&amp;gt; GPT ----+ +----&amp;gt; initramfs --+ |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (memory) V
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1 load drivers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run /sbin/init &amp;lt;--- 2 mount root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3 switch root
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>运行 BIOS（现代系统是 UEFI）。&lt;/li>
&lt;li>进行开机自检（POST，即 Power-On Self-Test）。&lt;/li>
&lt;li>寻找启动设备，依次检查存储设备，如果前 512 字节最后两个字节是 0x55 和 0xaa，那么这个块就是 MBR（主引导记录，Master Boot Record），这个存储设备就含有操作系统。然后根据 MBR 的信息找到 Boot Loader 位置，将其加载并运行。&lt;strong>如果是 UEFI，UEFI 固件会读取磁盘上的 GPT (GUID Partition Table)。GPT 中有一个特殊的 EFI 系统分区 (ESP, EFI System Partition)，通常格式化为 FAT32。UEFI 固件会直接在该分区中查找并执行引导加载程序文件（通常是 .efi 文件，例如 \EFI\ubuntu\grubx64.efi 或 \EFI\BOOT\BOOTX64.EFI）&lt;/strong>。它不依赖 MBR 的 0x55AA 签名来启动。&lt;/li>
&lt;li>Linux 常见的 Boot Loader 是 GRUB。Boot Loader 能理解文件系统，能显示操作系统选择菜单和加载 Linux 内核。&lt;/li>
&lt;li>GRUB &lt;strong>加载&lt;/strong> (load) 内核 (vmlinuz-&amp;hellip;) 和 initrd/initramfs 文件 &lt;strong>到内存&lt;/strong>。加载完成后，GRUB &lt;strong>将执行控制权转交给已加载到内存中的内核&lt;/strong>。&lt;strong>然后，内核会找到内存中的 initrd/initramfs 镜像，并将其解压&lt;/strong>（如果是压缩格式，如 gzip, xz），然后将其挂载为一个 &lt;strong>临时的根文件系统 (rootfs)&lt;/strong>。&lt;/li>
&lt;li>内核&lt;strong>执行位于 initramfs 根目录下的 /init 程序&lt;/strong> (通常是一个脚本或小程序，如 dracut 或 mkinitcpio 生成的)，这个程序会&lt;strong>加载必要的驱动模块&lt;/strong>，找到真正的根设备（可能是 /dev/sda2，或者 /dev/nvme0n1p3 等），将真正的根设备挂到临时路径如 /sysroot 上，然后切换根目录并释放 initramfs 的内存。&lt;/li>
&lt;li>现在根目录已经切换好了，运行 /sbin/init 成为系统的第一个进程。&lt;strong>内核引导阶段结束，用户空间初始化开始。&lt;/strong>&lt;/li>
&lt;/ol></description></item><item><title>动态链接原理</title><link>https://hxhue.github.io/posts/systems/Linux/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 05 Apr 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%8E%9F%E7%90%86/</guid><description>&lt;h1 id="阶段">阶段
&lt;a class="header-anchor" href="#%e9%98%b6%e6%ae%b5">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>静态编辑&lt;/li>
&lt;li>动态加载&lt;/li>
&lt;li>延迟绑定&lt;/li>
&lt;/ul>
&lt;h1 id="一静态编辑">一、静态编辑
&lt;a class="header-anchor" href="#%e4%b8%80%e9%9d%99%e6%80%81%e7%bc%96%e8%be%91">&lt;/a>
&lt;/h1>&lt;p>链接器（ld）在生成可执行文件时，会记录可执行文件所依赖的共享库的名称以及需要的符号，并将这些信息存储在特定的段中（例如 .dynamic 段）。同时，它会创建 PLT（Procedure Linkage Table，过程链接表）和 GOT（Global Offset Table，全局偏移表）作为占位符，用于后续的动态链接过程。GOT 表初始时包含的是用于延迟绑定的地址，而非实际的函数地址。&lt;/p></description></item><item><title>LaTeX hyperref CJK 中文短语链接可点击范围只有其高度的一半</title><link>https://hxhue.github.io/posts/latex/LaTeX-hyperref-CJK-%E4%B8%AD%E6%96%87%E7%9F%AD%E8%AF%AD%E9%93%BE%E6%8E%A5%E5%8F%AF%E7%82%B9%E5%87%BB%E8%8C%83%E5%9B%B4%E5%8F%AA%E6%9C%89%E5%85%B6%E9%AB%98%E5%BA%A6%E7%9A%84%E4%B8%80%E5%8D%8A/</link><pubDate>Mon, 03 Mar 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/latex/LaTeX-hyperref-CJK-%E4%B8%AD%E6%96%87%E7%9F%AD%E8%AF%AD%E9%93%BE%E6%8E%A5%E5%8F%AF%E7%82%B9%E5%87%BB%E8%8C%83%E5%9B%B4%E5%8F%AA%E6%9C%89%E5%85%B6%E9%AB%98%E5%BA%A6%E7%9A%84%E4%B8%80%E5%8D%8A/</guid><description>&lt;p>LaTeX hyperref CJK 中文短语链接可点击范围只有其高度的一半。但凡其中加入了非 CJK 字符，可点击范围就会恢复正常。用 &lt;code>\vphantom&lt;/code> 没有效果，大概是因为不会真正改变 baseline。有一种方法是强制 CJK 字符和其他字符的基线对齐，但是我觉得对齐之后肯定不好看。&lt;/p></description></item><item><title>C++ 中哪些 STL 类型可以作为 map 或 unordered_map 的键？</title><link>https://hxhue.github.io/posts/programming/cpp/C++-%E4%B8%AD%E5%93%AA%E4%BA%9B-STL-%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA-map-%E6%88%96-unordered_map-%E7%9A%84%E9%94%AE/</link><pubDate>Sat, 22 Feb 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++-%E4%B8%AD%E5%93%AA%E4%BA%9B-STL-%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA-map-%E6%88%96-unordered_map-%E7%9A%84%E9%94%AE/</guid><description>&lt;p>其实是在问哪些类型有 hash 函数和重载了 &lt;code>&amp;lt;&lt;/code> 比较操作符。因为说的是 STL，所以不考虑内建类型。&lt;/p>
&lt;h1 id="可哈希和--比较">可哈希和 &lt;code>==&lt;/code> 比较
&lt;a class="header-anchor" href="#%e5%8f%af%e5%93%88%e5%b8%8c%e5%92%8c--%e6%af%94%e8%be%83">&lt;/a>
&lt;/h1>&lt;p>常见的可以哈希和 &lt;code>==&lt;/code> 比较的集合类型有（以下省略 &lt;code>std&lt;/code> 命名空间）：&lt;/p></description></item><item><title>Windows 禁用系统更新</title><link>https://hxhue.github.io/posts/systems/Windows/Windows-%E7%A6%81%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0/</link><pubDate>Thu, 13 Feb 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Windows-%E7%A6%81%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0/</guid><description>&lt;p>参考 &lt;a href="https://www.bilibili.com/opus/962604159366856745" title="B 站教程" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >B 站教程&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>。&lt;/p>
&lt;p>在注册表中，找到：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>新建 DWORD 值，名称为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>flightSettingsmaxpausedays
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>值设置大一点。这样在 Windows 更新页面的最大停止时间就可以选很长，几十周甚至几百周。不过这个数字设置太大了面板会卡住，设置到合理大就可以了，比如 3000。注意设置的时候选择&lt;strong>十进制&lt;/strong>。&lt;/p></description></item><item><title>git log --remerge-diff</title><link>https://hxhue.github.io/posts/cli/git/git-log--remerge-diff/</link><pubDate>Mon, 10 Feb 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/git/git-log--remerge-diff/</guid><description>&lt;p>&lt;code>--remerge-diff&lt;/code> 选项在 &lt;code>git log&lt;/code> 和 &lt;code>git show&lt;/code> 命令中都存在。它用更容易阅读的方式显示一个合并结点相对于两个 parent 的变化。&lt;/p>
&lt;p>下图是一个例子（&lt;a href="https://github.blog/open-source/git/highlights-from-git-2-36/#review-merge-conflict-resolution-with-remerge-diff" title="来源在这里" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >来源在这里&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>）。没用这个选项的时候会显示三路的差异，有三种颜色。只看绿色部分就是最终解决了冲突后的代码，但是看红色还得看红色是来自哪一个 parent，不够方便。&lt;/p></description></item><item><title>libstdc++ enable_shared_from_this 源码分析</title><link>https://hxhue.github.io/posts/programming/cpp/libstdc++-enable_shared_from_this-%E6%BA%90%E7%A0%81/</link><pubDate>Fri, 07 Feb 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libstdc++-enable_shared_from_this-%E6%BA%90%E7%A0%81/</guid><description>&lt;p>继承 &lt;code>std::enable_shared_from_this&lt;/code> 模板类之后就多了一个弱指针（&lt;code>_M_weak_this&lt;/code>）。同时还多了一个 &lt;code>__enable_shared_from_this_base&lt;/code> 方法，创建共享指针时该方法能被 ADL 找到，以关联和共享控制块。该方法是私有的，不过 &lt;code>__shared_ptr&amp;lt;typename, typename&amp;gt;&lt;/code> 是友元类，因此能访问它。&lt;/p></description></item><item><title>Windows 打不开服务、设备管理器等 .msc 文件</title><link>https://hxhue.github.io/posts/systems/Windows/Windows-%E6%89%93%E4%B8%8D%E5%BC%80%E6%9C%8D%E5%8A%A1%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8%E7%AD%89-.msc-%E6%96%87%E4%BB%B6/</link><pubDate>Wed, 05 Feb 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Windows-%E6%89%93%E4%B8%8D%E5%BC%80%E6%9C%8D%E5%8A%A1%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8%E7%AD%89-.msc-%E6%96%87%E4%BB%B6/</guid><description>&lt;h1 id="问题">问题
&lt;a class="header-anchor" href="#%e9%97%ae%e9%a2%98">&lt;/a>
&lt;/h1>&lt;p>发现是 mmc.exe 不工作了，“.msc 文件打开方式”的系统注册项是正常的。&lt;/p>
&lt;h1 id="sfcdismchkdsk-三件套无果">sfc/dism/chkdsk 三件套，无果
&lt;a class="header-anchor" href="#sfcdismchkdsk-%e4%b8%89%e4%bb%b6%e5%a5%97%e6%97%a0%e6%9e%9c">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>sfc.exe /scannow
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>DISM.exe /Online /Cleanup-image /scanhealth
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DISM.exe /Online /Cleanup-image /checkhealth
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DISM.exe /Online /Cleanup-image /restorehealth
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>确实是显示发现了问题并修复，但是结果还是打不开。&lt;/p></description></item><item><title>Nuphy 轴体质量差</title><link>https://hxhue.github.io/posts/life/2025%E5%B9%B41%E6%9C%8815%E6%97%A5-Nuphy-%E8%BD%B4%E4%BD%93%E8%B4%A8%E9%87%8F%E5%B7%AE/</link><pubDate>Wed, 15 Jan 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/life/2025%E5%B9%B41%E6%9C%8815%E6%97%A5-Nuphy-%E8%BD%B4%E4%BD%93%E8%B4%A8%E9%87%8F%E5%B7%AE/</guid><description>&lt;p>如题，买的是 Nuphy Air75 V2 越橘轴，感觉按久了之后&lt;strong>有几颗轴松松垮垮的&lt;/strong>，和其他轴体的紧致感是完全不一样的，而且有问题的轴体在小键上面还能听到剐蹭的声音。可惜包装里面送的是四种轴体各一个，而不是同一种轴体 4 个，不能方便替换（包装里面有一个越橘轴我已经拿来替换过了）。&lt;/p></description></item><item><title>无法从 huggingface 上下载模型</title><link>https://hxhue.github.io/posts/unsorted/%E6%97%A0%E6%B3%95%E4%BB%8E-huggingface-%E4%B8%8A%E4%B8%8B%E8%BD%BD%E6%A8%A1%E5%9E%8B/</link><pubDate>Sat, 11 Jan 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/unsorted/%E6%97%A0%E6%B3%95%E4%BB%8E-huggingface-%E4%B8%8A%E4%B8%8B%E8%BD%BD%E6%A8%A1%E5%9E%8B/</guid><description>&lt;p>可以设置环境变量来修改访问其他端点。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">export&lt;/span> &lt;span style="color:#268bd2">HF_ENDPOINT&lt;/span>&lt;span style="color:#719e07">=&lt;/span>https://hf-mirror.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>WSL2 中安装 perf</title><link>https://hxhue.github.io/posts/systems/Windows/WSL2-%E4%B8%AD%E5%AE%89%E8%A3%85-perf/</link><pubDate>Mon, 06 Jan 2025 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/WSL2-%E4%B8%AD%E5%AE%89%E8%A3%85-perf/</guid><description>&lt;p>&lt;a href="https://juanjose.garciaripoll.com/blog/installing-perf-on-WSL2/index.html" title="https://juanjose.garciaripoll.com/blog/installing-perf-on-WSL2/index.html" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://juanjose.garciaripoll.com/blog/installing-perf-on-WSL2/index.html&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>参考这个教程，直接下载 perf 并编译，编译报错。&lt;/p>
&lt;p>&lt;a href="https://gist.github.com/abel0b/b1881e41b9e1c4b16d84e5e083c38a13" title="https://gist.github.com/abel0b/b1881e41b9e1c4b16d84e5e083c38a13" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://gist.github.com/abel0b/b1881e41b9e1c4b16d84e5e083c38a13&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>从 WSL2 的仓库附属代码编译 perf。注意找到和自己内核版本对应的源码，可以用 &lt;code>uname -a&lt;/code> 来查看自己的内核版本。&lt;/p></description></item><item><title>哥斯拉主题 Berry 键帽体验</title><link>https://hxhue.github.io/posts/life/2024%E5%B9%B412%E6%9C%8828%E6%97%A5-%E5%93%A5%E6%96%AF%E6%8B%89%E4%B8%BB%E9%A2%98-Berry-%E9%94%AE%E5%B8%BD%E4%BD%93%E9%AA%8C/</link><pubDate>Sat, 28 Dec 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/life/2024%E5%B9%B412%E6%9C%8828%E6%97%A5-%E5%93%A5%E6%96%AF%E6%8B%89%E4%B8%BB%E9%A2%98-Berry-%E9%94%AE%E5%B8%BD%E4%BD%93%E9%AA%8C/</guid><description>&lt;h1 id="说明">说明
&lt;a class="header-anchor" href="#%e8%af%b4%e6%98%8e">&lt;/a>
&lt;/h1>&lt;p>以下的 nSA 键帽指的是 Nuphy 原装的键帽，而 Berry 键帽指的是指尖文创和 Nuphy 联名的哥斯拉主题矮轴键帽。注明这一点是因为有可能我的体验只适用于特定的键帽，我没买过其他键帽不好评价。&lt;/p></description></item><item><title>bash 字符串操作</title><link>https://hxhue.github.io/posts/cli/bash/bash-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</link><pubDate>Fri, 27 Dec 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/bash-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</guid><description>&lt;h1 id="反转字符串">反转字符串
&lt;a class="header-anchor" href="#%e5%8f%8d%e8%bd%ac%e5%ad%97%e7%ac%a6%e4%b8%b2">&lt;/a>
&lt;/h1>&lt;p>将每行内部颠倒用 &lt;code>rev&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#b58900">printf&lt;/span> &lt;span style="color:#2aa198">&amp;#39;1234 5678\nABC abc\n&amp;#39;&lt;/span> | rev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">8765&lt;/span> &lt;span style="color:#2aa198">4321&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cba CBA
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将不同行颠倒用 &lt;code>tac&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#b58900">printf&lt;/span> &lt;span style="color:#2aa198">&amp;#39;1234 5678\nABC abc\n&amp;#39;&lt;/span> | tac
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ABC abc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">1234&lt;/span> &lt;span style="color:#2aa198">5678&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>联想小新睡眠唤醒后 ctrl 按键一直被按下</title><link>https://hxhue.github.io/posts/systems/Windows/%E8%81%94%E6%83%B3%E5%B0%8F%E6%96%B0%E7%9D%A1%E7%9C%A0%E5%94%A4%E9%86%92%E5%90%8E-ctrl-%E6%8C%89%E9%94%AE%E4%B8%80%E7%9B%B4%E8%A2%AB%E6%8C%89%E4%B8%8B/</link><pubDate>Fri, 29 Nov 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/%E8%81%94%E6%83%B3%E5%B0%8F%E6%96%B0%E7%9D%A1%E7%9C%A0%E5%94%A4%E9%86%92%E5%90%8E-ctrl-%E6%8C%89%E9%94%AE%E4%B8%80%E7%9B%B4%E8%A2%AB%E6%8C%89%E4%B8%8B/</guid><description>&lt;p>联想小新睡眠唤醒后 ctrl 按键一直被按下，完全没办法正常使用键盘，打字打不出来，每个字母按键都像是被 ctrl 修饰。按 esc + shift 不能启动任务管理器，但是按 esc + shift + ctrl 能，这很奇怪，又不完全是 ctrl 被按下。&lt;strong>我的解决方式一直都是重启电脑&lt;/strong>，终于忍不住了，今天晚上花了很久去搜索相关资料。&lt;/p></description></item><item><title>在 Tex Studio 中配置 SumatraPDF 为外部 PDF 预览器</title><link>https://hxhue.github.io/posts/latex/%E5%9C%A8-Tex-Studio-%E4%B8%AD%E9%85%8D%E7%BD%AE-SumatraPDF-%E4%B8%BA%E5%A4%96%E9%83%A8-PDF-%E9%A2%84%E8%A7%88%E5%99%A8/</link><pubDate>Fri, 29 Nov 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/latex/%E5%9C%A8-Tex-Studio-%E4%B8%AD%E9%85%8D%E7%BD%AE-SumatraPDF-%E4%B8%BA%E5%A4%96%E9%83%A8-PDF-%E9%A2%84%E8%A7%88%E5%99%A8/</guid><description>&lt;p>&lt;strong>同时使用正向和反向搜索&lt;/strong>可以参考： &lt;a href="https://tex.stackexchange.com/questions/579313/sumatratexstudio-inverse-search-not-working" title="https://tex.stackexchange.com/questions/579313/sumatratexstudio-inverse-search-not-working" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://tex.stackexchange.com/questions/579313/sumatratexstudio-inverse-search-not-working&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> ，具体是在 Tex Studio 的 External PDF Viewer 填上：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>&amp;#34;C:\Program Files\SumatraPDF\SumatraPDF.exe&amp;#34; -reuse-instance -inverse-search &amp;#39;&amp;#34;C:\Program Files\TeXstudio\texstudio.exe&amp;#34; &amp;#34;%%f&amp;#34; -line %%l&amp;#39; -forward-search &amp;#34;?c:am.tex&amp;#34; @ &amp;#34;?am.pdf&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果 SumatraPDF 已经启动，要关闭之后重新被 Tex Studio 打开才能使用逆向搜索，因为逆向搜索的命令行是写在 SumatraPDF 启动时的命令行参数中的。&lt;/p></description></item><item><title>获取 ssh 中已知公钥的指纹</title><link>https://hxhue.github.io/posts/systems/Linux/%E8%8E%B7%E5%8F%96-ssh-%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%85%AC%E9%92%A5%E7%9A%84%E6%8C%87%E7%BA%B9/</link><pubDate>Thu, 28 Nov 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E8%8E%B7%E5%8F%96-ssh-%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%85%AC%E9%92%A5%E7%9A%84%E6%8C%87%E7%BA%B9/</guid><description>&lt;h1 id="原因">原因
&lt;a class="header-anchor" href="#%e5%8e%9f%e5%9b%a0">&lt;/a>
&lt;/h1>&lt;p>服务器上有异常登录现象，通过 /var/log/auth.log 找到了登录记录和公钥的指纹，但是不知道和哪个公钥对应，想要把这个公钥找出来。&lt;/p>
&lt;h1 id="步骤">步骤
&lt;a class="header-anchor" href="#%e6%ad%a5%e9%aa%a4">&lt;/a>
&lt;/h1>&lt;p>参考 &lt;a href="https://serverfault.com/questions/291763/is-it-possible-to-get-openssh-to-log-the-public-key-that-was-used-in-authenticat" title="https://serverfault.com/questions/291763/is-it-possible-to-get-openssh-to-log-the-public-key-that-was-used-in-authenticat" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://serverfault.com/questions/291763/is-it-possible-to-get-openssh-to-log-the-public-key-that-was-used-in-authenticat&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">while&lt;/span> &lt;span style="color:#268bd2">IFS&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">$&amp;#39;\n&amp;#39;&lt;/span> &lt;span style="color:#b58900">read&lt;/span> key; &lt;span style="color:#719e07">do&lt;/span> ssh-keygen -lf &amp;lt;&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#b58900">echo&lt;/span> &lt;span style="color:#268bd2">$key&lt;/span>&lt;span style="color:#719e07">)&lt;/span>; &lt;span style="color:#719e07">done&lt;/span> &amp;lt; ~/.ssh/authorized_keys
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者&lt;/p></description></item><item><title>如何对齐 PyTorch 的除法运算？</title><link>https://hxhue.github.io/posts/programming/python/%E5%A6%82%E4%BD%95%E5%AF%B9%E9%BD%90-PyTorch-%E7%9A%84%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97/</link><pubDate>Tue, 26 Nov 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/%E5%A6%82%E4%BD%95%E5%AF%B9%E9%BD%90-PyTorch-%E7%9A%84%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97/</guid><description>&lt;h1 id="过程">过程
&lt;a class="header-anchor" href="#%e8%bf%87%e7%a8%8b">&lt;/a>
&lt;/h1>&lt;p>我遇到的情况是：&lt;code>a&lt;/code> 为 64 位浮点数（FP64）标量，&lt;code>b&lt;/code> 为 32 位浮点数（FP32）张量，要计算 &lt;code>a / b&lt;/code>。&lt;/p>
&lt;p>一种做法是：使用 &lt;code>1 / b * a&lt;/code> 来代替 &lt;code>a / b&lt;/code>。这样的结果看起来和 PyTorch 的计算是对齐的。&lt;/p></description></item><item><title>用 cv2 或 Pillow 保存 numpy 格式图片</title><link>https://hxhue.github.io/posts/programming/python/%E7%94%A8-cv2-%E6%88%96-Pillow-%E4%BF%9D%E5%AD%98-numpy-%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87/</link><pubDate>Wed, 20 Nov 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/%E7%94%A8-cv2-%E6%88%96-Pillow-%E4%BF%9D%E5%AD%98-numpy-%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>img &lt;span style="color:#719e07">=&lt;/span> np&lt;span style="color:#719e07">.&lt;/span>asarray(img)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#b58900">len&lt;/span>(img&lt;span style="color:#719e07">.&lt;/span>shape) &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">4&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">assert&lt;/span> img&lt;span style="color:#719e07">.&lt;/span>shape[&lt;span style="color:#2aa198">0&lt;/span>] &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> img &lt;span style="color:#719e07">=&lt;/span> img[&lt;span style="color:#2aa198">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">assert&lt;/span> &lt;span style="color:#b58900">len&lt;/span>(img&lt;span style="color:#719e07">.&lt;/span>shape) &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">3&lt;/span> &lt;span style="color:#719e07">and&lt;/span> img&lt;span style="color:#719e07">.&lt;/span>shape[&lt;span style="color:#2aa198">0&lt;/span>] &lt;span style="color:#719e07">in&lt;/span> (&lt;span style="color:#2aa198">1&lt;/span>, &lt;span style="color:#2aa198">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>img &lt;span style="color:#719e07">=&lt;/span> img&lt;span style="color:#719e07">.&lt;/span>transpose(&lt;span style="color:#2aa198">1&lt;/span>, &lt;span style="color:#2aa198">2&lt;/span>, &lt;span style="color:#2aa198">0&lt;/span>) &lt;span style="color:#586e75"># to channels-last&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">#1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>img &lt;span style="color:#719e07">=&lt;/span> img[&lt;span style="color:#719e07">...&lt;/span>, ::&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>] &lt;span style="color:#586e75"># RGB to BGR&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>img &lt;span style="color:#719e07">=&lt;/span> (img &lt;span style="color:#719e07">*&lt;/span> &lt;span style="color:#2aa198">255.0&lt;/span>)&lt;span style="color:#719e07">.&lt;/span>astype(np&lt;span style="color:#719e07">.&lt;/span>uint8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>img &lt;span style="color:#719e07">=&lt;/span> np&lt;span style="color:#719e07">.&lt;/span>ascontiguousarray(img)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">assert&lt;/span> cv2&lt;span style="color:#719e07">.&lt;/span>imwrite(&lt;span style="color:#2aa198">&amp;#34;fused.jpg&amp;#34;&lt;/span>, img)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">#2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">## https://pytorch.org/vision/main/generated/torchvision.transforms.ToPILImage.html&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">## img.shape: (C x H x W) if img is torch.Tensor, (H x W x C) if img is np.ndarray.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># img = transforms.ToPILImage()(img)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># img.save(&amp;#39;fused.jpg&amp;#39;)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要么进行 RGB -&amp;gt; BGR、将 0~1 缩放到 0~255、转换到 &lt;code>np.uint8&lt;/code> 类型、将数组转连续等操作，要么直接使用 torchvision 的 transforms 工具。&lt;/p></description></item><item><title>How to call "friends" properly?</title><link>https://hxhue.github.io/posts/programming/cpp/How-to-call-friends-properly/</link><pubDate>Sun, 17 Nov 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/How-to-call-friends-properly/</guid><description>&lt;h1 id="开头">开头
&lt;a class="header-anchor" href="#%e5%bc%80%e5%a4%b4">&lt;/a>
&lt;/h1>&lt;p>有一天看到类似这样的代码（隐藏了业务逻辑，对函数签名进行了简化）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">Foo&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">friend&lt;/span> Foo &lt;span style="color:#268bd2">max&lt;/span>(Foo a, Foo b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Foo &lt;span style="color:#268bd2">max&lt;/span>(Foo a, Foo b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#2aa198">&amp;#34;friend max&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Foo &lt;span style="color:#268bd2">max&lt;/span>(Foo a, Foo b, &lt;span style="color:#dc322f">int&lt;/span> x &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#2aa198">&amp;#34;global max&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>(&lt;span style="color:#dc322f">int&lt;/span> argc, &lt;span style="color:#dc322f">char&lt;/span> &lt;span style="color:#719e07">**&lt;/span>argv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Foo a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Foo b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Foo c &lt;span style="color:#719e07">=&lt;/span> max(a, b); &lt;span style="color:#586e75">// ambiguous
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>很明显无法编译：&lt;/p></description></item><item><title>PyTorch `optimizer.step()` 影响 BatchNorm2d 权重的梯度</title><link>https://hxhue.github.io/posts/programming/python/PyTorch-optimizer.step-%E5%BD%B1%E5%93%8D-BatchNorm2d-%E6%9D%83%E9%87%8D%E7%9A%84%E6%A2%AF%E5%BA%A6/</link><pubDate>Wed, 06 Nov 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/PyTorch-optimizer.step-%E5%BD%B1%E5%93%8D-BatchNorm2d-%E6%9D%83%E9%87%8D%E7%9A%84%E6%A2%AF%E5%BA%A6/</guid><description>&lt;p>我发现 &lt;code>optimizer.step()&lt;/code> 这一步会改变 &lt;code>torch.nn.BatchNorm2d&lt;/code> 层的 weight 和 bias 的梯度（看上去是每个元素按照相同的比例进行了缩放）。如果想要比较梯度，应该在 &lt;code>optimizer.step()&lt;/code> 之前来对比，想要对比更新后的权重，要在 &lt;code>optimizer.step()&lt;/code> 之后对比。&lt;/p></description></item><item><title>在 VS Code 中从 C++ 调试 pybind</title><link>https://hxhue.github.io/posts/programming/python/%E5%9C%A8-VS-Code-%E4%B8%AD%E4%BB%8E-C++-%E8%B0%83%E8%AF%95-pybind/</link><pubDate>Tue, 05 Nov 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/%E5%9C%A8-VS-Code-%E4%B8%AD%E4%BB%8E-C++-%E8%B0%83%E8%AF%95-pybind/</guid><description>&lt;h1 id="使用-debugpy-调试">使用 debugpy 调试
&lt;a class="header-anchor" href="#%e4%bd%bf%e7%94%a8-debugpy-%e8%b0%83%e8%af%95">&lt;/a>
&lt;/h1>&lt;p>在被 C++ 调用的 python 文件中加上这样的内容（端口可以随便选）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> debugpy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>debugpy&lt;span style="color:#719e07">.&lt;/span>listen(&lt;span style="color:#2aa198">5678&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>debugpy&lt;span style="color:#719e07">.&lt;/span>wait_for_client()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样在第一次加载这个 python 模块的时候，这行代码就会暂停等待调试器连接。我们可以创建这样的 Python 调试配置，随后连接正在监听端口的 python 程序。&lt;/p></description></item><item><title>PyTorch 注册反向传播的钩子</title><link>https://hxhue.github.io/posts/programming/python/PyTorch-%E6%B3%A8%E5%86%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%9A%84%E9%92%A9%E5%AD%90/</link><pubDate>Wed, 30 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/PyTorch-%E6%B3%A8%E5%86%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%9A%84%E9%92%A9%E5%AD%90/</guid><description>&lt;h1 id="注册钩子">注册钩子
&lt;a class="header-anchor" href="#%e6%b3%a8%e5%86%8c%e9%92%a9%e5%ad%90">&lt;/a>
&lt;/h1>&lt;p>通过注册钩子，收集模型运行时的输出，可以对每一层的输出值进行调试。&lt;/p>
&lt;p>假设模型是 &lt;code>model&lt;/code>，我们可以把每一层的输入的梯度和输出的梯度保存在字典中：&lt;/p></description></item><item><title>用特定的 CUDA 版本构建 PyTorch</title><link>https://hxhue.github.io/posts/programming/python/%E7%94%A8%E7%89%B9%E5%AE%9A%E7%9A%84-CUDA-%E7%89%88%E6%9C%AC%E6%9E%84%E5%BB%BA-PyTorch-%E5%B9%B6%E6%89%93%E5%8C%85-Conda-%E7%8E%AF%E5%A2%83/</link><pubDate>Tue, 15 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/%E7%94%A8%E7%89%B9%E5%AE%9A%E7%9A%84-CUDA-%E7%89%88%E6%9C%AC%E6%9E%84%E5%BB%BA-PyTorch-%E5%B9%B6%E6%89%93%E5%8C%85-Conda-%E7%8E%AF%E5%A2%83/</guid><description>&lt;h1 id="说明">说明
&lt;a class="header-anchor" href="#%e8%af%b4%e6%98%8e">&lt;/a>
&lt;/h1>&lt;p>文章是按照我解决问题的过程来写的，不是一个一步式的教程，所以显得有点凌乱。如果要操作请务必先看完全文，以免跟着中间过程走了同样的弯路。&lt;strong>如果不想看前面的内容可以直接跳到 conda 打包这一节&lt;/strong>。&lt;/p></description></item><item><title>fma 指令</title><link>https://hxhue.github.io/posts/programming/cuda/fma-%E6%8C%87%E4%BB%A4/</link><pubDate>Mon, 14 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cuda/fma-%E6%8C%87%E4%BB%A4/</guid><description>&lt;p>今天写 atan 反向传播的 CUDA kernel 发现和 torch 算出来的不一样。核心代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">elementwise_atan_backward&lt;/span>(&lt;span style="color:#dc322f">float&lt;/span>&lt;span style="color:#719e07">*&lt;/span> in, &lt;span style="color:#dc322f">float&lt;/span>&lt;span style="color:#719e07">*&lt;/span> din, &lt;span style="color:#dc322f">float&lt;/span>&lt;span style="color:#719e07">*&lt;/span> dout, &lt;span style="color:#dc322f">int&lt;/span> N) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> blockIdx.x &lt;span style="color:#719e07">*&lt;/span> blockDim.x &lt;span style="color:#719e07">+&lt;/span> threadIdx.x; i &lt;span style="color:#719e07">&amp;lt;&lt;/span> (N); i &lt;span style="color:#719e07">+=&lt;/span> blockDim.x &lt;span style="color:#719e07">*&lt;/span> gridDim.x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// din[i] = dout[i] / (in[i] * in[i] + 1.f);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// pytorch/tools/autograd/derivatives.yaml
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// - name: atan(Tensor self) -&amp;gt; Tensor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// self: grad / (self * self + 1).conj()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// result: auto_element_wise
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#dc322f">float&lt;/span> square &lt;span style="color:#719e07">=&lt;/span> in[i] &lt;span style="color:#719e07">*&lt;/span> in[i] &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">0.f&lt;/span>; &lt;span style="color:#586e75">// disable fma so we can align with torch
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> din[i] &lt;span style="color:#719e07">=&lt;/span> dout[i] &lt;span style="color:#719e07">/&lt;/span> (square &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">1.f&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>PyTorch 是用规则文件生成自动梯度求导的，&lt;code>torch.atan&lt;/code> 的求导规则为 &lt;code>grad / (self * self + 1).conj()&lt;/code>，其中 &lt;code>grad&lt;/code> 和 &lt;code>self&lt;/code> 都是张量，&lt;code>conj()&lt;/code> 在实数张量的场景下是可以不管的。我按照同样的方法写 kernel，发现和 torch 算出来的结果有极小的差异。&lt;/p></description></item><item><title>添加用户到 docker 组</title><link>https://hxhue.github.io/posts/cli/docker/%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%88%B0-docker-%E7%BB%84/</link><pubDate>Sun, 13 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%88%B0-docker-%E7%BB%84/</guid><description>&lt;p>通过 &lt;code>sudo usermod -aG docker xx&lt;/code> 把 xx 加到 docker 组之后，需要先退出当前登录才能生效。&lt;/p></description></item><item><title>安装 cv2 Python 包</title><link>https://hxhue.github.io/posts/programming/python/%E5%AE%89%E8%A3%85-cv2-Python-%E5%8C%85/</link><pubDate>Fri, 11 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/%E5%AE%89%E8%A3%85-cv2-Python-%E5%8C%85/</guid><description>&lt;h1 id="通过-mambaconda-安装">通过 mamba/conda 安装
&lt;a class="header-anchor" href="#%e9%80%9a%e8%bf%87-mambaconda-%e5%ae%89%e8%a3%85">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mamba install -c mempo opencv
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="通过-pip-安装">通过 pip 安装
&lt;a class="header-anchor" href="#%e9%80%9a%e8%bf%87-pip-%e5%ae%89%e8%a3%85">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install opencv-python opencv-python-headless
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可能需要安装 opencv-contrib-python-headless，但是我这里不安装也成功了。&lt;/p>
&lt;h1 id="注意">注意
&lt;a class="header-anchor" href="#%e6%b3%a8%e6%84%8f">&lt;/a>
&lt;/h1>&lt;p>两种安装方式不能混合使用。尤其是在通过 &lt;code>pip&lt;/code> 安装 opencv-python 之后，发现不生效，是不能通过 conda 安装 opencv 来补救的。只能继续安装 opencv-python-headless。&lt;/p></description></item><item><title>在 C++ 项目中使用 Pybind11</title><link>https://hxhue.github.io/posts/programming/cpp/%E5%9C%A8-C++-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Pybind11/</link><pubDate>Fri, 11 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E5%9C%A8-C++-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Pybind11/</guid><description>&lt;p>安装 pybind11：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install &lt;span style="color:#2aa198">&amp;#39;pybind11[global]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># add your executable
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#b58900">set&lt;/span>(&lt;span style="color:#2aa198">PYTHON_EXECUTABLE&lt;/span> &lt;span style="color:#2aa198">/opt/miniforge3/bin/python&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">find_package&lt;/span>(&lt;span style="color:#2aa198">pybind11&lt;/span> &lt;span style="color:#2aa198">REQUIRED&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">target_link_libraries&lt;/span>(&lt;span style="color:#2aa198">your_executable&lt;/span> &lt;span style="color:#2aa198">PRIVATE&lt;/span> &lt;span style="color:#2aa198">pybind11::pybind11&lt;/span> &lt;span style="color:#2aa198">pybind11::embed&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>设置 &lt;code>PYTHON_EXECUTABLE&lt;/code> 可以确保 pybind11 使用正确的 python 版本，这样才能在里面找到你安装好的其他的包。&lt;/p></description></item><item><title>Windows 释放 NAT 服务占用的端口</title><link>https://hxhue.github.io/posts/systems/Windows/Windows-%E9%87%8A%E6%94%BE-NAT-%E6%9C%8D%E5%8A%A1%E5%8D%A0%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3/</link><pubDate>Fri, 04 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Windows-%E9%87%8A%E6%94%BE-NAT-%E6%9C%8D%E5%8A%A1%E5%8D%A0%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3/</guid><description>&lt;h1 id="释放-nat-服务占用的端口">释放 NAT 服务占用的端口
&lt;a class="header-anchor" href="#%e9%87%8a%e6%94%be-nat-%e6%9c%8d%e5%8a%a1%e5%8d%a0%e7%94%a8%e7%9a%84%e7%ab%af%e5%8f%a3">&lt;/a>
&lt;/h1>&lt;p>查看被占用的 TCP 端口，检查自己所用的服务端口是否被包含在结果中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>netsh interface ipv4 show excludedportrange protocol=tcp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重启 winnat 服务来释放大多数端口（需要管理员权限），验证 TCP 端口是否被释放：&lt;/p></description></item><item><title>超线程</title><link>https://hxhue.github.io/posts/systems/%E8%B6%85%E7%BA%BF%E7%A8%8B/</link><pubDate>Fri, 04 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/%E8%B6%85%E7%BA%BF%E7%A8%8B/</guid><description>&lt;h1 id="分类">分类
&lt;a class="header-anchor" href="#%e5%88%86%e7%b1%bb">&lt;/a>
&lt;/h1>&lt;p>我们平时说的超线程可能指同时多线程（SMT），也可能指 Intel 的超线程（HT）。&lt;/p>

&lt;div class="highlight">&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">flowchart TD
 SMT(&amp;#34;Simultaneous multithreading (SMT)&amp;#34;)
 HT(&amp;#34;Hyper-threading (HT)&amp;#34;)
 TMT(&amp;#34;Temporal multithreading, or super-threading&amp;#34;)
 SMT --&amp;gt;|Intel&amp;#39;s implementation| HT
 TMT &amp;lt;--&amp;gt;|SMT 同一条流水线能执行来自多个线程的指令，另外一个不能| SMT
	HT -.-&amp;gt; HT_note(&amp;#34;两个逻辑线程共享包括 TLB 和 cache 等资源，但 CR3 等资源独立&amp;#34;)&lt;/code>&lt;/pre>&lt;/div>
&lt;p>也存在一个物理核心对应超过 2 个逻辑线程的 SMT 实现，比如 IBM Power8: 12 cores, 8T each, (32 FX + 32 FP) registers per thread，FX 是定点数，FP 是浮点数。&lt;/p></description></item><item><title>Hugo 文章摘要</title><link>https://hxhue.github.io/posts/unsorted/Hugo-%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81/</link><pubDate>Thu, 03 Oct 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/unsorted/Hugo-%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81/</guid><description>&lt;h1 id="说明">说明
&lt;a class="header-anchor" href="#%e8%af%b4%e6%98%8e">&lt;/a>
&lt;/h1>&lt;p>在我写这个文章摘要代码片段的时候，Hugo 还没有支持按照元素截取，因此 summary 是纯文本、没有格式。&lt;/p>
&lt;p>现在 &lt;a href="https://github.com/gohugoio/hugo/issues/7926" title="Hugo 已经实现了带格式的截取" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Hugo 已经实现了带格式的截取&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>。目前内置实现和我实现的区别是：&lt;strong>内置实现是按照词数截取的，直到词数满足要求就停止添加新的元素，我的实现是按照顶级元素数量截取的&lt;/strong>（以前用 Hexo 插件有这个功能，因此我实现的也是这个）。&lt;/p></description></item><item><title>VS Code 终端多重 conda 环境</title><link>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E7%BB%88%E7%AB%AF%E5%A4%9A%E9%87%8D-conda-%E7%8E%AF%E5%A2%83/</link><pubDate>Thu, 26 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E7%BB%88%E7%AB%AF%E5%A4%9A%E9%87%8D-conda-%E7%8E%AF%E5%A2%83/</guid><description>&lt;p>准确的说是 conda 环境的提示重复了两次，实际上是同一个环境 &lt;code>env1&lt;/code>，但显示出来是 &lt;code>(env1) (env1)&lt;/code>。&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ol>
&lt;li>关闭 &lt;code>python.terminal.activateEnvironment&lt;/code>，然后重载工作区，防止自动加载。&lt;/li>
&lt;li>或者关闭 conda 的自动激活：&lt;code>conda config --set auto_activate_base false&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>我觉得 2 更方便一点，因为 vscode 调试 python 程序还是需要自动激活的。&lt;/p></description></item><item><title>Docker 升级之后 docker-compose 无法正常启动使用 GPU 的容器</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E5%8D%87%E7%BA%A7%E4%B9%8B%E5%90%8E-docker-compose-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8%E4%BD%BF%E7%94%A8-GPU-%E7%9A%84%E5%AE%B9%E5%99%A8/</link><pubDate>Sat, 21 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E5%8D%87%E7%BA%A7%E4%B9%8B%E5%90%8E-docker-compose-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8%E4%BD%BF%E7%94%A8-GPU-%E7%9A%84%E5%AE%B9%E5%99%A8/</guid><description>&lt;h1 id="解决-docker-compose-启动的容器无法使用-gpu">解决 docker-compose 启动的容器无法使用 GPU
&lt;a class="header-anchor" href="#%e8%a7%a3%e5%86%b3-docker-compose-%e5%90%af%e5%8a%a8%e7%9a%84%e5%ae%b9%e5%99%a8%e6%97%a0%e6%b3%95%e4%bd%bf%e7%94%a8-gpu">&lt;/a>
&lt;/h1>&lt;p>最近有人升级了服务器的 docker，我们创建容器有点问题。症状是这样：在命令行用 &lt;code>--gpus all&lt;/code> 参数启动的都能正常使用 GPU（可以通过运行 &lt;code>nvidia-smi&lt;/code> 命令测试），但是在 docker-compose.yml 文件中指定要使用 GPU 就不行。&lt;/p></description></item><item><title>C++ 结构化绑定过程</title><link>https://hxhue.github.io/posts/programming/cpp/C++-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B/</link><pubDate>Wed, 18 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B/</guid><description>&lt;h1 id="起因">起因
&lt;a class="header-anchor" href="#%e8%b5%b7%e5%9b%a0">&lt;/a>
&lt;/h1>&lt;p>同学给出如下代码，指出 &lt;code>std::forward_as_tuple()&lt;/code> 的返回值不能被 &lt;code>auto&lt;/code> 结构化绑定：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;tuple&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> t1 &lt;span style="color:#719e07">=&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>tuple{&lt;span style="color:#2aa198">0&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> [a0] &lt;span style="color:#719e07">=&lt;/span> t1; &lt;span style="color:#586e75">// ok
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">auto&lt;/span> t2 &lt;span style="color:#719e07">=&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>forward_as_tuple(&lt;span style="color:#2aa198">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> [a1] &lt;span style="color:#719e07">=&lt;/span> t2; &lt;span style="color:#586e75">// error
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改代码尝试了几次发现，&lt;code>t2&lt;/code> 只是不能被 &lt;code>auto&lt;/code> 结构化绑定，可以被 &lt;code>auto &amp;amp;&lt;/code> 和 &lt;code>auto &amp;amp;&amp;amp;&lt;/code>（万能引用）结构化绑定。查阅资料得知 &lt;code>std::forward_as_tuple()&lt;/code> 返回的 &lt;code>std::tuple&lt;/code> 的参数类型都是完美转发后的类型，&lt;code>t2&lt;/code> 的类型是 &lt;code>std::tuple&amp;lt;int &amp;amp;&amp;amp;&amp;gt;&lt;/code> 而不是 &lt;code>std::tuple&amp;lt;int&amp;gt;&lt;/code>。&lt;/p></description></item><item><title>简易的计时函数</title><link>https://hxhue.github.io/posts/programming/cpp/%E7%AE%80%E6%98%93%E7%9A%84%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0/</link><pubDate>Wed, 18 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E7%AE%80%E6%98%93%E7%9A%84%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> F&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> timed_execute(std&lt;span style="color:#719e07">::&lt;/span>string_view tag, F &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span>f) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> start &lt;span style="color:#719e07">=&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>chrono&lt;span style="color:#719e07">::&lt;/span>steady_clock&lt;span style="color:#719e07">::&lt;/span>now();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> end &lt;span style="color:#719e07">=&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>chrono&lt;span style="color:#719e07">::&lt;/span>steady_clock&lt;span style="color:#719e07">::&lt;/span>now();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> ns &lt;span style="color:#719e07">=&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>chrono&lt;span style="color:#719e07">::&lt;/span>duration_cast&lt;span style="color:#719e07">&amp;lt;&lt;/span>std&lt;span style="color:#719e07">::&lt;/span>chrono&lt;span style="color:#719e07">::&lt;/span>nanoseconds&lt;span style="color:#719e07">&amp;gt;&lt;/span>(end &lt;span style="color:#719e07">-&lt;/span> start).count();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>printf(&lt;span style="color:#2aa198">&amp;#34;%-20s: &amp;#34;&lt;/span>, tag.data());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ns &lt;span style="color:#719e07">&amp;gt;=&lt;/span> &lt;span style="color:#2aa198">1e6&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>printf(&lt;span style="color:#2aa198">&amp;#34;%.1fms&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>, ns &lt;span style="color:#719e07">/&lt;/span> &lt;span style="color:#2aa198">1e6&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#268bd2">if&lt;/span> (ns &lt;span style="color:#719e07">&amp;gt;=&lt;/span> &lt;span style="color:#2aa198">1e3&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>printf(&lt;span style="color:#2aa198">&amp;#34;%.1fus&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>, ns &lt;span style="color:#719e07">/&lt;/span> &lt;span style="color:#2aa198">1e3&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>printf(&lt;span style="color:#2aa198">&amp;#34;%zdns&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>, ns);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>timed_execute(&lt;span style="color:#2aa198">&amp;#34;reduce&amp;#34;&lt;/span>, [&lt;span style="color:#719e07">&amp;amp;&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> result &lt;span style="color:#719e07">=&lt;/span> reduce(v.begin(), v.end(), &lt;span style="color:#2aa198">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2024 年 10 月 2 日：其实 duration 的 &lt;code>count()&lt;/code> 不一定非得是整数。参考 &lt;a href="https://en.cppreference.com/w/cpp/chrono/duration" title="https://en.cppreference.com/w/cpp/chrono/duration" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/chrono/duration&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> ，可以自己定义数据类型为浮点数的 ratio（通用单位，在 &lt;code>std::chrono&lt;/code> 中自然就表示时间单位，比如 &lt;code>std::milli&lt;/code> 表示 1e-3 这个比例，而 &lt;code>std::chrono::milliseconds&lt;/code> 真正表示毫秒这个时间段）。例子：&lt;/p></description></item><item><title>WSL2 中 nvim 的复制粘贴和 Windows 不共享剪贴板</title><link>https://hxhue.github.io/posts/systems/Windows/WSL2-%E4%B8%AD-nvim-%E7%9A%84%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%92%8C-Windows-%E4%B8%8D%E5%85%B1%E4%BA%AB%E5%89%AA%E8%B4%B4%E6%9D%BF/</link><pubDate>Sun, 15 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/WSL2-%E4%B8%AD-nvim-%E7%9A%84%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%92%8C-Windows-%E4%B8%8D%E5%85%B1%E4%BA%AB%E5%89%AA%E8%B4%B4%E6%9D%BF/</guid><description>&lt;h1 id="三个剪贴板">三个剪贴板
&lt;a class="header-anchor" href="#%e4%b8%89%e4%b8%aa%e5%89%aa%e8%b4%b4%e6%9d%bf">&lt;/a>
&lt;/h1>&lt;p>Windows 一个，X selection 一个，Wayland 一个。&lt;/p>
&lt;p>安装 wl-clipboard 包可以获得 &lt;code>wl-copy&lt;/code> 和 &lt;code>wl-paste&lt;/code> 工具，它们操作 Wayland 剪贴板。&lt;/p>
&lt;p>安装 xclip 可以获得 &lt;code>xclip&lt;/code> 工具，&lt;code>xclip&lt;/code> 或 &lt;code>xclip -i&lt;/code> 类似 &lt;code>wl-copy&lt;/code>，完成复制功能，&lt;code>xclip -o&lt;/code> 完成粘贴功能。它操作的是 X selection。&lt;/p></description></item><item><title>同学 Zoom 黑屏掉线</title><link>https://hxhue.github.io/posts/systems/Windows/%E5%90%8C%E5%AD%A6-Zoom-%E9%BB%91%E5%B1%8F%E6%8E%89%E7%BA%BF/</link><pubDate>Wed, 11 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/%E5%90%8C%E5%AD%A6-Zoom-%E9%BB%91%E5%B1%8F%E6%8E%89%E7%BA%BF/</guid><description>&lt;h1 id="起因">起因
&lt;a class="header-anchor" href="#%e8%b5%b7%e5%9b%a0">&lt;/a>
&lt;/h1>&lt;p>同学说 Zoom 卡，影响了他在线考试。我们收集了一些资料后发现 Zoom 有中国服务器，但是只有商业用户可以连接，而免费账户只能连接到美国的服务器。我怀疑是中国到 Zoom 的美国服务器网络线路不好。&lt;/p></description></item><item><title>Python 临时目录在退出时没有被清理</title><link>https://hxhue.github.io/posts/programming/python/Python-%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95%E5%9C%A8%E9%80%80%E5%87%BA%E6%97%B6%E6%B2%A1%E6%9C%89%E8%A2%AB%E6%B8%85%E7%90%86/</link><pubDate>Tue, 10 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/Python-%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95%E5%9C%A8%E9%80%80%E5%87%BA%E6%97%B6%E6%B2%A1%E6%9C%89%E8%A2%AB%E6%B8%85%E7%90%86/</guid><description>&lt;p>我的主要代码是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">def&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">with&lt;/span> tempfile&lt;span style="color:#719e07">.&lt;/span>TemporaryDirectory() &lt;span style="color:#719e07">as&lt;/span> d:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> write_tmp_files(d)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>即便是程序在终端被 &lt;code>^C&lt;/code> 终止，临时文件夹也会被正常清理，但是我发现 SIGHUP 到来时，临时文件夹就不会被正常清理了。可以注册一个信号处理器函数：&lt;/p></description></item><item><title>Docker 的 seccomp 选项</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E7%9A%84-seccomp-%E9%80%89%E9%A1%B9/</link><pubDate>Sun, 08 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E7%9A%84-seccomp-%E9%80%89%E9%A1%B9/</guid><description>&lt;p>&lt;a href="https://docs.docker.com/engine/security/seccomp/" title="https://docs.docker.com/engine/security/seccomp/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://docs.docker.com/engine/security/seccomp/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>&lt;code>seccomp&lt;/code> 选项可以控制容器内可以执行的系统调用。可以用 &lt;code>--security-opt seccomp=/path/to/seccomp/profile.json&lt;/code>，也可以用 &lt;code>--security-opt seccomp=unconfined&lt;/code> 表示不受限。&lt;/p></description></item><item><title>在 Python 中对文件名按照数值排序</title><link>https://hxhue.github.io/posts/programming/python/%E5%9C%A8-Python-%E4%B8%AD%E5%AF%B9%E6%96%87%E4%BB%B6%E5%90%8D%E6%8C%89%E7%85%A7%E6%95%B0%E5%80%BC%E6%8E%92%E5%BA%8F/</link><pubDate>Sat, 07 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/%E5%9C%A8-Python-%E4%B8%AD%E5%AF%B9%E6%96%87%E4%BB%B6%E5%90%8D%E6%8C%89%E7%85%A7%E6%95%B0%E5%80%BC%E6%8E%92%E5%BA%8F/</guid><description>&lt;h1 id="对数据集的文件名正确排序">对数据集的文件名正确排序
&lt;a class="header-anchor" href="#%e5%af%b9%e6%95%b0%e6%8d%ae%e9%9b%86%e7%9a%84%e6%96%87%e4%bb%b6%e5%90%8d%e6%ad%a3%e7%a1%ae%e6%8e%92%e5%ba%8f">&lt;/a>
&lt;/h1>&lt;p>有些训练或评估程序要求数据集输入文件的顺序严格有序 &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，但是文件名长度又不同，不能简单按照字典序来排序。比如，数据集的标签文件名可能是 0.txt、1.txt……10.txt 等，能想到的一个方法是在前面填充字符 &lt;code>'0'&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>lst &lt;span style="color:#719e07">=&lt;/span> os&lt;span style="color:#719e07">.&lt;/span>listdir(directory)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lst &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#b58900">sorted&lt;/span>(lst, key&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#719e07">lambda&lt;/span> s : s&lt;span style="color:#719e07">.&lt;/span>zfill(&lt;span style="color:#2aa198">50&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果先去掉后缀名，然后再把前面的字符串转数字，则可能会遇到很多复杂的情况（比如多重后缀名），比不上在前面填充字符简单。&lt;/p></description></item><item><title>上手 cv2 遇到的一些问题</title><link>https://hxhue.github.io/posts/programming/python/%E4%B8%8A%E6%89%8B-cv2-%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 06 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/%E4%B8%8A%E6%89%8B-cv2-%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="cv2-的参数输入格式">&lt;code>cv2&lt;/code> 的参数输入格式
&lt;a class="header-anchor" href="#cv2-%e7%9a%84%e5%8f%82%e6%95%b0%e8%be%93%e5%85%a5%e6%a0%bc%e5%bc%8f">&lt;/a>
&lt;/h1>&lt;p>&lt;code>cv2&lt;/code> 全部改成了用 &lt;code>numpy.ndarray&lt;/code> 作为图像处理格式。只是操作图像的时候：&lt;/p>
&lt;ol>
&lt;li>数据类型必须是 uint8。&lt;/li>
&lt;li>形状必须是 &lt;code>(H, W, C)&lt;/code> 或者 &lt;code>(H, W)&lt;/code>，后者为灰度图。&lt;/li>
&lt;li>必须是连续的，必要时得用 &lt;code>np.ascontiguousarray()&lt;/code> 转换一下（不然报错会很晦涩）。&lt;/li>
&lt;/ol>
&lt;p>如果使用训练模型用的张量转 numpy，一定要记得把批量维度去掉，并且转 channels-last 格式。否则 cv2 不能正常识别图像，并可能报错（报错信息晦涩难懂）。&lt;/p></description></item><item><title>读英伟达博客：CUDA Wrap 级原语</title><link>https://hxhue.github.io/posts/programming/cuda/%E8%AF%BB%E8%8B%B1%E4%BC%9F%E8%BE%BE%E5%8D%9A%E5%AE%A2CUDA-Wrap-%E7%BA%A7%E5%8E%9F%E8%AF%AD/</link><pubDate>Thu, 05 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cuda/%E8%AF%BB%E8%8B%B1%E4%BC%9F%E8%BE%BE%E5%8D%9A%E5%AE%A2CUDA-Wrap-%E7%BA%A7%E5%8E%9F%E8%AF%AD/</guid><description>&lt;h1 id="原文">原文
&lt;a class="header-anchor" href="#%e5%8e%9f%e6%96%87">&lt;/a>
&lt;/h1>&lt;p>&lt;a href="https://developer.nvidia.com/blog/using-cuda-warp-level-primitives/" title="https://developer.nvidia.com/blog/using-cuda-warp-level-primitives/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://developer.nvidia.com/blog/using-cuda-warp-level-primitives/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;h1 id="笔记">笔记
&lt;a class="header-anchor" href="#%e7%ac%94%e8%ae%b0">&lt;/a>
&lt;/h1>&lt;h2 id="warp-内规约">Warp 内规约
&lt;a class="header-anchor" href="#warp-%e5%86%85%e8%a7%84%e7%ba%a6">&lt;/a>
&lt;/h2>&lt;p>






&lt;img src="https://hxhue.github.io/assets/Pasted%20image%2020240905103728.webp">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#define FULL_MASK 0xffffffff
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>&lt;span style="color:#719e07">for&lt;/span> (&lt;span style="color:#dc322f">int&lt;/span> offset &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">16&lt;/span>; offset &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>; offset &lt;span style="color:#719e07">/=&lt;/span> &lt;span style="color:#2aa198">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val &lt;span style="color:#719e07">+=&lt;/span> &lt;span style="color:#268bd2">__shfl_down_sync&lt;/span>(FULL_MASK, val, offset);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先在 warp 内用原语规约，比在 block 级别用共享内存规约快很多。（虽然也有 &lt;code>__reduce_add_sync()&lt;/code> 函数，但是截至 2024 年 9 月 5 日只支持 unsigned 和 int 类型，给浮点数做规约就要用 &lt;code>__shfl_xx_sync()&lt;/code> 系列。）&lt;/p></description></item><item><title>读英伟达博客：Warp 聚合原子操作 —— 以过滤为例</title><link>https://hxhue.github.io/posts/programming/cuda/%E8%AF%BB%E8%8B%B1%E4%BC%9F%E8%BE%BE%E5%8D%9A%E5%AE%A2Warp-%E8%81%9A%E5%90%88%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-%E4%BB%A5%E8%BF%87%E6%BB%A4%E4%B8%BA%E4%BE%8B/</link><pubDate>Thu, 05 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cuda/%E8%AF%BB%E8%8B%B1%E4%BC%9F%E8%BE%BE%E5%8D%9A%E5%AE%A2Warp-%E8%81%9A%E5%90%88%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-%E4%BB%A5%E8%BF%87%E6%BB%A4%E4%B8%BA%E4%BE%8B/</guid><description>&lt;h1 id="原文链接">原文链接
&lt;a class="header-anchor" href="#%e5%8e%9f%e6%96%87%e9%93%be%e6%8e%a5">&lt;/a>
&lt;/h1>&lt;p>&lt;a href="https://developer.nvidia.com/blog/cuda-pro-tip-optimized-filtering-warp-aggregated-atomics/" title="https://developer.nvidia.com/blog/cuda-pro-tip-optimized-filtering-warp-aggregated-atomics/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://developer.nvidia.com/blog/cuda-pro-tip-optimized-filtering-warp-aggregated-atomics/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;h1 id="场景">场景
&lt;a class="header-anchor" href="#%e5%9c%ba%e6%99%af">&lt;/a>
&lt;/h1>&lt;p>将 &lt;code>src&lt;/code> 中大于 0 的数字移动到 &lt;code>dst&lt;/code> 中去，并返回新数组的元素数量。和 C++ 的 &lt;code>std::copy_if&lt;/code> 相似。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">filter&lt;/span>(&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#719e07">*&lt;/span>dst, &lt;span style="color:#719e07">const&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#719e07">*&lt;/span>src, &lt;span style="color:#dc322f">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> nres &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>; i &lt;span style="color:#719e07">&amp;lt;&lt;/span> n; i&lt;span style="color:#719e07">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (src[i] &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dst[nres&lt;span style="color:#719e07">++&lt;/span>] &lt;span style="color:#719e07">=&lt;/span> src[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// return the number of elements copied
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> nres;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果用全局内存实现：&lt;/p></description></item><item><title>Linux Mint 22 虚拟机安装 CUDA Toolkit</title><link>https://hxhue.github.io/posts/programming/cuda/Linux-Mint-22-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85-CUDA-Toolkit/</link><pubDate>Tue, 03 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cuda/Linux-Mint-22-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85-CUDA-Toolkit/</guid><description>&lt;p>&lt;strong>本机没有 NVIDIA GPU，只是无聊想要试试能不能在没有 GPU 的机器（宿主机没 GPU）上做编译工作&lt;/strong>。&lt;/p>
&lt;p>按照 &lt;a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;amp;target_arch=x86_64&amp;amp;Distribution=Ubuntu&amp;amp;target_version=24.04&amp;amp;target_type=deb_local" title="官网链接" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >官网链接&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>，选择 Ubuntu 即可。cuda-repo-ubuntu2404-12-6-local_12.6.1-560.35.03-1_amd64.deb 这个文件占了 3.2G，安装之后就更大了。&lt;/p>
&lt;p>安装完成之后，可以在 /usr/local/cuda-12.6/bin/ 中找到 &lt;code>nvcc&lt;/code>。加到 PATH 之后，编译都能正常进行，但是因为没有 GPU，运行时 CUDA 相关的 API 都会报错，仅此而已。&lt;/p></description></item><item><title>bash 等待特定进程结束</title><link>https://hxhue.github.io/posts/cli/bash/bash-%E7%AD%89%E5%BE%85%E7%89%B9%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F/</link><pubDate>Mon, 02 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/bash-%E7%AD%89%E5%BE%85%E7%89%B9%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F/</guid><description>&lt;p>这是我写的某个测试的脚本：&lt;/p>
&lt;ol>
&lt;li>B 需要等待 A 程序先运行起来之后才能启动。&lt;/li>
&lt;li>A 退出之后，应该中止 B。&lt;/li>
&lt;li>代码能保证 B 不会在 A 之前中止。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./build/test/A -n &lt;span style="color:#2aa198">5000&lt;/span> &amp;amp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">PROC_A&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#268bd2">$!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sleep &lt;span style="color:#2aa198">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python test/B.py &amp;amp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">PROC_B&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#268bd2">$!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tail --pid&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#268bd2">$PROC_A&lt;/span> -f /dev/null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">kill&lt;/span> &lt;span style="color:#268bd2">$PROC_B&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>tail --pid=$PROC_A -f /dev/null&lt;/code> 这一句是等待特定进程结束的关键。参考 &lt;a href="https://stackoverflow.com/questions/1058047/wait-for-a-process-to-finish" title="https://stackoverflow.com/questions/1058047/wait-for-a-process-to-finish" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/questions/1058047/wait-for-a-process-to-finish&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 。&lt;/p></description></item><item><title>保存被终端转义后的文本</title><link>https://hxhue.github.io/posts/systems/Linux/Linux-%E4%BF%9D%E5%AD%98%E8%A2%AB%E7%BB%88%E7%AB%AF%E8%BD%AC%E4%B9%89%E5%90%8E%E7%9A%84%E6%96%87%E6%9C%AC/</link><pubDate>Mon, 02 Sep 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/Linux-%E4%BF%9D%E5%AD%98%E8%A2%AB%E7%BB%88%E7%AB%AF%E8%BD%AC%E4%B9%89%E5%90%8E%E7%9A%84%E6%96%87%E6%9C%AC/</guid><description>&lt;h1 id="问题起因">问题起因
&lt;a class="header-anchor" href="#%e9%97%ae%e9%a2%98%e8%b5%b7%e5%9b%a0">&lt;/a>
&lt;/h1>&lt;p>我的某个程序会自己打印 &lt;code>\r&lt;/code> 和 &lt;code>\b&lt;/code> 字符以在终端上起到提示效果，但是如果将内容重定向到文件，那么显示出来效果就不好。在很多阅读器中特殊字符不能被正确显示，在 VS Code 中 &lt;code>\r&lt;/code> 会换行，而 &lt;code>\b&lt;/code> 也不会真正起到删除的作用。&lt;/p>
&lt;h1 id="方法-1cat-或者-less--r">方法 1：&lt;code>cat&lt;/code> 或者 &lt;code>less -r&lt;/code>
&lt;a class="header-anchor" href="#%e6%96%b9%e6%b3%95-1cat-%e6%88%96%e8%80%85-less--r">&lt;/a>
&lt;/h1>&lt;p>假设现在文件 A.log 中包含了大量 &lt;code>\r&lt;/code> 和 &lt;code>\b&lt;/code>，想要阅读它可以直接将其 &lt;code>cat&lt;/code> 到终端，或者使用 &lt;code>less -r A.log&lt;/code> 来阅读。&lt;strong>用 &lt;code>less -r&lt;/code> 是比较推荐的，因为还能用 &lt;code>/&lt;/code> 查找、用 &lt;code>&amp;amp;&lt;/code> 过滤&lt;/strong>。&lt;/p>
&lt;h1 id="方法-2col">方法 2：&lt;code>col&lt;/code>
&lt;a class="header-anchor" href="#%e6%96%b9%e6%b3%95-2col">&lt;/a>
&lt;/h1>&lt;p>如果想要真正保存一份和我们在终端看上去一样的文件，可以使用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>col -b &amp;lt; A.log &amp;gt; A1.log
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>bash 搜索内置命令的帮助信息</title><link>https://hxhue.github.io/posts/cli/bash/bash-%E6%90%9C%E7%B4%A2%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF/</link><pubDate>Sat, 31 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/bash-%E6%90%9C%E7%B4%A2%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF/</guid><description>&lt;p>想要搜索 bash 内置命令的帮助信息，但是发现找不到，比如 &lt;code>man ulimit&lt;/code> 没有对应的页面，怎么办呢？&lt;/p>
&lt;p>其实和 bash 内置命令相关的帮助信息就在 bash 的 man 手册当中，可以用 &lt;code>man bash&lt;/code> 来查看。然后在弹出的 less 阅读器中，搜索 &lt;code>SHELL BUILTIN COMMANDS&lt;/code> 就能找到这一栏了（用小写就能搜索）。&lt;/p></description></item><item><title>连续运行程序观察 pid 的变化</title><link>https://hxhue.github.io/posts/systems/Linux/%E8%BF%9E%E7%BB%AD%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%A7%82%E5%AF%9F-pid-%E7%9A%84%E5%8F%98%E5%8C%96/</link><pubDate>Fri, 30 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E8%BF%9E%E7%BB%AD%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%A7%82%E5%AF%9F-pid-%E7%9A%84%E5%8F%98%E5%8C%96/</guid><description>&lt;p>我的测试环境是 wsl，系统是空载的。理想的情况是两次程序的 pid 连续：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ grep -i &lt;span style="color:#2aa198">&amp;#39;^pid:&amp;#39;&lt;/span> /proc/self/status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pid: &lt;span style="color:#2aa198">3355&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ grep -i &lt;span style="color:#2aa198">&amp;#39;^pid:&amp;#39;&lt;/span> /proc/self/status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pid: &lt;span style="color:#2aa198">3356&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但实际上我发现我每次回车（不运行 grep）都会导致 Pid +7，运行 grep 时会 +8（合理，毕竟 grep 本身也是一个进程）。&lt;/p></description></item><item><title>yt-dlp 下载 YouTube 视频</title><link>https://hxhue.github.io/posts/cli/yt-dlp-%E4%B8%8B%E8%BD%BD-YouTube-%E8%A7%86%E9%A2%91/</link><pubDate>Wed, 28 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/yt-dlp-%E4%B8%8B%E8%BD%BD-YouTube-%E8%A7%86%E9%A2%91/</guid><description>&lt;p>下载前使用 &lt;code>-F&lt;/code> 选项来查看视频格式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yt-dlp -F https://www.youtube.com/watch?v&lt;span style="color:#719e07">=&lt;/span>lNPZV9Iqo3U
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下载选定格式的视频（yt-dlp 给 YouTube 视频选的默认格式通常很模糊，但是因为同时包含音频和视频，所以就成了默认）：&lt;/p></description></item><item><title>libstdc++ 中 std::shared_ptr 的内存开销</title><link>https://hxhue.github.io/posts/programming/cpp/libstdc++-%E4%B8%AD-shared_ptr-%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%80%E9%94%80/</link><pubDate>Tue, 27 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libstdc++-%E4%B8%AD-shared_ptr-%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%80%E9%94%80/</guid><description>&lt;h1 id="stdshared_ptrt-的内存开销">&lt;code>std::shared_ptr&amp;lt;T&amp;gt;&lt;/code> 的内存开销
&lt;a class="header-anchor" href="#stdshared_ptrt-%e7%9a%84%e5%86%85%e5%ad%98%e5%bc%80%e9%94%80">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#719e07">::&lt;/span>shared_ptr&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> element_type&lt;span style="color:#719e07">*&lt;/span>    _M_ptr; &lt;span style="color:#586e75">// Contained pointer. sizeof(intptr_t) 字节
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> __shared_count&lt;span style="color:#719e07">&amp;lt;&lt;/span>_Lp&lt;span style="color:#719e07">&amp;gt;&lt;/span>  _M_refcount; &lt;span style="color:#586e75">// Reference counter. sizeof(intptr_t) 字节
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> _Sp_counted_base&lt;span style="color:#719e07">&amp;lt;&lt;/span>_Lp&lt;span style="color:#719e07">&amp;gt;*&lt;/span>  _M_pi;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#719e07">::&lt;/span>_Sp_counted_base&lt;span style="color:#719e07">&amp;lt;&lt;/span>__default_lock_policy&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// vtable pointer // sizeof(intptr_t) 字节
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> _Atomic_word  _M_use_count;     &lt;span style="color:#586e75">// #shared 4 字节，实际上是 int 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> _Atomic_word  _M_weak_count;    &lt;span style="color:#586e75">// #weak + (#shared != 0) 4 字节
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，记录 use count 是为了判断什么时候可以释放共享指针指向的对象；记录 weak count 是为了判断什么时候可以安全释放控制块本身。即便是共享指针指向对象已经被释放（use count 归零），也可能有弱指针会尝试转换成共享指针，因此应该保证这些弱指针能安全查询控制块。还有一点，如果用 &lt;code>std::make_shared&lt;/code> 创建共享指针，use count 归零而 weak count 不归零时，共享对象只是被析构，其内存会等到 weak count 归零时一起被释放。可以参考 &lt;a href="https://stackoverflow.com/a/49585948/" title="https://stackoverflow.com/a/49585948/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/49585948/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 。&lt;/p></description></item><item><title>查找 malloc 和 free 是否配对</title><link>https://hxhue.github.io/posts/cli/bash/bash-%E6%9F%A5%E6%89%BE-malloc-%E5%92%8C-free-%E6%98%AF%E5%90%A6%E9%85%8D%E5%AF%B9/</link><pubDate>Tue, 27 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/bash-%E6%9F%A5%E6%89%BE-malloc-%E5%92%8C-free-%E6%98%AF%E5%90%A6%E9%85%8D%E5%AF%B9/</guid><description>&lt;h1 id="说明">说明
&lt;a class="header-anchor" href="#%e8%af%b4%e6%98%8e">&lt;/a>
&lt;/h1>&lt;p>因为项目有老代码所以才需要这样处理，一般建议用 RAII 等技术避免裸露资源。&lt;/p>
&lt;h1 id="find_mallocsh">find_malloc.sh
&lt;a class="header-anchor" href="#find_mallocsh">&lt;/a>
&lt;/h1>&lt;p>要点：&lt;/p>
&lt;ol>
&lt;li>用 gcc 去除代码注释。&lt;/li>
&lt;li>用 awk 对正则表达式计数。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>check&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gcc -fpreprocessed -dD -E -P &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#268bd2">$1&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> 2&amp;gt;/dev/null | awk -v &lt;span style="color:#268bd2">file&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#268bd2">$1&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#2aa198">&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> BEGIN {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> malloc=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> free=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> queueCreate=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> queueDestroy=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> notifierCreate=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> notifierDestroy=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> handleCreate=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> handleDestroy=0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtMalloc\(/ { malloc++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtFree\(/ { free++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtQueueCreate\(/ { queueCreate++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtCreateQueue\(/ { queueCreate++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtDestroyQueue\(/ { queueDestroy++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtQueueDestroy\(/ { queueDestroy++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtCreateNotifier\(/ { notifierCreate++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnrtDestroyNotifier\(/ { notifierDestroy++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnnlCreate\(/ { handleCreate++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> /cnnlDestroy\(/ { handleDestroy++; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> END {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> if (malloc != free) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> print &amp;#34;file: &amp;#34; file &amp;#34;, malloc: &amp;#34; malloc &amp;#34;, free: &amp;#34; free
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> if (queueCreate != queueDestroy) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> print &amp;#34;file: &amp;#34; file &amp;#34;, queueCreate: &amp;#34; queueCreate &amp;#34;, queueDestroy: &amp;#34; queueDestroy
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> if (notifierCreate != notifierDestroy) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> print &amp;#34;file: &amp;#34; file &amp;#34;, notifierCreate: &amp;#34; notifierCreate &amp;#34;, notifierDestroy: &amp;#34; notifierDestroy
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> if (handleCreate != handleDestroy) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> print &amp;#34;file: &amp;#34; file &amp;#34;, handleCreate: &amp;#34; handleCreate &amp;#34;, handleDestroy: &amp;#34; handleDestroy
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>check &lt;span style="color:#268bd2">$1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="find_malloc_allsh">find_malloc_all.sh
&lt;a class="header-anchor" href="#find_malloc_allsh">&lt;/a>
&lt;/h1>&lt;p>要点：使用 &lt;code>find&lt;/code> 匹配时应该选择正则表达式类型，同时和 Python 的 &lt;code>re&lt;/code> 模块一样要全字符串匹配（不能匹配只部分字符，因此想只匹配中间部分的时候，就要在两边加上 &lt;code>.*&lt;/code>）。&lt;/p></description></item><item><title>换新笔记本之后 OneDrive 没有把桌面同步过来</title><link>https://hxhue.github.io/posts/systems/Windows/%E6%8D%A2%E6%96%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%B9%8B%E5%90%8E-OneDrive-%E6%B2%A1%E6%9C%89%E6%8A%8A%E6%A1%8C%E9%9D%A2%E5%90%8C%E6%AD%A5%E8%BF%87%E6%9D%A5/</link><pubDate>Mon, 19 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/%E6%8D%A2%E6%96%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%B9%8B%E5%90%8E-OneDrive-%E6%B2%A1%E6%9C%89%E6%8A%8A%E6%A1%8C%E9%9D%A2%E5%90%8C%E6%AD%A5%E8%BF%87%E6%9D%A5/</guid><description>&lt;p>OneDrive 可以同步桌面，我以前的桌面是 &lt;code>C:\Users\xxx\OneDrive\Desktop&lt;/code>，现在我的新电脑的桌面是 &lt;code>C:\Users\xxx\Desktop&lt;/code>，虽然 OneDrive 仍然保存了之前的文件夹，但是没有对桌面进行同步。&lt;/p>
&lt;p>解决方案是从文件资源管理器进入用户目录，然后右键桌面，选择位置 &amp;gt; 移动。点击移动之后桌面上面的文件就会被移动到新的路径（新路径的旧文件不会被删除，遇到同名文件会询问是否覆盖），随后新的路径会被设置为桌面。&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/Pasted%20image%2020240819140125.webp">&lt;/p></description></item><item><title>PyTorch 的 CPU 计算为什么使用 double 作为 32 位浮点数的累加类型？</title><link>https://hxhue.github.io/posts/programming/python/PyTorch-%E7%9A%84-CPU-%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-double-%E4%BD%9C%E4%B8%BA-32-%E4%BD%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B4%AF%E5%8A%A0%E7%B1%BB%E5%9E%8B/</link><pubDate>Sat, 10 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/PyTorch-%E7%9A%84-CPU-%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-double-%E4%BD%9C%E4%B8%BA-32-%E4%BD%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B4%AF%E5%8A%A0%E7%B1%BB%E5%9E%8B/</guid><description>&lt;div class="markdown-alert markdown-alert-tip">
 &lt;p class="markdown-alert-title">
 &lt;svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true">
 &lt;path
 d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z">
 &lt;/path>
 &lt;/svg>Tip&lt;/p>
 &lt;p>本文没有得到最终结论，只是一些个人猜想。&lt;/p></description></item><item><title>CUDA Kernel 常用 float 类型这件事</title><link>https://hxhue.github.io/posts/programming/cuda/CUDA-Kernel-%E5%B8%B8%E7%94%A8-float-%E7%B1%BB%E5%9E%8B%E8%BF%99%E4%BB%B6%E4%BA%8B/</link><pubDate>Fri, 09 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cuda/CUDA-Kernel-%E5%B8%B8%E7%94%A8-float-%E7%B1%BB%E5%9E%8B%E8%BF%99%E4%BB%B6%E4%BA%8B/</guid><description>&lt;p>本文分别讨论双精度、单精度、半精度的浮点数计算，最后提及混合精度。在 CPU 方面，仅考虑 x86-64 CPU 和 GNU/Linux 上的 GCC 编译器；GPU 方面仅考虑 NVIDIA GPU。&lt;/p>
&lt;h1 id="gpu-上双精度计算慢在哪里">GPU 上双精度计算慢在哪里？
&lt;a class="header-anchor" href="#gpu-%e4%b8%8a%e5%8f%8c%e7%b2%be%e5%ba%a6%e8%ae%a1%e7%ae%97%e6%85%a2%e5%9c%a8%e5%93%aa%e9%87%8c">&lt;/a>
&lt;/h1>&lt;p>&lt;a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions" title="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 以上链接说明：GPU 双精度浮点数运算比单精度浮点数慢，在有些架构（很多 $x.y~(y \ne 0)$ 运算能力的 GPU 都是游戏卡）上甚至慢得多。除了指令慢之外，double 类型也不利于 cache 和全局内存带宽。&lt;/p></description></item><item><title>要小心 C++ 静态初始化顺序</title><link>https://hxhue.github.io/posts/programming/cpp/%E8%A6%81%E5%B0%8F%E5%BF%83-C++-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</link><pubDate>Tue, 06 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E8%A6%81%E5%B0%8F%E5%BF%83-C++-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</guid><description>&lt;p>&lt;a href="https://godbolt.org/z/n5bjMGcx3" title="https://godbolt.org/z/n5bjMGcx3" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://godbolt.org/z/n5bjMGcx3&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>编译器并不会自动根据代码的依赖关系去编排静态初始化顺序，示例代码中 &lt;code>vec&lt;/code> 在被推入两个元素之后又被初始化了一次（在 compiler explorer 中看汇编也能看出来）。&lt;/p></description></item><item><title>torch 自动求导的代码在哪里？</title><link>https://hxhue.github.io/posts/programming/python/torch-%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC%E5%92%8C%E6%B4%BE%E5%8F%91%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9C%A8%E5%93%AA%E9%87%8C/</link><pubDate>Mon, 05 Aug 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/torch-%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC%E5%92%8C%E6%B4%BE%E5%8F%91%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9C%A8%E5%93%AA%E9%87%8C/</guid><description>&lt;p>2024 年 8 月 5 日：当前 torch 发布的版本是 2.4。PyTorch 的源码中还有几个 YAML 文件，这些文件都挺重要的，可以关注一下。&lt;/p>
&lt;p>tools/autograd/derivatives.yaml 中有一些求导代码片段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#268bd2">name&lt;/span>: prod.dim_int(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None) -&amp;gt; Tensor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">self&lt;/span>: prod_backward(grad, self.to(grad.scalar_type()), result, dim, keepdim)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">result&lt;/span>: (prod_backward(at::ones({}, result.options()).expand_as(result), self_p.to(result.scalar_type()), result, dim, keepdim) * self_t.conj()).sum(dim, keepdim).conj()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#268bd2">name&lt;/span>: put(Tensor self, Tensor index, Tensor source, bool accumulate=False) -&amp;gt; Tensor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">self&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;accumulate ? grad : grad.put(index, zeros_like(source), false)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">index&lt;/span>: non_differentiable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">source&lt;/span>: grad.take(index).reshape_as(source)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">result&lt;/span>: self_t.put(index, source_t, accumulate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#268bd2">name&lt;/span>: linalg_qr(Tensor A, str mode=&amp;#39;reduced&amp;#39;) -&amp;gt; (Tensor Q, Tensor R)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">A&lt;/span>: linalg_qr_backward(grad_Q, grad_R, Q, R, mode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">Q, R&lt;/span>: linalg_qr_jvp(A_t, Q, R, mode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#268bd2">name&lt;/span>: rad2deg(Tensor self) -&amp;gt; Tensor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">self&lt;/span>: rad2deg_backward(grad)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">result&lt;/span>: auto_element_wise
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#268bd2">name&lt;/span>: random_.from(Tensor(a!) self, int from, int? to, *, Generator? generator=None) -&amp;gt; Tensor(a!)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">self&lt;/span>: zeros_like(grad)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">result&lt;/span>: self_t.zero_()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#268bd2">name&lt;/span>: random_.to(Tensor(a!) self, int to, *, Generator? generator=None) -&amp;gt; Tensor(a!)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">self&lt;/span>: zeros_like(grad)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">result&lt;/span>: self_t.zero_()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看起来 &lt;code>name&lt;/code> 是近似于 python 的伪代码，其他的都是 C++ 代码？&lt;/p></description></item><item><title>私有化构造函数</title><link>https://hxhue.github.io/posts/programming/cpp/%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 22 Jul 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid><description>&lt;p>有的时候我们希望私有化构造函数，然后要求用户只通过工厂方法访问我们的类型，在 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/cpp-templates-the-complete-guide/21-Templates-and-Inheritance/#std-enable_shared_from_this" title="std::enable_shared_from_this 的例子" >&lt;code>std::enable_shared_from_this&lt;/code> 的例子&lt;/a> 中就有使用。这个例子是从 cppreference 上面抄来的。但是今天我发现去年 11 月有人修改了网页上的例子，修订记录为 &lt;a href="https://en.cppreference.com/mwiki/index.php?title=cpp%2Fmemory%2Fenable_shared_from_this&amp;amp;diff=162885&amp;amp;oldid=153414" title="https://en.cppreference.com/mwiki/index.php?title=cpp%2Fmemory%2Fenable_shared_from_this&amp;diff=162885&amp;oldid=153414" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/mwiki/index.php?title=cpp%2Fmemory%2Fenable_shared_from_this&amp;diff=162885&amp;oldid=153414&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 。&lt;/p></description></item><item><title>GNU 扩展语法：带有返回值的多语句表达式</title><link>https://hxhue.github.io/posts/programming/cpp/GNU-%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95%E5%B8%A6%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A4%9A%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Sat, 13 Jul 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/GNU-%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95%E5%B8%A6%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A4%9A%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>&lt;p>&lt;a href="https://godbolt.org/z/vo195MYGj" title="https://godbolt.org/z/vo195MYGj" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://godbolt.org/z/vo195MYGj&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> ({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上代码返回 1。在花括号中写多条语句都没关系。&lt;/p></description></item><item><title>torch 分布式程序产生僵尸进程</title><link>https://hxhue.github.io/posts/programming/python/torch-%E5%88%86%E5%B8%83%E5%BC%8F%E7%A8%8B%E5%BA%8F%E4%BA%A7%E7%94%9F%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 08 Jul 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/torch-%E5%88%86%E5%B8%83%E5%BC%8F%E7%A8%8B%E5%BA%8F%E4%BA%A7%E7%94%9F%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</guid><description>&lt;p>聊天记录：&lt;/p>
&lt;blockquote>
 &lt;p>A
torch 的分布式程序在一些异常结束的情况下会留下一些僵尸进程
我之前经常是这样
你 kill 掉主进程子进程不会被回收&lt;/p>
&lt;p>B
为什么没有会回收？因为父进程没死且没有被回收，难道父进程不是 torch 的主进程，而是整个容器里面的一个活跃进程？
不在容器里使用是否不会出现这种情况？
如果父进程死了，应该由 init 回收
是否是因为容器的起始进程不是 init&lt;/p></description></item><item><title>对 CMake 构建类型 CMAKE_BUILD_TYPE 的考量</title><link>https://hxhue.github.io/posts/cli/cmake/%E5%AF%B9-CMake-%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B-CMAKE_BUILD_TYPE-%E7%9A%84%E8%80%83%E9%87%8F/</link><pubDate>Sun, 07 Jul 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/cmake/%E5%AF%B9-CMake-%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B-CMAKE_BUILD_TYPE-%E7%9A%84%E8%80%83%E9%87%8F/</guid><description>&lt;h1 id="参考">参考
&lt;a class="header-anchor" href="#%e5%8f%82%e8%80%83">&lt;/a>
&lt;/h1>&lt;p>&lt;a href="https://stackoverflow.com/a/59314670/" title="https://stackoverflow.com/a/59314670/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/59314670/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html" title="https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 的解释：&lt;/p>
&lt;blockquote>
 &lt;p>Specifies the build type on single-configuration generators (e.g. &lt;a href="https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html#makefile-generators" title="Makefile Generators" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Makefile Generators&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> or &lt;a href="https://cmake.org/cmake/help/latest/generator/Ninja.html#generator:Ninja" title="Ninja" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >&lt;code>Ninja&lt;/code>&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>). Typical values include &lt;code>Debug&lt;/code>, &lt;code>Release&lt;/code>, &lt;code>RelWithDebInfo&lt;/code> and &lt;code>MinSizeRel&lt;/code>, but custom build types can also be defined.&lt;/p>
&lt;/blockquote>&lt;p>Stack Overflow 回答里提到的 BetaTest 等其他构建类型应该就是上面所说的 &lt;em>custom build types&lt;/em>.&lt;/p></description></item><item><title>对键盘的碎碎念</title><link>https://hxhue.github.io/posts/life/%E5%AF%B9%E9%94%AE%E7%9B%98%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</link><pubDate>Sat, 06 Jul 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/life/%E5%AF%B9%E9%94%AE%E7%9B%98%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</guid><description>&lt;h1 id="说明">说明
&lt;a class="header-anchor" href="#%e8%af%b4%e6%98%8e">&lt;/a>
&lt;/h1>&lt;p>这里放的是我觉得没有必要专门写一篇文章的内容。&lt;/p>
&lt;h1 id="2024-07-06">2024-07-06
&lt;a class="header-anchor" href="#2024-07-06">&lt;/a>
&lt;/h1>&lt;p>V75K 不同的键有点高低不一致了，怀疑是定位板被我弄的不平了。数字 5、6、7、8 这几个位置不仅突起，而且手感还偏硬，估计是下面有电池（这同时意味着这个地方不应该再使劲按下去了，可能不安全）；回车的位置下陷了，我觉得是装键帽使劲按回车导致的。&lt;/p></description></item><item><title>利用 ssh-agent 在两个服务器之间传输文件</title><link>https://hxhue.github.io/posts/cli/ssh/%E5%88%A9%E7%94%A8-ssh-agent-%E5%9C%A8%E4%B8%A4%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 06 Jul 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/ssh/%E5%88%A9%E7%94%A8-ssh-agent-%E5%9C%A8%E4%B8%A4%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">eval&lt;/span> &lt;span style="color:#719e07">$(&lt;/span>ssh-agent -s&lt;span style="color:#719e07">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ssh-add ~/.ssh/id_ed25519 &lt;span style="color:#586e75"># 根据实际情况操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ssh -A server1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scp server2:/data /data
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于 sever1 可能没有把 server2 作为主机存储，在 &lt;code>scp&lt;/code> 的时候需要输入一长串的用户名、主机、端口。&lt;/p></description></item><item><title>less 大小写不敏感搜索、过滤</title><link>https://hxhue.github.io/posts/cli/common/less-%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E6%90%9C%E7%B4%A2%E8%BF%87%E6%BB%A4/</link><pubDate>Thu, 04 Jul 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/common/less-%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E6%90%9C%E7%B4%A2%E8%BF%87%E6%BB%A4/</guid><description>&lt;h1 id="启用标记例子大小写不敏感搜索">启用标记（例子：大小写不敏感搜索）
&lt;a class="header-anchor" href="#%e5%90%af%e7%94%a8%e6%a0%87%e8%ae%b0%e4%be%8b%e5%ad%90%e5%a4%a7%e5%b0%8f%e5%86%99%e4%b8%8d%e6%95%8f%e6%84%9f%e6%90%9c%e7%b4%a2">&lt;/a>
&lt;/h1>&lt;p>&lt;code>-&lt;/code> 加上其他字符。比如 &lt;code>-i&lt;/code> 表示开关大小写敏感搜索（ignore case in searches）。但是，这只对全小写的输入有用，如果查询的词中包含大写字母、又想要大小写不敏感搜索，则需要使用 &lt;code>-I&lt;/code>（ignore case in searches and in patterns）。&lt;/p></description></item><item><title>ctrl + f5 可以强制 chrome 拉取最新的网页资源</title><link>https://hxhue.github.io/posts/programming/www/ctrl-+-f5-%E5%8F%AF%E4%BB%A5%E5%BC%BA%E5%88%B6-chrome-%E6%8B%89%E5%8F%96%E6%9C%80%E6%96%B0%E7%9A%84%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90/</link><pubDate>Sat, 29 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/www/ctrl-+-f5-%E5%8F%AF%E4%BB%A5%E5%BC%BA%E5%88%B6-chrome-%E6%8B%89%E5%8F%96%E6%9C%80%E6%96%B0%E7%9A%84%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90/</guid><description>&lt;p>如题。&lt;/p></description></item><item><title>为什么用 tar.gz 安装的共享库 gcc 找不到？</title><link>https://hxhue.github.io/posts/systems/Linux/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-tar.gz-%E5%AE%89%E8%A3%85%E7%9A%84%E5%85%B1%E4%BA%AB%E5%BA%93-gcc-%E6%89%BE%E4%B8%8D%E5%88%B0/</link><pubDate>Fri, 28 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-tar.gz-%E5%AE%89%E8%A3%85%E7%9A%84%E5%85%B1%E4%BA%AB%E5%BA%93-gcc-%E6%89%BE%E4%B8%8D%E5%88%B0/</guid><description>&lt;h1 id="情况">情况
&lt;a class="header-anchor" href="#%e6%83%85%e5%86%b5">&lt;/a>
&lt;/h1>&lt;p>项目是由 CMake 构建的动态库，用 CPack 我们打包得到了一个 deb 包版本和一个 tar.gz 的压缩包版本。前者安装之后 demo 能够正常编译运行，但是在换用压缩包安装共享库后编译 demo 则出现了找不到库的错误（这里讨论的是非标准路径的情况，即安装路径不在 &lt;code>/&lt;/code>、&lt;code>/usr&lt;/code> 和 &lt;code>/usr/local&lt;/code> 下）。&lt;/p></description></item><item><title>Debian 本地软件包的安装和卸载</title><link>https://hxhue.github.io/posts/systems/Linux/Debian-%E6%9C%AC%E5%9C%B0%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/</link><pubDate>Thu, 27 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/Debian-%E6%9C%AC%E5%9C%B0%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/</guid><description>&lt;p>操作起来感觉 apt 和 dpkg 在安装和卸载软件上是可以混用的，其一安装的包可以由另外一者去卸载。&lt;/p>
&lt;h1 id="安装软件-i----install">安装软件（&lt;code>-i&lt;/code> | &lt;code>--install&lt;/code>）
&lt;a class="header-anchor" href="#%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6-i----install">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>dpkg -i localpackage.deb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>经过测试，不必像 apt 一样需要加上 &lt;code>./&lt;/code> 前缀以安装本地的软件包。&lt;/p></description></item><item><title>鲸海轴体验</title><link>https://hxhue.github.io/posts/life/2024%E5%B9%B46%E6%9C%8825%E6%97%A5-%E9%B2%B8%E6%B5%B7%E8%BD%B4%E4%BD%93%E9%AA%8C/</link><pubDate>Tue, 25 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/life/2024%E5%B9%B46%E6%9C%8825%E6%97%A5-%E9%B2%B8%E6%B5%B7%E8%BD%B4%E4%BD%93%E9%AA%8C/</guid><description>&lt;p>狼蛛 M75 在 618 首发会送 80 颗鲸海轴，把鲸海轴的价格打下来了，全新在咸鱼上是 75~80 元。而且是刚好 80 颗！和我的 V75K 的按键数一样，所以头脑一热就入了。我前几天也把极光冰淇淋轴和静音轴都出了：静音轴体用着还是有点憋屈，而冰淇淋轴对于我来说始发压力（30 gf）太轻了，在滑键的时候会发出声音，我不喜欢。&lt;/p></description></item><item><title>CUDA 中 SFINAE 的坑</title><link>https://hxhue.github.io/posts/programming/cuda/CUDA-%E4%B8%AD-SFINAE-%E7%9A%84%E5%9D%91/</link><pubDate>Sat, 22 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cuda/CUDA-%E4%B8%AD-SFINAE-%E7%9A%84%E5%9D%91/</guid><description>&lt;h1 id="tldr">TL;DR
&lt;a class="header-anchor" href="#tldr">&lt;/a>
&lt;/h1>&lt;p>如果想要写一些 traits，而且涉及到了函数和变量（而不是类型），则需要同时加上 &lt;code>__device__&lt;/code> 和 &lt;code>__host__&lt;/code> 以确保它在 device 侧和 host 侧都可见。否则会因为 SFINAE 不报错（实际上可能是在 device 侧找不到函数或变量），而且不知道为什么结果不对。&lt;/p></description></item><item><title>极光冰淇淋轴体验</title><link>https://hxhue.github.io/posts/life/2024%E5%B9%B46%E6%9C%8819%E6%97%A5-%E6%9E%81%E5%85%89%E5%86%B0%E6%B7%87%E6%B7%8B%E8%BD%B4%E4%BD%93%E9%AA%8C/</link><pubDate>Wed, 19 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/life/2024%E5%B9%B46%E6%9C%8819%E6%97%A5-%E6%9E%81%E5%85%89%E5%86%B0%E6%B7%87%E6%B7%8B%E8%BD%B4%E4%BD%93%E9%AA%8C/</guid><description>&lt;p>极光冰淇淋轴是我从咸鱼上买的，本来买完有点后悔，因为我看到了有人出我更想要的蓝莓冰淇淋，而且价格相当好，但是这倒也没什么。比较难受的是：卖家说自己是到手拆，但是我拿到的轴针脚歪歪扭扭的，特别是有一个轴的金色针脚都快从中间一分二了。如果平时都没怎么用过，我都不敢想装货的时候有多暴力。而且这个卖家卖了特别多键设，原来大家的容忍度都这么高吗？&lt;/p></description></item><item><title>模除运算</title><link>https://hxhue.github.io/posts/programming/cpp/%E6%A8%A1%E9%99%A4%E8%BF%90%E7%AE%97/</link><pubDate>Sun, 16 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E6%A8%A1%E9%99%A4%E8%BF%90%E7%AE%97/</guid><description>&lt;p>C++ 中两数相除（假设被除数和除数都不是 0），同号则结果为正，异号则结果为负。模除运算则定义为：&lt;/p>
&lt;blockquote>
 &lt;p>If $a~/~b$ is representable in the result type, $(a~/~b)*b + a~\%~b == a$.（来自 &lt;a href="https://en.cppreference.com/w/cpp/language/operator_arithmetic" title="https://en.cppreference.com/w/cpp/language/operator_arithmetic" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/language/operator_arithmetic&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> ）&lt;/p>
&lt;/blockquote>&lt;p>实践起来则是：在被除数不是 0 的情况下，模除运算的结果总是和除数同正负。&lt;/p></description></item><item><title>记一次代码合并后发生错误的定位过程</title><link>https://hxhue.github.io/posts/cli/git/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%E5%90%8E%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%E7%9A%84%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B/</link><pubDate>Wed, 12 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/git/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%E5%90%8E%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%E7%9A%84%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B/</guid><description>&lt;p>昨天晚上合并完新的代码准备提交上去但是 CI 跑不了，有一个单元测试报错。然后照着官方的 &lt;a href="https://www.git-scm.com/docs/git-bisect" title="git-bisect" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >git-bisect&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 文档找问题。这个工具比想象中要好用很多，大部分时间都花在了构建项目上面（每次修改 HEAD 之后都要重新构建才能测试）。半个小时后锁定了问题在一个具体的提交上。&lt;/p></description></item><item><title>以 zstd 压缩方式导出镜像</title><link>https://hxhue.github.io/posts/cli/docker/%E4%BB%A5-zstd-%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F%E5%AF%BC%E5%87%BA%E9%95%9C%E5%83%8F/</link><pubDate>Wed, 12 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/%E4%BB%A5-zstd-%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F%E5%AF%BC%E5%87%BA%E9%95%9C%E5%83%8F/</guid><description>&lt;h1 id="步骤">步骤
&lt;a class="header-anchor" href="#%e6%ad%a5%e9%aa%a4">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker save image:tag | zstd -o image.tar.zst
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>docker save&lt;/code> 是将镜像输出到标准输出流，&lt;code>docker save -o&lt;/code> 是将输出写入到文件。&lt;/li>
&lt;li>&lt;code>zstd -o&lt;/code> 是将压缩数据写入文件，而 &lt;code>zstd -c&lt;/code> 是将压缩的数据输出到标准输出流。&lt;/li>
&lt;/ul>
&lt;h1 id="为什么用-zstd-而不是-gzip-来压缩">为什么用 zstd 而不是 gzip 来压缩
&lt;a class="header-anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%94%a8-zstd-%e8%80%8c%e4%b8%8d%e6%98%af-gzip-%e6%9d%a5%e5%8e%8b%e7%bc%a9">&lt;/a>
&lt;/h1>&lt;ol>
&lt;li>zstd 在 ubuntu/debian 中有现成的包可以下载，安装非常轻松。&lt;/li>
&lt;li>压缩速度非常快，压缩比可以接受。&lt;/li>
&lt;li>&lt;strong>我的使用场景&lt;/strong>是在服务器之间传输文件，带宽很高，所以不想花太多时间在压缩和解压上。&lt;/li>
&lt;/ol></description></item><item><title>水蜜桃、青柠 V3 + 新的拔轴器体验</title><link>https://hxhue.github.io/posts/life/2024%E5%B9%B46%E6%9C%8810%E6%97%A5-%E6%B0%B4%E8%9C%9C%E6%A1%83%E9%9D%92%E6%9F%A0-V3-%E4%BD%93%E9%AA%8C%E6%96%B0%E7%9A%84%E6%8B%94%E8%BD%B4%E5%99%A8%E5%88%B0%E8%B4%A7/</link><pubDate>Mon, 10 Jun 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/life/2024%E5%B9%B46%E6%9C%8810%E6%97%A5-%E6%B0%B4%E8%9C%9C%E6%A1%83%E9%9D%92%E6%9F%A0-V3-%E4%BD%93%E9%AA%8C%E6%96%B0%E7%9A%84%E6%8B%94%E8%BD%B4%E5%99%A8%E5%88%B0%E8%B4%A7/</guid><description>&lt;h1 id="新的拔键器到货不好用">新的拔键器到货（😓不好用）
&lt;a class="header-anchor" href="#%e6%96%b0%e7%9a%84%e6%8b%94%e9%94%ae%e5%99%a8%e5%88%b0%e8%b4%a7%e4%b8%8d%e5%a5%bd%e7%94%a8">&lt;/a>
&lt;/h1>&lt;p>之前的文章说键盘附送的拔键器会伤到键帽，所以买了个新的拔键器：&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/%E6%8B%94%E9%94%AE%E6%8B%94%E8%BD%B4%E5%99%A8.webp">&lt;/p>
&lt;p>&lt;strong>拔轴&lt;/strong>要把整个拔轴器按下去，退轴的时候要拨弹簧卡扣，也不是不好用吧，但是我觉得比原来的拔轴器麻烦。&lt;strong>拔键&lt;/strong>要向下压弹簧才能把拔键器卡进键位，实际感受是比较累的，既不如送的拔键器小巧，又不如它好用。而且拔键的一端卡不到某些键位里面去，以下两张图中都是因为碰到了键盘边框所以无法卡进去：&lt;/p></description></item><item><title>小白入坑挑键盘经历</title><link>https://hxhue.github.io/posts/life/2024%E5%B9%B45%E6%9C%8829%E6%97%A5-%E5%B0%8F%E7%99%BD%E5%85%A5%E5%9D%91%E6%8C%91%E9%94%AE%E7%9B%98%E7%BB%8F%E5%8E%86/</link><pubDate>Wed, 29 May 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/life/2024%E5%B9%B45%E6%9C%8829%E6%97%A5-%E5%B0%8F%E7%99%BD%E5%85%A5%E5%9D%91%E6%8C%91%E9%94%AE%E7%9B%98%E7%BB%8F%E5%8E%86/</guid><description>&lt;h1 id="更新">更新
&lt;a class="header-anchor" href="#%e6%9b%b4%e6%96%b0">&lt;/a>
&lt;/h1>&lt;ol>
&lt;li>2024 年 6 月 26 日：解决在桌面上移动键盘时脚撑发出刺耳摩擦声的办法：在脚撑上面贴上透明胶布。&lt;/li>
&lt;li>2024 年 6 月 29 日：现在键盘因为多次拔键拔轴已经是战损状态了，尤其是卫星轴和定位板之间卡不紧、有松动，问题相当大。很扎心：






&lt;img src="https://hxhue.github.io/assets/2024%E5%B9%B45%E6%9C%8829%E6%97%A5%20%E5%B0%8F%E7%99%BD%E5%85%A5%E5%9D%91%E6%8C%91%E9%94%AE%E7%9B%98%E7%BB%8F%E5%8E%86-20240701004504369.webp">以后选键盘还是选个一开始就能接受轴体的，不要再换轴了吧 (*^_^*) 。总觉得 V75K 的卫星轴专门顺着阿尼亚轴的短行程调过（或者是挑选过），换阿尼亚轴匹配度更高一点。我现在没有别的轴体了（卖了），就试了鲸海轴，空格左侧是有 &lt;a href="https://www.bilibili.com/video/BV1z341127ba/" title="空键程" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >空键程&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 的，换成阿尼亚轴就好一点。&lt;/li>
&lt;/ol>
&lt;h1 id="买键盘的历史">买键盘的历史
&lt;a class="header-anchor" href="#%e4%b9%b0%e9%94%ae%e7%9b%98%e7%9a%84%e5%8e%86%e5%8f%b2">&lt;/a>
&lt;/h1>&lt;p>本人小白，以前都是用薄膜键盘，这两个月买过以下键盘：&lt;/p></description></item><item><title>UNIX 中 printf 指定参数绑定顺序</title><link>https://hxhue.github.io/posts/programming/cpp/UNIX-%E4%B8%AD-printf-%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E9%A1%BA%E5%BA%8F/</link><pubDate>Thu, 16 May 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/UNIX-%E4%B8%AD-printf-%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E9%A1%BA%E5%BA%8F/</guid><description>&lt;h1 id="unix-中的-printf">UNIX 中的 &lt;code>printf&lt;/code>
&lt;a class="header-anchor" href="#unix-%e4%b8%ad%e7%9a%84-printf">&lt;/a>
&lt;/h1>&lt;p>Single UNIX Specification 中允许 &lt;code>printf&lt;/code> 使用 &lt;code>%m$&lt;/code> 和 &lt;code>*m$&lt;/code> 的形式来绑定第 m 个参数，其中 m 从 1 开始计数。如果使用了这种表达方式，则所有参数都要指定序号，而且不能遗漏参数。这样做的好处是：可以多次使用同一个参数。&lt;/p></description></item><item><title>我们实验室的服务器曾如何处理 Docker 数据转移的问题？</title><link>https://hxhue.github.io/posts/systems/Linux/%E6%88%91%E4%BB%AC%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%BE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-Docker-%E6%95%B0%E6%8D%AE%E8%BD%AC%E7%A7%BB%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 15 May 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E6%88%91%E4%BB%AC%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%BE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-Docker-%E6%95%B0%E6%8D%AE%E8%BD%AC%E7%A7%BB%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="修改配置文件">修改配置文件
&lt;a class="header-anchor" href="#%e4%bf%ae%e6%94%b9%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6">&lt;/a>
&lt;/h1>&lt;p>网上一般推荐的做法是这种： &lt;a href="https://linuxiac.com/how-to-change-docker-data-directory/" title="https://linuxiac.com/how-to-change-docker-data-directory/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://linuxiac.com/how-to-change-docker-data-directory/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>修改 /etc/docker/daemon.json，向其中加入：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#268bd2">&amp;#34;data-root&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;/new/docker/root&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者在 systemd 的服务启动程序中指定数据的路径。&lt;/p></description></item><item><title>cudaLaunchKernel 非常耗时？</title><link>https://hxhue.github.io/posts/programming/cuda/cudaLaunchKernel-%E9%9D%9E%E5%B8%B8%E8%80%97%E6%97%B6/</link><pubDate>Sun, 12 May 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cuda/cudaLaunchKernel-%E9%9D%9E%E5%B8%B8%E8%80%97%E6%97%B6/</guid><description>&lt;h1 id="事情起因">事情起因
&lt;a class="header-anchor" href="#%e4%ba%8b%e6%83%85%e8%b5%b7%e5%9b%a0">&lt;/a>
&lt;/h1>&lt;p>在第一次使用 nsys 的时候发现 &lt;code>cudaLaunchKernel&lt;/code> 非常耗时。网友觉得 &lt;code>cudaLaunchKernel&lt;/code> 超过了 50ms 就觉得很大了，但我在服务器上测是 400~500ms！&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/cudaLaunchKernel%20%E8%80%97%E6%97%B6%EF%BC%9F-20240512005128828.webp">&lt;/p>
&lt;p>我想到的可能原因：&lt;/p>
&lt;ul>
&lt;li>服务器的 CPU 和 GPU 负载太高。用环境变量 &lt;code>CUDA_VISIBLE_DEVICES&lt;/code> 换到同一台服务器上相对比较空闲的卡，发现 kernel 启动时间从平均 440 ms 减少到了 372 ms，因此可以排除 GPU 负载高的影响。&lt;/li>
&lt;li>启动 kernel 时申请的资源太多。我们自己写的 kernel 每个 block 都是固定 512 线程数，GPU 为 3090，每个 SM 上最大能容纳 1024 个线程；对 cudnn 的调用（比如卷积核）看了一下是用满了 1024 线程数。&lt;/li>
&lt;li>GPU 在 warmup 阶段。&lt;/li>
&lt;/ul>
&lt;h1 id="真正原因">真正原因
&lt;a class="header-anchor" href="#%e7%9c%9f%e6%ad%a3%e5%8e%9f%e5%9b%a0">&lt;/a>
&lt;/h1>&lt;p>&lt;strong>GPU 在 warmup 阶段&lt;/strong>。&lt;/p></description></item><item><title>在 Ubuntu 上安装和使用 nsys</title><link>https://hxhue.github.io/posts/programming/cuda/%E5%9C%A8-Ubuntu-%E4%B8%8A%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-nsys/</link><pubDate>Sat, 11 May 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cuda/%E5%9C%A8-Ubuntu-%E4%B8%8A%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-nsys/</guid><description>&lt;h1 id="安装">安装
&lt;a class="header-anchor" href="#%e5%ae%89%e8%a3%85">&lt;/a>
&lt;/h1>&lt;p>&lt;code>nsys&lt;/code> 来自包 &lt;code>cuda-nsight-systems-11-7&lt;/code>（和自己的 CUDA 版本对应一下）。&lt;/p>
&lt;p>在网上一直都没有搜到安装方式，官网也说的不明不白。尝试过两个错误的包：&lt;/p></description></item><item><title>std::lower_bound 是一种分区查找算法</title><link>https://hxhue.github.io/posts/programming/cpp/std__lower_bound-%E6%98%AF%E4%B8%80%E7%A7%8D%E5%88%86%E5%8C%BA%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 04 May 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/std__lower_bound-%E6%98%AF%E4%B8%80%E7%A7%8D%E5%88%86%E5%8C%BA%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="起因每日一题官解看不明白">起因：每日一题官解看不明白
&lt;a class="header-anchor" href="#%e8%b5%b7%e5%9b%a0%e6%af%8f%e6%97%a5%e4%b8%80%e9%a2%98%e5%ae%98%e8%a7%a3%e7%9c%8b%e4%b8%8d%e6%98%8e%e7%99%bd">&lt;/a>
&lt;/h1>&lt;p>今天（2024 年 5 月 4 日）做 Leetcode 每日一题又没有做出来，最后抄了答案。题目是这样的：&lt;a href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/" title="1235. 规划兼职工作" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >1235. 规划兼职工作&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>。&lt;/p>
&lt;p>思路是先按照 &lt;code>endTime&lt;/code> 排序，然后再 dp，然后 dp 中用二分查找求满足“自己的 &lt;code>endTime&lt;/code> 小于等于当前元素 &lt;code>startTime&lt;/code> ” 的元素数量。但是官方解答的 &lt;code>std::upper_bound&lt;/code> 传参实在是看迷糊了。&lt;/p></description></item><item><title>为什么我不推荐用 enum class 作为强类型的整数？</title><link>https://hxhue.github.io/posts/programming/cpp/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%94%A8-enum-class-%E4%BD%9C%E4%B8%BA%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B4%E6%95%B0/</link><pubDate>Sat, 27 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%94%A8-enum-class-%E4%BD%9C%E4%B8%BA%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B4%E6%95%B0/</guid><description>&lt;h1 id="c11-之后-enum-的新增功能">C++11 之后 enum 的新增功能
&lt;a class="header-anchor" href="#c11-%e4%b9%8b%e5%90%8e-enum-%e7%9a%84%e6%96%b0%e5%a2%9e%e5%8a%9f%e8%83%bd">&lt;/a>
&lt;/h1>&lt;p>enum class 是 C++11 提供的功能，为了更好理解后文的内容，我们先看看 C++11 之后 enum 有什么变化。参考资料见 &lt;a href="https://en.cppreference.com/w/cpp/language/enum" title="https://en.cppreference.com/w/cpp/language/enum" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/language/enum&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 。&lt;/p>
&lt;h2 id="有作用域枚举">有作用域枚举
&lt;a class="header-anchor" href="#%e6%9c%89%e4%bd%9c%e7%94%a8%e5%9f%9f%e6%9e%9a%e4%b8%be">&lt;/a>
&lt;/h2>&lt;p>有作用域枚举（Scoped enumerations）使用 &lt;code>enum class|struct ClassName&lt;/code> 声明，以区别于原来的无作用域枚举。无作用域枚举的枚举量可以直接在外围名字空间中访问，当枚举类有名字且 C++ 版本至少为 C++11 时，可以通过 &lt;code>枚举名::枚举量&lt;/code> 访问；有作用域枚举只能通过 &lt;code>枚举名::枚举量&lt;/code> 访问。&lt;/p></description></item><item><title>cudaDeviceSynchronize 和 cudaStreamSynchronize</title><link>https://hxhue.github.io/posts/programming/cuda/cudaDeviceSynchronize-%E5%92%8C-cudaStreamSynchronize/</link><pubDate>Thu, 25 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cuda/cudaDeviceSynchronize-%E5%92%8C-cudaStreamSynchronize/</guid><description>&lt;h1 id="我的理解">我的理解
&lt;a class="header-anchor" href="#%e6%88%91%e7%9a%84%e7%90%86%e8%a7%a3">&lt;/a>
&lt;/h1>&lt;p>CUDA 的 API 都是和 device 相关的，调用前要先确保已经调用过 &lt;code>cudaSetDevice&lt;/code> 将 context 关联到相关的设备上（据 Stackoverflow 的&lt;a href="https://stackoverflow.com/q/64854862/" title="老提问" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >老提问&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>，这个 context 会占用 &lt;del>150 MB 显存；从我这边来看，这个显存占用量还更大一些，有 200&lt;/del>300 MB）。创建流是不需要提供设备号的，所以它肯定使用的是 thread_local 的 device。&lt;/p></description></item><item><title>inline 函数不对外链接？gnu89 和 c99 恐怖的语义对换！</title><link>https://hxhue.github.io/posts/programming/cpp/inline-%E5%87%BD%E6%95%B0%E4%B8%8D%E5%AF%B9%E5%A4%96%E9%93%BE%E6%8E%A5gnu89-%E5%92%8C-c99-%E6%81%90%E6%80%96%E7%9A%84%E8%AF%AD%E4%B9%89%E5%AF%B9%E6%8D%A2/</link><pubDate>Thu, 25 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/inline-%E5%87%BD%E6%95%B0%E4%B8%8D%E5%AF%B9%E5%A4%96%E9%93%BE%E6%8E%A5gnu89-%E5%92%8C-c99-%E6%81%90%E6%80%96%E7%9A%84%E8%AF%AD%E4%B9%89%E5%AF%B9%E6%8D%A2/</guid><description>&lt;h1 id="经过">经过
&lt;a class="header-anchor" href="#%e7%bb%8f%e8%bf%87">&lt;/a>
&lt;/h1>&lt;p>遇到过一个坑：为共享库写函数，但是又需要从头文件隐藏实现时，不要将函数声明为内联。否则编译器会认为它未被使用并忽略它，链接的时候就找不到这个函数。&lt;/p></description></item><item><title>gitlab-jh 和 gitlab-ce 的区别以及博客内容声明</title><link>https://hxhue.github.io/posts/systems/Linux/gitlab/gitlab-jh-%E5%92%8C-gitlab-ce-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E5%A3%B0%E6%98%8E/</link><pubDate>Mon, 22 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/gitlab/gitlab-jh-%E5%92%8C-gitlab-ce-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E5%A3%B0%E6%98%8E/</guid><description>&lt;p>Gitlab 极狐版本是极狐购买了经营权的版本，内部也分会员版。从免费版的功能来看，两者几乎没有区别。但是为了更严谨一些，本博客中所有内容都可能是在 gitlab-jh 或者 gitlab-ce 上试过（或者混用），不保证仅在 gitlab-ce 上操作（尽管它们的操作方式应该一致）。&lt;/p></description></item><item><title>VS Code 无法使用 cuda-gdb 调试</title><link>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8-cuda-gdb-%E8%B0%83%E8%AF%95/</link><pubDate>Mon, 22 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8-cuda-gdb-%E8%B0%83%E8%AF%95/</guid><description>&lt;p>创建 &lt;code>launch.json&lt;/code> 的时候找不到 &lt;code>cuda-gdb&lt;/code> 这个 type：需要安装 Nsight Visual Studio Code Edition：&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/VS%20Code%20%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%20cuda-gdb%20%E8%B0%83%E8%AF%95-20240422190718604.webp">&lt;/p></description></item><item><title>在 Gitlab 实例之间创建仓库镜像</title><link>https://hxhue.github.io/posts/systems/Linux/gitlab/%E5%9C%A8-Gitlab-%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F/</link><pubDate>Mon, 22 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/gitlab/%E5%9C%A8-Gitlab-%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F/</guid><description>&lt;div class="markdown-alert markdown-alert-important">
 &lt;p class="markdown-alert-title">&lt;svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" width="16" height="16"
 aria-hidden="true">
 &lt;path
 d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z">
 &lt;/path>
 &lt;/svg>Important&lt;/p></description></item><item><title>Docker 更改地址段</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E6%9B%B4%E6%94%B9%E5%9C%B0%E5%9D%80%E6%AE%B5/</link><pubDate>Wed, 17 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E6%9B%B4%E6%94%B9%E5%9C%B0%E5%9D%80%E6%AE%B5/</guid><description>&lt;h1 id="先说解决方案">先说解决方案
&lt;a class="header-anchor" href="#%e5%85%88%e8%af%b4%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88">&lt;/a>
&lt;/h1>&lt;p>参考 &lt;a href="https://stackoverflow.com/a/73287366/" title="Networking problems with WSL2 and Docker Desktop for windows" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Networking problems with WSL2 and Docker Desktop for windows&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>，编辑 /etc/docker/daemon.json，加入 &lt;code>&amp;quot;bip&amp;quot;: &amp;quot;192.168.200.1/24&amp;quot;&lt;/code>（根据实际情况替换），然后 &lt;code>systemctl&lt;/code> 重载配置、重启 Docker 一通操作后用 &lt;code>ip route&lt;/code> 和 &lt;code>ifconfig&lt;/code> 验证一下变化。&lt;/p></description></item><item><title>libc++ 和 libstdc++ 中 basic_string 的 SSO 比较</title><link>https://hxhue.github.io/posts/programming/cpp/libc++-%E5%92%8C-libstdc++-%E4%B8%AD-basic_string-%E7%9A%84-SSO-%E6%AF%94%E8%BE%83/</link><pubDate>Sat, 13 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libc++-%E5%92%8C-libstdc++-%E4%B8%AD-basic_string-%E7%9A%84-SSO-%E6%AF%94%E8%BE%83/</guid><description>&lt;h1 id="参考">参考
&lt;a class="header-anchor" href="#%e5%8f%82%e8%80%83">&lt;/a>
&lt;/h1>&lt;p>&lt;a href="https://joellaity.com/2020/01/31/string.html" title="https://joellaity.com/2020/01/31/string.html" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://joellaity.com/2020/01/31/string.html&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>&lt;code>std::string&lt;/code> 是 &lt;code>std::basic_string&amp;lt;&amp;gt;&lt;/code> 的一个特化，该类的 &lt;code>value_type&lt;/code> 是 char。本文虽然是讨论 &lt;code>std::basic_string&amp;lt;&amp;gt;&lt;/code> 的实现方式，但是为了方便，&lt;strong>假设 &lt;code>value_type&lt;/code> 是 &lt;code>char&lt;/code>、假设目标平台是 64 位&lt;/strong>，讨论时也将把 &lt;code>std::basic_string&amp;lt;&amp;gt;&lt;/code> 和 &lt;code>std::string&lt;/code> 互用。&lt;/p></description></item><item><title>如何提技术问题？</title><link>https://hxhue.github.io/posts/collaboration/%E5%A6%82%E4%BD%95%E6%8F%90%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 10 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/collaboration/%E5%A6%82%E4%BD%95%E6%8F%90%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="我在做什么">我在做什么？
&lt;a class="header-anchor" href="#%e6%88%91%e5%9c%a8%e5%81%9a%e4%bb%80%e4%b9%88">&lt;/a>
&lt;/h1>&lt;p>你想要最终达成什么（目标）？你采用了什么样的路径来达成它（途径）？&lt;/p>
&lt;div class="markdown-alert markdown-alert-tip">
 &lt;p class="markdown-alert-title">
 &lt;svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true">
 &lt;path
 d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z">
 &lt;/path>
 &lt;/svg>Tip&lt;/p></description></item><item><title>Docker 配置镜像源</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E6%BA%90/</link><pubDate>Tue, 09 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E6%BA%90/</guid><description>&lt;h1 id="资源">资源
&lt;a class="header-anchor" href="#%e8%b5%84%e6%ba%90">&lt;/a>
&lt;/h1>&lt;p>可用 Docker Hub 镜像加速器列表见 &lt;a href="https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6" title="Docker Hub 镜像加速器" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Docker Hub 镜像加速器&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>。&lt;/p>
&lt;h1 id="修改方式">修改方式
&lt;a class="header-anchor" href="#%e4%bf%ae%e6%94%b9%e6%96%b9%e5%bc%8f">&lt;/a>
&lt;/h1>&lt;p>网络上有不少教程是先修改 /etc/docker/daemon.json，然后：&lt;/p></description></item><item><title>language/implicit_conversion 限定性类型转换</title><link>https://hxhue.github.io/posts/programming/cpp/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E6%80%A7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link><pubDate>Sun, 07 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E6%80%A7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid><description>&lt;h1 id="写在前面">写在前面
&lt;a class="header-anchor" href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2">&lt;/a>
&lt;/h1>&lt;p>内容见 &lt;a href="https://en.cppreference.com/w/cpp/language/implicit_conversion" title="implicit conversion" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >implicit conversion&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>。&lt;/p>
&lt;p>限定性转换指的是和 cv 属性有关的类型转换，它的发生必须满足一定的条件。&lt;/p>
&lt;h1 id="相似类型">相似类型
&lt;a class="header-anchor" href="#%e7%9b%b8%e4%bc%bc%e7%b1%bb%e5%9e%8b">&lt;/a>
&lt;/h1>&lt;p>忽略掉各层的 cv 属性，如果两个类型形式相同，就是相似类型。比如 &lt;code>const int* volatile *&lt;/code> 和 &lt;code>int** const&lt;/code>。&lt;/p></description></item><item><title>Copy elision</title><link>https://hxhue.github.io/posts/programming/cpp/Copy-elision/</link><pubDate>Tue, 02 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Copy-elision/</guid><description>&lt;h1 id="参考">参考
&lt;a class="header-anchor" href="#%e5%8f%82%e8%80%83">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>&lt;a href="https://en.cppreference.com/w/cpp/language/copy_elision" title="https://en.cppreference.com/w/cpp/language/copy_elision" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/language/copy_elision&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=PTCFddZfnXc" title="https://www.youtube.com/watch?v=PTCFddZfnXc" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://www.youtube.com/watch?v=PTCFddZfnXc&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 2024 年 6 月 26 日：这个视频讲了 GCC 的新 &lt;code>-Wnrvo&lt;/code> 编译参数。&lt;/li>
&lt;/ul>
&lt;h1 id="c17-prvalue-semantics-guaranteed-copy-elision">C++17 prvalue semantics (&amp;ldquo;guaranteed copy elision&amp;rdquo;)
&lt;a class="header-anchor" href="#c17-prvalue-semantics-guaranteed-copy-elision">&lt;/a>
&lt;/h1>&lt;p>返回值（或函数参数）的位置，如果表达式是纯右值，且返回值（或函数参数）需要的也是同一类型的纯右值，那么标准就要求省略复制和移动。不过，为了让语义检查通过，&lt;strong>要构造对象的析构函数必须在此处可以访问&lt;/strong>，尽管在完成优化之后并不会用到析构函数。&lt;/p></description></item><item><title>VS Code gdb 不能 pretty-printing</title><link>https://hxhue.github.io/posts/developer/vscode/VS-Code-gdb-%E4%B8%8D%E8%83%BD-pretty-printing/</link><pubDate>Mon, 01 Apr 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/VS-Code-gdb-%E4%B8%8D%E8%83%BD-pretty-printing/</guid><description>&lt;p>这个问题在 Windows MSYS2 中没有出现，但是在 WSL 上出现了。在调试时对 &lt;code>std::vector&lt;/code> 的显示如下：&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/Pasted%20image%2020240401145112.webp">&lt;/p>
&lt;p>本来我是用的 CMake 上的调试启动功能的，&lt;a href="https://stackoverflow.com/questions/56828562/unable-to-see-elements-of-stdvector-with-gcc-in-vs-code" title="StackOverflow" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >StackOverflow&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 上面让用 .vscode/launch.json，我也试了，但是同样不行。这是我写的启动文件内容，主要是在 &lt;code>setupCommands&lt;/code> 中打开了 pretty-printing 功能：&lt;/p></description></item><item><title>NVIDIA 显卡显存占用高但是 nvidia-smi 查不到</title><link>https://hxhue.github.io/posts/systems/Linux/NVIDIA-%E6%98%BE%E5%8D%A1%E6%98%BE%E5%AD%98%E5%8D%A0%E7%94%A8%E9%AB%98%E4%BD%86%E6%98%AF-nvidia-smi-%E6%9F%A5%E4%B8%8D%E5%88%B0/</link><pubDate>Wed, 27 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/NVIDIA-%E6%98%BE%E5%8D%A1%E6%98%BE%E5%AD%98%E5%8D%A0%E7%94%A8%E9%AB%98%E4%BD%86%E6%98%AF-nvidia-smi-%E6%9F%A5%E4%B8%8D%E5%88%B0/</guid><description>&lt;h1 id="解决方案">解决方案
&lt;a class="header-anchor" href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88">&lt;/a>
&lt;/h1>&lt;p>假设是 3 号卡，用 &lt;code>sudo lsof /dev/nvidia3&lt;/code> 看看有哪些进程正在使用这个设备。然后用各种手段查看各个可疑进程的信息（假设进程号是 66666）：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ps ww 66666&lt;/code>（&lt;a href="https://unix.stackexchange.com/questions/243252/ps-wide-output-for-a-single-process" title="BSD 风格的 ps" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >BSD 风格的 &lt;code>ps&lt;/code>&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>，而不是 System V）。&lt;/li>
&lt;li>&lt;code>cat /proc/66666/status&lt;/code> 查看进程状态。除了 status 之外，还有其他信息可以在 /proc 下查看。&lt;/li>
&lt;li>&lt;code>htop -p 66666&lt;/code> 或者 &lt;code>top -p 66666&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>确定进程没用之后，就可以根据 PID 杀掉进程了。&lt;/p></description></item><item><title>C++: Rule of 3/5/0</title><link>https://hxhue.github.io/posts/programming/cpp/C++-Rule-of-3-5-0/</link><pubDate>Sun, 24 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++-Rule-of-3-5-0/</guid><description>&lt;p>&lt;a href="https://en.cppreference.com/w/cpp/language/rule_of_three" title="https://en.cppreference.com/w/cpp/language/rule_of_three" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://en.cppreference.com/w/cpp/language/rule_of_three&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;h1 id="rule-of-3">Rule of 3
&lt;a class="header-anchor" href="#rule-of-3">&lt;/a>
&lt;/h1>&lt;p>析构函数、拷贝构造、拷贝赋值三者要是定义了其一，最好把其他两个都补上，因为编译生成的很可能不是我们想要的。此外，&lt;strong>定义三者之一会导致移动构造、移动赋值被删除&lt;/strong>。&lt;/p>
&lt;div class="markdown-alert markdown-alert-note">
 &lt;p class="markdown-alert-title">&lt;svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16"
 aria-hidden="true">
 &lt;path
 d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
 &lt;/path>
 &lt;/svg>Note&lt;/p>
 &lt;p>显式删除拷贝构造函数（&lt;code>MyClass(const MyClass&amp;amp;) = delete;&lt;/code>）也是一种声明，这样会导致移动构造函数被删除，如果有移动尝试则会匹配上（被删除的）拷贝构造函数，从而编译失败。&lt;/p>
&lt;/div>&lt;div class="markdown-alert markdown-alert-tip">
 &lt;p class="markdown-alert-title">
 &lt;svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true">
 &lt;path
 d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z">
 &lt;/path>
 &lt;/svg>Tip&lt;/p>
 &lt;p>复制 / 移动赋值操作符可以用复制 / 移动构造函数 + &lt;code>std::swap&lt;/code> 实现。&lt;/p>
&lt;/div></description></item><item><title>Docker attach 之后不能退出</title><link>https://hxhue.github.io/posts/cli/docker/Docker-attach-%E4%B9%8B%E5%90%8E%E4%B8%8D%E8%83%BD%E9%80%80%E5%87%BA/</link><pubDate>Sat, 16 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-attach-%E4%B9%8B%E5%90%8E%E4%B8%8D%E8%83%BD%E9%80%80%E5%87%BA/</guid><description>&lt;p>Docker 不能用 &lt;kbd>CTRL&lt;/kbd> + &lt;kbd>p&lt;/kbd>，&lt;kbd>CTRL&lt;/kbd> + &lt;kbd>q&lt;/kbd> 退出的解决方案：登录后先用 &lt;code>tty&lt;/code> 看自己的终端。然后用另外一个连接 &lt;code>ps -af&lt;/code> 看想要终止的 &lt;code>docker&lt;/code> 命令的 pid 是多少，然后用 &lt;code>kill -9&lt;/code> 强杀。因为杀的是客户端而不是守护进程，所以不需要担心其他正在运行的容器受到影响。&lt;/p></description></item><item><title>Docker 查询和管理</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%AE%A1%E7%90%86/</link><pubDate>Sat, 16 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%AE%A1%E7%90%86/</guid><description>&lt;h1 id="查看所有容器的资源占用">查看所有容器的资源占用
&lt;a class="header-anchor" href="#%e6%9f%a5%e7%9c%8b%e6%89%80%e6%9c%89%e5%ae%b9%e5%99%a8%e7%9a%84%e8%b5%84%e6%ba%90%e5%8d%a0%e7%94%a8">&lt;/a>
&lt;/h1>&lt;p>&lt;code>docker stats&lt;/code> 可以实时刷新所有容器的占用情况。用 &lt;code>docker stats --no-stream&lt;/code> 只看最近一次，而不像 &lt;code>top&lt;/code> 一样刷新。不知道哪个容器占用多的时候可以使用这个命令。&lt;/p>
&lt;h1 id="找到进程属于哪一个容器">找到进程属于哪一个容器
&lt;a class="header-anchor" href="#%e6%89%be%e5%88%b0%e8%bf%9b%e7%a8%8b%e5%b1%9e%e4%ba%8e%e5%93%aa%e4%b8%80%e4%b8%aa%e5%ae%b9%e5%99%a8">&lt;/a>
&lt;/h1>&lt;p>我们实验室的不同学生使用不同的容器作为开发环境。现在的问题是，当我们从 &lt;code>htop&lt;/code> 或者 &lt;code>top&lt;/code> 中发现某个进程消耗了大量资源时，我们需要确定这个进程是由哪个容器启动的，怎么做呢？&lt;/p></description></item><item><title>不同编译器如何处理 C 语言函数名？</title><link>https://hxhue.github.io/posts/programming/cpp/%E4%B8%8D%E5%90%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-C-%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%90%8D/</link><pubDate>Sat, 16 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E4%B8%8D%E5%90%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-C-%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%90%8D/</guid><description>&lt;p>&lt;a href="https://godbolt.org/z/YrzsWbMh8" title="https://godbolt.org/z/YrzsWbMh8" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://godbolt.org/z/YrzsWbMh8&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>在以下几种编译器上都尝试了：&lt;/p>
&lt;ol>
&lt;li>x86-64 gcc 13.2&lt;/li>
&lt;li>x86-64 clang 18.1.0&lt;/li>
&lt;li>x64 msvc v19.38&lt;/li>
&lt;li>x86 msvc v19.38&lt;/li>
&lt;/ol>
&lt;p>发现只有 &lt;strong>x86 msvc v19.38&lt;/strong> 给函数名前面加了下划线，其他几种编译器都是尊重函数定义的名字。以前做川合秀实的 30 天自制操作系统时，还以为所有编译器都会固定地给 C 语言函数名前面加上下划线，所以汇编中引用时有一些区别。现在看来只是因为平台不同，所以编译器处理方式也不同。&lt;/p></description></item><item><title>创建内网 Overleaf</title><link>https://hxhue.github.io/posts/systems/Linux/%E5%88%9B%E5%BB%BA%E5%86%85%E7%BD%91-Overleaf/</link><pubDate>Thu, 14 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E5%88%9B%E5%BB%BA%E5%86%85%E7%BD%91-Overleaf/</guid><description>&lt;p>有两种方案，推荐第 2 种。&lt;/p>
&lt;h1 id="方案-1docker-compose">方案 1：docker-compose
&lt;a class="header-anchor" href="#%e6%96%b9%e6%a1%88-1docker-compose">&lt;/a>
&lt;/h1>&lt;p>截至 2024 年 3 月 14 日 最新的 docker-compose 文件是 &lt;a href="https://raw.githubusercontent.com/overleaf/overleaf/408e1dccd7c0cb58fe02c5eb9ef983312ad9b244/docker-compose.yml" title="https://raw.githubusercontent.com/overleaf/overleaf/408e1dccd7c0cb58fe02c5eb9ef983312ad9b244/docker-compose.yml" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://raw.githubusercontent.com/overleaf/overleaf/408e1dccd7c0cb58fe02c5eb9ef983312ad9b244/docker-compose.yml&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>首先把 docker-compose 配置文件下载下来修改好 sharelatex 的端口、sharelatex/redis/mongo 的映射路径。&lt;/p></description></item><item><title>记录一次 LaTeX 不能编译的解决过程</title><link>https://hxhue.github.io/posts/latex/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1-LaTeX-%E4%B8%8D%E8%83%BD%E7%BC%96%E8%AF%91%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</link><pubDate>Thu, 14 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/latex/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1-LaTeX-%E4%B8%8D%E8%83%BD%E7%BC%96%E8%AF%91%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</guid><description>&lt;p>同学把 LaTeX 源码文件夹从 Windows 电脑上拷贝给我，但是无法编译，说是里面有几个字体找不到。我改了 &lt;code>fontspec&lt;/code> 的几个设置，包括 &lt;code>\setmainfont&lt;/code> 等，向其中用 &lt;code>Path=&lt;/code> 选项添加了 &lt;code>fonts/&lt;/code> 的路径（之前没有路径，找的是系统字体）。但是还是不能编译！&lt;/p></description></item><item><title>C++20 之前向下转换到有符号数无法表示时是实现定义</title><link>https://hxhue.github.io/posts/programming/cpp/C++20-%E4%B9%8B%E5%89%8D%E5%90%91%E4%B8%8B%E8%BD%AC%E6%8D%A2%E5%88%B0%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%97%A0%E6%B3%95%E8%A1%A8%E7%A4%BA%E6%97%B6%E6%98%AF%E5%AE%9E%E7%8E%B0%E5%AE%9A%E4%B9%89/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++20-%E4%B9%8B%E5%89%8D%E5%90%91%E4%B8%8B%E8%BD%AC%E6%8D%A2%E5%88%B0%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%97%A0%E6%B3%95%E8%A1%A8%E7%A4%BA%E6%97%B6%E6%98%AF%E5%AE%9E%E7%8E%B0%E5%AE%9A%E4%B9%89/</guid><description>&lt;h1 id="什么是向下转换">什么是向下转换
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%90%91%e4%b8%8b%e8%bd%ac%e6%8d%a2">&lt;/a>
&lt;/h1>&lt;p>向下转换是可能出现溢出的转换。检查是否为向下转换：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> To, &lt;span style="color:#719e07">typename&lt;/span> From, &lt;span style="color:#719e07">typename&lt;/span> &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#dc322f">void&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">NotNarrowing&lt;/span>&lt;span style="color:#719e07">:&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>false_type {};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> To, &lt;span style="color:#719e07">typename&lt;/span> From&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">NotNarrowing&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>To, From, std&lt;span style="color:#719e07">::&lt;/span>void_t&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">decltype&lt;/span>(To{std&lt;span style="color:#719e07">::&lt;/span>declval&lt;span style="color:#719e07">&amp;lt;&lt;/span>From&lt;span style="color:#719e07">&amp;gt;&lt;/span>()})&lt;span style="color:#719e07">&amp;gt;&amp;gt;:&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>true_type {};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>To{std::declval&amp;lt;From&amp;gt;()}&lt;/code> 这一步如果用在具体的类型上（比如说 int 和 unsigned），编译器是只给警告，不会报错。如果能够在编译期推导出来数值，则会根据数值来选择通过或报错。比如 &lt;code>char{'a'};&lt;/code> 是正常编译的，但是 &lt;code>char{300};&lt;/code> 是会报错的。&lt;/p></description></item><item><title>自定义 ostream</title><link>https://hxhue.github.io/posts/programming/cpp/%E8%87%AA%E5%AE%9A%E4%B9%89-ostream/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E8%87%AA%E5%AE%9A%E4%B9%89-ostream/</guid><description>&lt;p>下面的代码继承了 &lt;code>std::streambuf&lt;/code> 改变了 &lt;code>ostream&lt;/code> 的行为，并自定义了打印操作将结果送到 &lt;code>stdout&lt;/code>，而不是 &lt;code>std::cout&lt;/code> 中（当然也可以更改逻辑修改打印的细节）。&lt;/p>
&lt;p>其中的 &lt;code>print&lt;/code> 函数是仿 C++23 &lt;code>std::print&lt;/code> 的，功能仅仅是打印参数，在笔记 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/posts/programming/cpp/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%8A%B1%E6%8B%AC%E5%8F%B7%E6%8F%92%E5%80%BC%E6%89%93%E5%8D%B0/" title="实现简单的花括号插值打印" >实现简单的花括号插值打印&lt;/a> 中实现。&lt;/p></description></item><item><title>CUDA 程序第一次运行很慢</title><link>https://hxhue.github.io/posts/programming/cuda/CUDA-%E7%A8%8B%E5%BA%8F%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%90%E8%A1%8C%E5%BE%88%E6%85%A2/</link><pubDate>Mon, 12 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cuda/CUDA-%E7%A8%8B%E5%BA%8F%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%90%E8%A1%8C%E5%BE%88%E6%85%A2/</guid><description>&lt;p>&lt;a href="https://developer.nvidia.com/blog/cuda-pro-tip-understand-fat-binaries-jit-caching/" title="https://developer.nvidia.com/blog/cuda-pro-tip-understand-fat-binaries-jit-caching/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://developer.nvidia.com/blog/cuda-pro-tip-understand-fat-binaries-jit-caching/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>CUDA 程序有两种代码：一是设备无关的 PTX，二是设备有关的二进制代码。在运行之前将 PTX 编译成二进制代码就是 JIT 过程。（当然，nvcc 会在文件系统里面存储 cache。）用 &lt;code>-arch=sm_xx&lt;/code> 可以只为给定的架构编译，从而运行时不需要 JIT 这一步。&lt;/p></description></item><item><title>deb 包里面装的是什么？</title><link>https://hxhue.github.io/posts/systems/Linux/deb-%E5%8C%85%E9%87%8C%E9%9D%A2%E8%A3%85%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88/</link><pubDate>Fri, 09 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/deb-%E5%8C%85%E9%87%8C%E9%9D%A2%E8%A3%85%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88/</guid><description>&lt;h1 id="格式解析">格式解析
&lt;a class="header-anchor" href="#%e6%a0%bc%e5%bc%8f%e8%a7%a3%e6%9e%90">&lt;/a>
&lt;/h1>&lt;p>根据维基百科，deb 包是一个标准的 ar 归档。&lt;/p>
&lt;p>因此，对于 Modern CMake for C++ 中示例代码用 CPack 创建的包 CPackPackage-1.2.3-Linux.deb，可以直接解压。&lt;/p></description></item><item><title>tar</title><link>https://hxhue.github.io/posts/cli/common/tar/</link><pubDate>Thu, 08 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/common/tar/</guid><description>&lt;p>tar 的时候可以指定压缩，要注意打包的时候如果用了压缩，解包的时候需要用同样的算法来解压。这个并不是自动识别的。比如：&lt;/p>
&lt;p>&lt;code>tar -zcf xxx.tar.gz files&lt;/code> 对应于 &lt;code>tar -zxf xxx.tar.gz&lt;/code>。&lt;/p>
&lt;p>而且，如果不压缩就不要用 &lt;code>.tar.gz&lt;/code> 来命名，而是用 &lt;code>.tar&lt;/code>。（如果是其他压缩格式就用其他的命名方式。）&lt;/p></description></item><item><title>wget</title><link>https://hxhue.github.io/posts/cli/common/wget/</link><pubDate>Thu, 08 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/common/wget/</guid><description>&lt;h1 id="下载整个站点">下载整个站点
&lt;a class="header-anchor" href="#%e4%b8%8b%e8%bd%bd%e6%95%b4%e4%b8%aa%e7%ab%99%e7%82%b9">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># https://stackoverflow.com/a/11514515/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget -r -p -np -k &lt;span style="color:#2aa198">${&lt;/span>&lt;span style="color:#268bd2">URL&lt;/span>&lt;span style="color:#2aa198">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>CMake 代码风格</title><link>https://hxhue.github.io/posts/cli/cmake/CMake-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</link><pubDate>Wed, 07 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/cmake/CMake-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</guid><description>&lt;p>感觉 CMake 的语法不是很容易格式化，感觉怎么都别扭。现在我看到一种格式的思路比较好，&lt;strong>就是把命令的每个选项都当成 yaml 配置文件去写&lt;/strong>，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">install&lt;/span>(&lt;span style="color:#2aa198">FILES&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">src/include/calc/calc.h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">src/include/calc/nested/calc_extended.h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">DESTINATION&lt;/span> &lt;span style="color:#719e07">${&lt;/span>&lt;span style="color:#268bd2">CMAKE_INSTALL_INCLUDEDIR&lt;/span>&lt;span style="color:#719e07">}&lt;/span>&lt;span style="color:#2aa198">/calc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种列表就换行+缩进。&lt;/p></description></item><item><title>find</title><link>https://hxhue.github.io/posts/cli/common/find/</link><pubDate>Mon, 05 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/common/find/</guid><description>&lt;p>&lt;code>find&lt;/code> 的 &lt;code>-exec&lt;/code> 选项中，以 &lt;code>;&lt;/code> 结尾（注意 shell 转义）是对每个文件单独运行命令。而 &lt;code>+&lt;/code> 结尾是对所有文件用 xargs 的形式运行命令。可以从以下例子看出：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ find . -name &lt;span style="color:#2aa198">&amp;#39;*.cu&amp;#39;&lt;/span> -exec &lt;span style="color:#b58900">echo&lt;/span> &lt;span style="color:#719e07">{}&lt;/span> +
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./basic_interop.cu ./ripple.cu ./heat.cu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ find . -name &lt;span style="color:#2aa198">&amp;#39;*.cu&amp;#39;&lt;/span> -exec &lt;span style="color:#b58900">echo&lt;/span> &lt;span style="color:#719e07">{}&lt;/span> &lt;span style="color:#cb4b16">\;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./basic_interop.cu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./ripple.cu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./heat.cu
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>-depth&lt;/code> 选项让 find 以深度优先的顺序访问文件，这样文件夹就一定比其包含的子文件后访问，这对于删除等工作非常重要。&lt;/p></description></item><item><title>bash 行编辑</title><link>https://hxhue.github.io/posts/cli/bash/bash-%E8%A1%8C%E7%BC%96%E8%BE%91/</link><pubDate>Fri, 02 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/bash-%E8%A1%8C%E7%BC%96%E8%BE%91/</guid><description>&lt;p>默认的是 emacs 模式的行编辑。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>ctrl _ yank
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ctrl y yank
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ctrl / undo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alt f word-level forward
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alt b word-level backward
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alt d word-level delete 这个可能会更好用，因为 d 按键更近
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alt backspace word-level backspace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>git-blame-ignore-revs</title><link>https://hxhue.github.io/posts/cli/git/git-blame-ignore-revs/</link><pubDate>Fri, 02 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/git/git-blame-ignore-revs/</guid><description>&lt;p>LLVM 项目中有个文件：.git-blame-ignore-revs&lt;/p>
&lt;p>说明是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span># Since version 2.23 (released in August 2019), git-blame has a feature
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># to ignore or bypass certain commits.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>#
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># This file contains a list of commits that are not likely what you
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># are looking for in a blame, such as mass reformatting or renaming.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># You can set this file as a default ignore file for blame by running
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># the following command.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>#
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># $ git config blame.ignoreRevsFile .git-blame-ignore-revs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个文件可以指定要在 blame 时忽略的那些提交（比如对工程整体的格式化）。因为 git 配置是本地的，所以需要手动跑一次。&lt;/p></description></item><item><title>VS Code 错误：Remote Extension host terminated unexpectedly 3 times within the last 5 minutes.</title><link>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E9%94%99%E8%AF%AFRemote-Extension-host-terminated-unexpectedly-3-times-within-the-last-5-minutes./</link><pubDate>Fri, 02 Feb 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E9%94%99%E8%AF%AFRemote-Extension-host-terminated-unexpectedly-3-times-within-the-last-5-minutes./</guid><description>&lt;p>可能是因为上次对 wsl2 vdisk compact 之后造成的？还是因为升级之后造成的？&lt;/p>
&lt;p>尝试过以下方法：&lt;/p>
&lt;ul>
&lt;li>删除 ~/.vscode 和 ~/.vscode-server 里面的所有东西然后重新下载。不行。&lt;/li>
&lt;li>禁用所有扩展，不行。&lt;/li>
&lt;/ul>
&lt;p>发现在 vscode 的终端使用 code 打开文件夹就有问题，但是在 code 之外的终端用 code 命令就没有问题。一看在 vscode 终端中的 code 命令竟然还是 windows 文件系统中的 code 命令，并不是 vscode-server 提供的 code 命令。&lt;/p></description></item><item><title>C++ 模板显式实例化</title><link>https://hxhue.github.io/posts/programming/cpp/C++-%E6%A8%A1%E6%9D%BF%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++-%E6%A8%A1%E6%9D%BF%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96/</guid><description>&lt;p>头文件：template.hpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#ifndef TEMPLATE_HPP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#define TEMPLATE_HPP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> T&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> println(T t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>源文件：main.cpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;#34;template.hpp&amp;#34;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#2aa198">9&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">7&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>源文件：instantiation.cpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;#34;template.hpp&amp;#34;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> T&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> println(T t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> t &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 特化声明：失败，因为没有定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// template &amp;lt;&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// void println&amp;lt;int&amp;gt;(int);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 显式实例化：成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> println&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>(&lt;span style="color:#dc322f">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// template void println(int); // 如果能够从函数参数中推导出模板参数，也可以省略模板参数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 特化定义：成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// template &amp;lt;&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// void println&amp;lt;int&amp;gt;(int t) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// std::cout &amp;lt;&amp;lt; &amp;#34;instantiation.cpp: &amp;#34; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// }
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>翻译单元 A 要调用模板函数：&lt;/p></description></item><item><title>C++ 重定向输出的几种方案：iostream rdbuf、stdio freopen、unix fd</title><link>https://hxhue.github.io/posts/programming/cpp/C++-%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88iostream-rdbufstdio-freopenunix-fd/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++-%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88iostream-rdbufstdio-freopenunix-fd/</guid><description>&lt;p>在看 Modern CMake for C++ 的时候看到了这段代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">RunOutputsCorrectEquations&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string expected {&lt;span style="color:#2aa198">&amp;#34;2 + 2 = 4&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">3 * 3 = 9&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stringstream buffer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// redirect cout
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">auto&lt;/span> prevcoutbuf &lt;span style="color:#719e07">=&lt;/span> cout.rdbuf(buffer.rdbuf());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">auto&lt;/span> output &lt;span style="color:#719e07">=&lt;/span> buffer.str();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// restore original buffer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> cout.rdbuf(prevcoutbuf);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (expected &lt;span style="color:#719e07">!=&lt;/span> output)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit(&lt;span style="color:#2aa198">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看起来 stdio 的 FILE 也能重定向（但是不能保存之前的关联，因而恢复到 stdout 不能跨平台）：&lt;/p></description></item><item><title>CMake CONFIG 生成器表达式</title><link>https://hxhue.github.io/posts/cli/cmake/CMake-CONFIG-%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/cmake/CMake-CONFIG-%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>&lt;p>cmake 的 &lt;code>CONFIG&lt;/code> 生成器表达式有两种形式，一种是不接受参数、输出当前的 CONFIG 值，还有一种是判断当前的 CONFIG 是否属于几者之一。在判断 Debug 模式的时候一定要小心，因为使用 Makefile 作为生成器时，不传入 &lt;code>CMAKE_BUILD_TYPE&lt;/code> 时使用的 CONFIG 为空。&lt;/p></description></item><item><title>CMake 学过又忘记的写法</title><link>https://hxhue.github.io/posts/cli/cmake/CMake-%E5%AD%A6%E8%BF%87%E5%8F%88%E5%BF%98%E8%AE%B0%E7%9A%84%E5%86%99%E6%B3%95/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/cmake/CMake-%E5%AD%A6%E8%BF%87%E5%8F%88%E5%BF%98%E8%AE%B0%E7%9A%84%E5%86%99%E6%B3%95/</guid><description>&lt;p>这篇用来记录学过但是不容易记住的写法。&lt;/p>
&lt;p>CMake language&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">add_subdirectory&lt;/span>(&lt;span style="color:#2aa198">source_dir&lt;/span> &lt;span style="color:#2aa198">[binary_dir]&lt;/span> &lt;span style="color:#2aa198">[EXCLUDE_FROM_ALL]&lt;/span> &lt;span style="color:#2aa198">[SYSTEM]&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ^^^^^^^^^
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>e.g.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">add_subdirectory&lt;/span>(&lt;span style="color:#2aa198">src&lt;/span> &lt;span style="color:#2aa198">bin&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个操作是可以给单个文件设置不同的编译选项，而不是对 target 设置。控制的粒度就更细了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">if&lt;/span>(&lt;span style="color:#2aa198">MSVC&lt;/span> &lt;span style="color:#2aa198">AND&lt;/span> &lt;span style="color:#2aa198">NOT&lt;/span> &lt;span style="color:#2aa198">CLANG_CL&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b58900">set_source_files_properties&lt;/span>(&lt;span style="color:#2aa198">CompileCommands.cpp&lt;/span> &lt;span style="color:#2aa198">PROPERTIES&lt;/span> &lt;span style="color:#2aa198">COMPILE_FLAGS&lt;/span> &lt;span style="color:#2aa198">-wd4130&lt;/span>) &lt;span style="color:#586e75"># disables C4130: logical operation on address of string constant
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#b58900">endif&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CMake command line&lt;/p></description></item><item><title>CMake 并行编译</title><link>https://hxhue.github.io/posts/cli/cmake/CMake-%E5%B9%B6%E8%A1%8C%E7%BC%96%E8%AF%91/</link><pubDate>Tue, 30 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/cmake/CMake-%E5%B9%B6%E8%A1%8C%E7%BC%96%E8%AF%91/</guid><description>&lt;p>CMake 在 3.12 之后有 &lt;code>-j&lt;/code> 选项了，无参数则表示不受限。&lt;/p>
&lt;p>常用的两个 generators：&lt;/p>
&lt;p>Unix Makefiles 默认使用 1 个线程，支持 &lt;code>-j&lt;/code> 选项。&lt;/p>
&lt;p>Ninja 也支持 &lt;code>-j&lt;/code> 选项，如果不指定则使用默认线程数。可以用 &lt;code>ninja --help&lt;/code> 来查看。&lt;/p></description></item><item><title>限制 Docker 容器使用的 CPU</title><link>https://hxhue.github.io/posts/cli/docker/%E9%99%90%E5%88%B6-Docker-%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84-CPU/</link><pubDate>Tue, 30 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/%E9%99%90%E5%88%B6-Docker-%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84-CPU/</guid><description>&lt;p>在 &lt;code>docker run&lt;/code> 创建容器的时候用 &lt;code>--cpuset-cpus 0-3&lt;/code> 可以限制 CPU 在 0-3 这四个核心上，实测 &lt;code>nproc&lt;/code> 的结果已经改变了。&lt;/p>
&lt;p>在 &lt;code>docker build&lt;/code> 的时候也可以用同样的参数，比如 &lt;code>docker build . --cpuset-cpus 0-3&lt;/code>，这能够被正常识别，但是 &lt;code>nproc&lt;/code> 的结果没有改变，也不知道是否正常限制了。&lt;/p></description></item><item><title>括号的英文叫法</title><link>https://hxhue.github.io/posts/unsorted/%E6%8B%AC%E5%8F%B7%E7%9A%84%E8%8B%B1%E6%96%87%E5%8F%AB%E6%B3%95/</link><pubDate>Sat, 27 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/unsorted/%E6%8B%AC%E5%8F%B7%E7%9A%84%E8%8B%B1%E6%96%87%E5%8F%AB%E6%B3%95/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>(parentheses)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[brackets]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{braces}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;angled brackets&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LaTeX 中裁剪图片</title><link>https://hxhue.github.io/posts/latex/LaTeX-%E4%B8%AD%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/</link><pubDate>Thu, 25 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/latex/LaTeX-%E4%B8%AD%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">\begin&lt;/span>&lt;span style="color:#b58900">{&lt;/span>document&lt;span style="color:#b58900">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">% Answer: [trim={left bottom right top},clip]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">% Ex. 1: trim from left edge
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">\includegraphics&lt;/span>[trim={5cm 0 0 0},clip]&lt;span style="color:#b58900">{&lt;/span>example-image-a&lt;span style="color:#b58900">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">% Ex. 2: trim from right edge
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">\includegraphics&lt;/span>[trim={0 0 5cm 0},clip]&lt;span style="color:#b58900">{&lt;/span>example-image-a&lt;span style="color:#b58900">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">\end&lt;/span>&lt;span style="color:#b58900">{&lt;/span>document&lt;span style="color:#b58900">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>顺序是&lt;strong>左下右上&lt;/strong>。和 css 中的 margin 的指定是相反的顺序。（css 中是&lt;strong>上右下左&lt;/strong>。css 这个好记忆，就是初始位置在最上面，然后顺时针。）&lt;/p></description></item><item><title>bash 数字大小比较</title><link>https://hxhue.github.io/posts/cli/bash/bash-%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83/</link><pubDate>Wed, 24 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/bash-%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83/</guid><description>&lt;p>对于整数，可以用 &lt;code>[[]]&lt;/code> 和 &lt;code>(())&lt;/code> 来比较。&lt;/p>
&lt;p>对于浮点数，可以用 bc，但是 bc 不是每个环境都有。&lt;/p>
&lt;p>还有一种方法是 perl（如果装了 perl 但是没有装 bc）：&lt;code>perl -e &amp;quot;exit(1) if not $a &amp;gt; $b&amp;quot;&lt;/code>，这样可以用返回值标志是否成功。&lt;/p></description></item><item><title>bash 语法总结</title><link>https://hxhue.github.io/posts/cli/bash/bash-%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 21 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/bash-%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>&lt;h1 id="重新加载-path-中的可执行文件">重新加载 PATH 中的可执行文件
&lt;a class="header-anchor" href="#%e9%87%8d%e6%96%b0%e5%8a%a0%e8%bd%bd-path-%e4%b8%ad%e7%9a%84%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6">&lt;/a>
&lt;/h1>&lt;p>&lt;code>hash -r&lt;/code>：用于解决在 PATH 中加入可执行文件后找不到的情况。&lt;/p>
&lt;h1 id="用--匹配多级目录find-不能匹配双星号">用 &lt;code>**&lt;/code> 匹配多级目录（&lt;code>find&lt;/code> 不能匹配双星号）
&lt;a class="header-anchor" href="#%e7%94%a8--%e5%8c%b9%e9%85%8d%e5%a4%9a%e7%ba%a7%e7%9b%ae%e5%bd%95find-%e4%b8%8d%e8%83%bd%e5%8c%b9%e9%85%8d%e5%8f%8c%e6%98%9f%e5%8f%b7">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">shopt&lt;/span> -s globstar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">set&lt;/span> +o pipefail
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clang-tidy -p build/ ./&lt;span style="color:#719e07">{&lt;/span>src,include&lt;span style="color:#719e07">}&lt;/span>/**/*.&lt;span style="color:#719e07">{&lt;/span>h,hpp,cc,cpp,cu&lt;span style="color:#719e07">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一句是打开 &lt;code>**&lt;/code> 选项，第二句是忽略 pipefail（&lt;code>-o&lt;/code> 和 &lt;code>+o&lt;/code> 相反）不然第三句的 pipe 可能出错，第三句 &lt;code>2&amp;gt;/dev/null&lt;/code> 是忽略错误信息。&lt;/p></description></item><item><title>cp</title><link>https://hxhue.github.io/posts/cli/common/cp/</link><pubDate>Sun, 21 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/common/cp/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>SYNOPSIS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cp [OPTION]... [-T] SOURCE DEST
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cp [OPTION]... SOURCE... DIRECTORY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cp [OPTION]... -t DIRECTORY SOURCE...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实 cp 的选项比我想象中的要多很多。&lt;/p>
&lt;p>其他选项：&lt;/p>
&lt;ul>
&lt;li>创建硬链接（&lt;code>-l&lt;/code>）而不是拷贝。&lt;/li>
&lt;li>&lt;code>-L&lt;/code> 则会先解引用符号链接。&lt;/li>
&lt;li>&lt;code>-n&lt;/code> &lt;strong>不会覆盖旧文件&lt;/strong>。&lt;/li>
&lt;li>&lt;code>-a&lt;/code> 先归档再拷贝，也就是保留所有属性。&lt;/li>
&lt;li>&lt;code>-r&lt;/code> 递归拷贝（文件夹）。&lt;/li>
&lt;li>&lt;code>-u&lt;/code> &lt;strong>只拷贝时间上更新的文件&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>在 shell 中合并两个目录可以用 rsync&lt;/strong>：&lt;/p></description></item><item><title>ssh 配置</title><link>https://hxhue.github.io/posts/cli/ssh/ssh-%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 21 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/ssh/ssh-%E9%85%8D%E7%BD%AE/</guid><description>&lt;h1 id="样例">样例
&lt;a class="header-anchor" href="#%e6%a0%b7%e4%be%8b">&lt;/a>
&lt;/h1>&lt;p>Windows 下是 &lt;code>%userprofile%\.ssh\config&lt;/code>。Linux 下自己对应一下。&lt;/p>
&lt;ul>
&lt;li>含有 &lt;code>ForwardAgent&lt;/code> 选项表示启用代理转发，相当于在连接它时自动添加了参数 &lt;code>-A&lt;/code>。&lt;/li>
&lt;li>含有 &lt;code>ProxyJump&lt;/code> 表示先通过跳板机再连接到此主机，相当于在连接它时自动添加了参数 &lt;code>-J&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>样例：&lt;/p></description></item><item><title>在 Dockerfile 中合并两个目录</title><link>https://hxhue.github.io/posts/cli/docker/%E5%9C%A8-Dockerfile-%E4%B8%AD%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E7%9B%AE%E5%BD%95/</link><pubDate>Sun, 21 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/%E5%9C%A8-Dockerfile-%E4%B8%AD%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E7%9B%AE%E5%BD%95/</guid><description>&lt;p>dockerfile 中合并两个目录：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">COPY&lt;/span> folderA folderB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不要在文件夹后面加 &lt;code>/&lt;/code>。&lt;/p></description></item><item><title>📌Linux 主机检查 💻</title><link>https://hxhue.github.io/posts/systems/Linux/Linux-%E4%B8%BB%E6%9C%BA%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7%E5%92%8C%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</link><pubDate>Fri, 19 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/Linux-%E4%B8%BB%E6%9C%BA%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7%E5%92%8C%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</guid><description>&lt;h1 id="常用">常用
&lt;a class="header-anchor" href="#%e5%b8%b8%e7%94%a8">&lt;/a>
&lt;/h1>&lt;div style="overflow-x: auto">
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: center">功能&lt;/th>
 &lt;th style="text-align: center">子项目&lt;/th>
 &lt;th style="text-align: center">命令&lt;/th>
 &lt;th style="text-align: center">其他&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: center">CPU&lt;/td>
 &lt;td style="text-align: center">-&lt;/td>
 &lt;td style="text-align: center">&lt;code>htop&lt;/code>&lt;/td>
 &lt;td style="text-align: center">&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">GPU&lt;/td>
 &lt;td style="text-align: center">-&lt;/td>
 &lt;td style="text-align: center">&lt;code>nvidia-smi&lt;/code>&lt;/td>
 &lt;td style="text-align: center">还可以用 &lt;code>gpustat&lt;/code>/ &lt;code>nvitop&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">磁盘&lt;/td>
 &lt;td style="text-align: center">-&lt;/td>
 &lt;td style="text-align: center">&lt;code>iostat&lt;/code>&lt;/td>
 &lt;td style="text-align: center">新版本的 htop 同样可以监控磁盘 I/O（在 3.2.2 版本上测试可以，老版本 2.2.0 上实测不行）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">网络&lt;/td>
 &lt;td style="text-align: center">-&lt;/td>
 &lt;td style="text-align: center">&lt;/td>
 &lt;td style="text-align: center">&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">↑&lt;/td>
 &lt;td style="text-align: center">端口&lt;/td>
 &lt;td style="text-align: center">&lt;code>sudo netstat -pnltu&lt;/code>&lt;/td>
 &lt;td style="text-align: center">还可以用 &lt;code>sudo ss -nltup&lt;/code>，快得多（不加 &lt;code>sudo&lt;/code> 可能会少显示一些程序的端口号、名字等）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">↑&lt;/td>
 &lt;td style="text-align: center">不同连接的网速&lt;/td>
 &lt;td style="text-align: center">&lt;code>sudo iftop&lt;/code>&lt;/td>
 &lt;td style="text-align: center">&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">↑&lt;/td>
 &lt;td style="text-align: center">具体接口的不同连接的网速&lt;/td>
 &lt;td style="text-align: center">&lt;code>sudo tcptrack -i eno1&lt;/code>&lt;/td>
 &lt;td style="text-align: center">&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">↑&lt;/td>
 &lt;td style="text-align: center">具体端口的网络活动&lt;/td>
 &lt;td style="text-align: center">&lt;code>tcpdump -i any port 53210&lt;/code>&lt;/td>
 &lt;td style="text-align: center">&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;/div>&lt;p>注意 docker 容器内的端口号和容器外的端口号是不同的。&lt;/p></description></item><item><title>ssh 代理转发，让服务器上外网</title><link>https://hxhue.github.io/posts/cli/ssh/ssh-%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%A4%96%E7%BD%91/</link><pubDate>Fri, 19 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/ssh/ssh-%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%A4%96%E7%BD%91/</guid><description>&lt;p>由于是自己的电脑充当代理，所以需要用 &lt;code>-R&lt;/code> 选项。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ssh -N -n -R 0.0.0.0:11625:127.0.0.1:12341 服务器
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是将远程的一个端口连到本地的端口。&lt;code>-N&lt;/code> 表示不要执行命令，仅仅转发端口。&lt;code>-n&lt;/code> 表示将 stdin 重定向到 /dev/null。&lt;/p></description></item><item><title>VS Code 上写 LaTeX</title><link>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E4%B8%8A%E5%86%99-LaTeX/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E4%B8%8A%E5%86%99-LaTeX/</guid><description>&lt;h1 id="消除烦人的错误提示">消除烦人的错误提示
&lt;a class="header-anchor" href="#%e6%b6%88%e9%99%a4%e7%83%a6%e4%ba%ba%e7%9a%84%e9%94%99%e8%af%af%e6%8f%90%e7%a4%ba">&lt;/a>
&lt;/h1>&lt;p>如果是自动保存，则会有烦人的错误提示。即便是打开勿扰模式也会提示错误消息。&lt;/p>
&lt;p>需要在设置中关闭 LaTeX 相关的消息。&lt;/p>
&lt;h1 id="无法编译中文">无法编译中文
&lt;a class="header-anchor" href="#%e6%97%a0%e6%b3%95%e7%bc%96%e8%af%91%e4%b8%ad%e6%96%87">&lt;/a>
&lt;/h1>&lt;p>在 &lt;code>&amp;quot;latex-workshop.latex.tools&amp;quot;&lt;/code> 中改一个参数。&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/4f424a2d52e9950ffe40178fd8a9725f.webp">&lt;/p>
&lt;p>每次保存之后不自动使用中文：在 VS Code 的设置中加入这一行并重启。&lt;/p></description></item><item><title>VS Code 终端快捷键冲突</title><link>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E7%BB%88%E7%AB%AF%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%86%B2%E7%AA%81/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E7%BB%88%E7%AB%AF%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%86%B2%E7%AA%81/</guid><description>&lt;h1 id="ctrl--e-不能传进-shell">ctrl + e 不能传进 shell
&lt;a class="header-anchor" href="#ctrl--e-%e4%b8%8d%e8%83%bd%e4%bc%a0%e8%bf%9b-shell">&lt;/a>
&lt;/h1>&lt;p>在自定义的快捷键配置中给 ctrl+e 删掉默认的 command。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 将键绑定放在此文件中以覆盖默认值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#268bd2">&amp;#34;key&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;ctrl+e&amp;#34;&lt;/span>, &lt;span style="color:#268bd2">&amp;#34;command&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;-workbench.action.quickOpen&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>VS Code 终端字符间距过宽</title><link>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E7%BB%88%E7%AB%AF%E5%AD%97%E7%AC%A6%E9%97%B4%E8%B7%9D%E8%BF%87%E5%AE%BD/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E7%BB%88%E7%AB%AF%E5%AD%97%E7%AC%A6%E9%97%B4%E8%B7%9D%E8%BF%87%E5%AE%BD/</guid><description>&lt;h1 id="终端字体间距过宽">终端字体间距过宽
&lt;a class="header-anchor" href="#%e7%bb%88%e7%ab%af%e5%ad%97%e4%bd%93%e9%97%b4%e8%b7%9d%e8%bf%87%e5%ae%bd">&lt;/a>
&lt;/h1>&lt;p>有时候恢复终端就会出现这种情况（比如显示屏分辨率变化）。暂且尝试的方法是&lt;strong>显式设置终端字体&lt;/strong>（而不是把终端字体留空，让其隐式使用编辑器字体）。感觉还是没有用！&lt;/p></description></item><item><title>VS Code + CMake: Allow building in different directories per build type</title><link>https://hxhue.github.io/posts/developer/vscode/VS-Code-+-CMakeAllow-building-in-different-directories-per-build-type/</link><pubDate>Wed, 17 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/VS-Code-+-CMakeAllow-building-in-different-directories-per-build-type/</guid><description>&lt;p>&lt;a href="https://github.com/microsoft/vscode-cmake-tools/issues/151" title="https://github.com/microsoft/vscode-cmake-tools/issues/151" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://github.com/microsoft/vscode-cmake-tools/issues/151&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">&amp;#34;cmake.buildDirectory&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;${workspaceRoot}/build/${buildType}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>CMake execute_process</title><link>https://hxhue.github.io/posts/cli/cmake/CMake-execute_process/</link><pubDate>Tue, 16 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/cmake/CMake-execute_process/</guid><description>&lt;p>和 &lt;code>add_custom_command&lt;/code> / &lt;code>add_custom_target&lt;/code> 不同，这个是在配置时就运行，但是一定要注意给对工作路径，否则运行结果出乎意料（或者以为没有运行）。&lt;/p>
&lt;p>示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">execute_process&lt;/span>(&lt;span style="color:#2aa198">COMMAND&lt;/span> &lt;span style="color:#2aa198">./utils/pre-commit-cmake.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">WORKING_DIRECTORY&lt;/span> &lt;span style="color:#719e07">${&lt;/span>&lt;span style="color:#268bd2">CMAKE_CURRENT_SOURCE_DIR&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>pybind11 CMake 不能编译和运行</title><link>https://hxhue.github.io/posts/cli/cmake/pybind11-CMake-%E4%B8%8D%E8%83%BD%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C/</link><pubDate>Sat, 13 Jan 2024 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/cmake/pybind11-CMake-%E4%B8%8D%E8%83%BD%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C/</guid><description>&lt;p>主要问题：加了 &lt;code>add_subdirectory&lt;/code> 但是仍然无法找到头文件。&lt;/p>
&lt;p>解决方案：先加上 &lt;code>find_package(Python3 COMPONENTS Interpreter Development)&lt;/code> 再添加 pybind11 子文件夹。不然 pybind11 找到的 python 版本可能不对。&lt;/p></description></item><item><title>git 仓库中，对不再存在的文件的体积进行统计</title><link>https://hxhue.github.io/posts/cli/git/git-%E4%BB%93%E5%BA%93%E4%B8%AD%E5%AF%B9%E4%B8%8D%E5%86%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%93%E7%A7%AF%E8%BF%9B%E8%A1%8C%E7%BB%9F%E8%AE%A1/</link><pubDate>Fri, 29 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/git/git-%E4%BB%93%E5%BA%93%E4%B8%AD%E5%AF%B9%E4%B8%8D%E5%86%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%93%E7%A7%AF%E8%BF%9B%E8%A1%8C%E7%BB%9F%E8%AE%A1/</guid><description>&lt;p>首先必须处在仓库中，然后用 &lt;a href="https://stackoverflow.com/a/42544963/" title="https://stackoverflow.com/a/42544963/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/42544963/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 提供的方法提取出每个文件的大小，最后用 perl 计算总的体积。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git rev-list --objects --all |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> git cat-file --batch-check&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#39;%(objecttype) %(objectname) %(objectsize) %(rest)&amp;#39;&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sed -n &lt;span style="color:#2aa198">&amp;#39;s/^blob //p&amp;#39;&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> grep -vF --file&lt;span style="color:#719e07">=&lt;/span>&amp;lt;&lt;span style="color:#719e07">(&lt;/span>git ls-tree -r HEAD | awk &lt;span style="color:#2aa198">&amp;#39;{print $3}&amp;#39;&lt;/span>&lt;span style="color:#719e07">)&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sort --numeric-sort --key&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">2&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cut -c 1-12,41- |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">$(&lt;/span>&lt;span style="color:#b58900">command&lt;/span> -v gnumfmt &lt;span style="color:#719e07">||&lt;/span> &lt;span style="color:#b58900">echo&lt;/span> numfmt&lt;span style="color:#719e07">)&lt;/span> --field&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">2&lt;/span> --to&lt;span style="color:#719e07">=&lt;/span>iec-i --suffix&lt;span style="color:#719e07">=&lt;/span>B --padding&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">7&lt;/span> --round&lt;span style="color:#719e07">=&lt;/span>nearest &amp;gt; legacy.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>perl -ne &lt;span style="color:#2aa198">&amp;#39;BEGIN{my $sum=0} s/.* (.*) .*/$1/g;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">s/B//g;s/Ki/*1024/g;s/Mi/*1024*1024/g;s/Gi/*1024*1024*1024/g;$sum+=eval($_);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">END{printf &amp;#34;%.1f MiB\n&amp;#34;, $sum/1024/1024}&amp;#39;&lt;/span> legacy.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>把上面的 &lt;code>objectsize&lt;/code> 换成 &lt;code>objectsize:disk&lt;/code> 就能看到压缩后的文件总体积，在我们仓库中大概是 2216.4 MiB，而压缩前大概是 7304.1 MiB。&lt;/p></description></item><item><title>Linux 上字体相关的环境变量</title><link>https://hxhue.github.io/posts/systems/Linux/Linux-%E4%B8%8A%E5%AD%97%E4%BD%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link><pubDate>Wed, 20 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/Linux-%E4%B8%8A%E5%AD%97%E4%BD%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid><description>&lt;p>&lt;a href="https://www.gnu.org/software/gettext/manual/html_node/Locale-Environment-Variables.html#Locale-Environment-Variables" title="https://www.gnu.org/software/gettext/manual/html_node/Locale-Environment-Variables.html#Locale-Environment-Variables" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://www.gnu.org/software/gettext/manual/html_node/Locale-Environment-Variables.html#Locale-Environment-Variables&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>&lt;code>gettext&lt;/code> 的优先级：&lt;/p>
&lt;ul>
&lt;li>&lt;code>LANGUAGE&lt;/code>&lt;/li>
&lt;li>&lt;code>LC_ALL&lt;/code>&lt;/li>
&lt;li>&lt;code>LC_xxx&lt;/code>, according to selected locale category: &lt;code>LC_CTYPE&lt;/code>, &lt;code>LC_NUMERIC&lt;/code>, &lt;code>LC_TIME&lt;/code>, &lt;code>LC_COLLATE&lt;/code>, &lt;code>LC_MONETARY&lt;/code>, &lt;code>LC_MESSAGES&lt;/code>, &amp;hellip;&lt;/li>
&lt;li>&lt;code>LANG&lt;/code> 算是一个 fallback&lt;/li>
&lt;/ul>
&lt;blockquote>
 &lt;p>&lt;code>$LANGUAGE&lt;/code> is not part of the C locales, but specific to GNU gettext. If set it is given precedence over anything else.&lt;/p>
&lt;/blockquote>&lt;p>所以设置 &lt;code>LANGUAGE&lt;/code> 不通用，设置 &lt;code>LC_ALL&lt;/code> 高优先级，如果系统里面什么都没有设置，&lt;code>LANG&lt;/code> 就足够了。&lt;/p></description></item><item><title>inttypes.h</title><link>https://hxhue.github.io/posts/programming/cpp/inttypes.h/</link><pubDate>Sun, 17 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/inttypes.h/</guid><description>&lt;p>包含了 &lt;code>stdint.h&lt;/code>，同时还有一些格式字符串宏帮助写可移植的 &lt;code>scanf&lt;/code>/&lt;code>printf&lt;/code> 代码。&lt;/p></description></item><item><title>zsh 中新命令不参与插件补全</title><link>https://hxhue.github.io/posts/cli/zsh/zsh-%E4%B8%AD%E6%96%B0%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%82%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A1%A5%E5%85%A8/</link><pubDate>Sun, 17 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/zsh/zsh-%E4%B8%AD%E6%96%B0%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%82%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A1%A5%E5%85%A8/</guid><description>&lt;p>zsh 在 PATH 路径中添加的新命令可以使用 zsh-syntax-highlighting，但是不能用 tab 补全。使用 &lt;code>rehash&lt;/code> 命令让 zsh 重新检查命令，就能补全了。&lt;/p>
&lt;blockquote>
 &lt;p>如果是 bash，则要用 hash -r。&lt;/p></description></item><item><title>切换默认 shell</title><link>https://hxhue.github.io/posts/systems/Linux/%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4-shell/</link><pubDate>Sun, 17 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4-shell/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo usermod -s /bin/bash &lt;span style="color:#719e07">$(&lt;/span>whoami&lt;span style="color:#719e07">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>chsh&lt;/code> 也有同样的功能。两者都是改变了 /etc/passwd 的记录项达到切换登陆 shell 的。&lt;/p>
&lt;p>注意，如果用 &lt;code>chsh&lt;/code>，必须先切换到要更改 shell 的用户，比如给当前用户切换 shell 则是：&lt;/p></description></item><item><title>bash 中的 BASH_SOURCE</title><link>https://hxhue.github.io/posts/cli/bash/bash-%E4%B8%AD%E7%9A%84-BASH_SOURCE/</link><pubDate>Mon, 11 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/bash-%E4%B8%AD%E7%9A%84-BASH_SOURCE/</guid><description>&lt;p>这个变量表示 bash 真正的入口程序。这个变量的必要性体现在 source 某个 bash 脚本的时候 &lt;code>$0&lt;/code> 不能准确反映入口程序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>&lt;span style="color:#b58900">echo&lt;/span> &lt;span style="color:#2aa198">&amp;#34;[&lt;/span>&lt;span style="color:#268bd2">$0&lt;/span>&lt;span style="color:#2aa198">] vs. [&lt;/span>&lt;span style="color:#2aa198">${&lt;/span>&lt;span style="color:#268bd2">BASH_SOURCE&lt;/span>[0]&lt;span style="color:#2aa198">}&lt;/span>&lt;span style="color:#2aa198">]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ bash ./foo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">[&lt;/span>./foo&lt;span style="color:#719e07">]&lt;/span> vs. &lt;span style="color:#719e07">[&lt;/span>./foo&lt;span style="color:#719e07">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ./foo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">[&lt;/span>./foo&lt;span style="color:#719e07">]&lt;/span> vs. &lt;span style="color:#719e07">[&lt;/span>./foo&lt;span style="color:#719e07">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ . ./foo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">[&lt;/span>bash&lt;span style="color:#719e07">]&lt;/span> vs. &lt;span style="color:#719e07">[&lt;/span>./foo&lt;span style="color:#719e07">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>参考 &lt;a href="https://stackoverflow.com/a/35006505/" title="https://stackoverflow.com/a/35006505/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/35006505/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p></description></item><item><title>gitlab-runner 的创建</title><link>https://hxhue.github.io/posts/systems/Linux/gitlab/gitlab-runner-%E7%9A%84%E5%88%9B%E5%BB%BA/</link><pubDate>Mon, 11 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/gitlab/gitlab-runner-%E7%9A%84%E5%88%9B%E5%BB%BA/</guid><description>&lt;div class="markdown-alert markdown-alert-important">
 &lt;p class="markdown-alert-title">&lt;svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" width="16" height="16"
 aria-hidden="true">
 &lt;path
 d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z">
 &lt;/path>
 &lt;/svg>Important&lt;/p></description></item><item><title>gitlab-jh 中一些和 external_url 相关的问题</title><link>https://hxhue.github.io/posts/systems/Linux/gitlab/gitlab-jh-%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%92%8C-external_url-%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 08 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/gitlab/gitlab-jh-%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%92%8C-external_url-%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;div class="markdown-alert markdown-alert-important">
 &lt;p class="markdown-alert-title">&lt;svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" width="16" height="16"
 aria-hidden="true">
 &lt;path
 d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z">
 &lt;/path>
 &lt;/svg>Important&lt;/p></description></item><item><title>Gitlab pipeline editor URL 的问题</title><link>https://hxhue.github.io/posts/systems/Linux/gitlab/Gitlab-pipeline-editor-URL-%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 03 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/gitlab/Gitlab-pipeline-editor-URL-%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;div class="markdown-alert markdown-alert-important">
 &lt;p class="markdown-alert-title">&lt;svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" width="16" height="16"
 aria-hidden="true">
 &lt;path
 d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z">
 &lt;/path>
 &lt;/svg>Important&lt;/p></description></item><item><title>bash 文件描述符</title><link>https://hxhue.github.io/posts/cli/bash/bash-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</link><pubDate>Sat, 02 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/bash-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</guid><description>&lt;p>例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#b58900">echo&lt;/span> A &amp;gt;&amp;amp;&lt;span style="color:#2aa198">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-bash: 3: Bad file descriptor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#b58900">echo&lt;/span> A 3&amp;gt;&amp;amp;&lt;span style="color:#2aa198">2&lt;/span> &amp;gt;&amp;amp;3|grep &lt;span style="color:#2aa198">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>A
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一行输出给描述符 3 相关的文件，但是没有这个文件，所以出错。&lt;/p>
&lt;p>第二行把描述符 3 分配给了原先 2 的文件，然后又将输出导入到描述符 3 对应的文件中，也就是将结果输出到 stderr 中，所以 grep 8 不能拦截 echo 的输出（可以看到 A 被打印出来了）。&lt;/p></description></item><item><title>Docker 配置代理</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</guid><description>&lt;h1 id="docker-pull">&lt;code>docker pull&lt;/code>
&lt;a class="header-anchor" href="#docker-pull">&lt;/a>
&lt;/h1>&lt;p>&lt;code>docker pull&lt;/code> 不会读取 &lt;code>http_proxy&lt;/code> 环境变量，因为拉取请求是发给守护进程的（不清楚守护进程是否是经典的 listen-fork 模式），环境变量早就在启动时读入，需要专门配置 docker 守护进程并让它重新加载配置。可以参考： &lt;a href="https://stackoverflow.com/a/71036185" title="https://stackoverflow.com/a/71036185" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/71036185&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p></description></item><item><title>Docker 按容器 A 的启动参数创建新容器 B</title><link>https://hxhue.github.io/posts/cli/docker/Docker-%E6%8C%89%E5%AE%B9%E5%99%A8-A-%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E5%88%9B%E5%BB%BA%E6%96%B0%E5%AE%B9%E5%99%A8-B/</link><pubDate>Thu, 30 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-%E6%8C%89%E5%AE%B9%E5%99%A8-A-%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E5%88%9B%E5%BB%BA%E6%96%B0%E5%AE%B9%E5%99%A8-B/</guid><description>&lt;p>&lt;a href="https://stackoverflow.com/questions/32758793/how-to-show-the-run-command-of-a-docker-container" title="How to show the run command of a docker container - Stack Overflow" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >How to show the run command of a docker container - Stack Overflow&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker inspect --format &lt;span style="color:#2aa198">&amp;#34;&lt;/span>&lt;span style="color:#719e07">$(&lt;/span>curl -s &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> https://gist.githubusercontent.com/efrecon/8ce9c75d518b6eb863f667442d7bc679/raw/run.tpl&lt;span style="color:#719e07">)&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> &lt;span style="color:#719e07">{&lt;/span>your_container&lt;span style="color:#719e07">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>得到的结果样例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --name &lt;span style="color:#2aa198">&amp;#34;/gitlab-runner-4&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --runtime &lt;span style="color:#2aa198">&amp;#34;runc&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --volume &lt;span style="color:#2aa198">&amp;#34;/srv/gitlab-runner/config:/etc/gitlab-runner&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --volume &lt;span style="color:#2aa198">&amp;#34;/var/run/docker.sock:/var/run/docker.sock&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --log-driver &lt;span style="color:#2aa198">&amp;#34;json-file&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --restart &lt;span style="color:#2aa198">&amp;#34;always&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --network &lt;span style="color:#2aa198">&amp;#34;bridge&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --env &lt;span style="color:#2aa198">&amp;#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --detach &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> &lt;span style="color:#2aa198">&amp;#34;gitlab/gitlab-runner:latest&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> &lt;span style="color:#2aa198">&amp;#34;run&amp;#34;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;--user=gitlab-runner&amp;#34;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;--working-directory=/home/gitlab-runner&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还有一种方法是使用 &lt;a href="https://github.com/lavie/runlike" title="https://github.com/lavie/runlike" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://github.com/lavie/runlike&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 提供的 pip 包 &lt;code>runlike&lt;/code>。使用起来也比较方便，但是输出的结果里面有些参数还得再检查和调整一下。&lt;/p></description></item><item><title>gitlab-jh 配置 CI 的问题</title><link>https://hxhue.github.io/posts/systems/Linux/gitlab/gitlab-jh-%E9%85%8D%E7%BD%AE-CI-%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Thu, 30 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/gitlab/gitlab-jh-%E9%85%8D%E7%BD%AE-CI-%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;div class="markdown-alert markdown-alert-important">
 &lt;p class="markdown-alert-title">&lt;svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" width="16" height="16"
 aria-hidden="true">
 &lt;path
 d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z">
 &lt;/path>
 &lt;/svg>Important&lt;/p></description></item><item><title>Windows cmd 转义</title><link>https://hxhue.github.io/posts/systems/Windows/Windows-cmd-%E8%BD%AC%E4%B9%89/</link><pubDate>Wed, 22 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Windows-cmd-%E8%BD%AC%E4%B9%89/</guid><description>&lt;p>cmd 对 &lt;strong>双引号中的 ^&lt;/strong> 不会转义。由于单引号不是 cmd 认可的引用方式，单引号中的 ^ 会转义。&lt;/p>
&lt;p>&lt;strong>cmd 的 echo 命令并不会去掉双引号参数的双引号&lt;/strong>。例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>C:&lt;span style="color:#cb4b16">\U&lt;/span>sers&lt;span style="color:#cb4b16">\x&lt;/span>x&amp;gt;echo &lt;span style="color:#2aa198">&amp;#34;6&amp;#34;&lt;/span> | C:&lt;span style="color:#cb4b16">\U&lt;/span>sers&lt;span style="color:#cb4b16">\x&lt;/span>x&lt;span style="color:#cb4b16">\s&lt;/span>coop&lt;span style="color:#cb4b16">\s&lt;/span>hims&lt;span style="color:#cb4b16">\b&lt;/span>ash.exe -c &lt;span style="color:#2aa198">&amp;#34;cat&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">&amp;#34;6&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其他命令貌似会去掉双引号，比如 cd 和 set。外置命令就更不用说了，写 git show &amp;ldquo;HEAD&amp;rdquo; 能够正常运行，可能是因为 cmd 为非内置命令去掉了双引号。&lt;/p></description></item><item><title>VS Code 友好的 pre-commit hook</title><link>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E5%8F%8B%E5%A5%BD%E7%9A%84-pre-commit-hook/</link><pubDate>Mon, 20 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E5%8F%8B%E5%A5%BD%E7%9A%84-pre-commit-hook/</guid><description>&lt;p>&lt;strong>问题&lt;/strong>：加入 pre-commit 之后，在 VS Code 的侧边栏 git 模块中提交代码看似卡住，看不到 pre-commit 的输出，也无法和 pre-commit 交互。&lt;/p>
&lt;p>将下面的 &lt;code>entry_point&lt;/code> 函数替换成要执行的流程，然后作为 .git/hooks/pre-commit 的内容即可。其主要作用是判断当前是否在 VS Code 环境中，如果是，则将输出写到一个临时文件中，然后再用 VS Code 打开这个文件以观察输出。&lt;strong>解决了看不到输出、进度的问题，但是还解决不了输入的问题&lt;/strong>。&lt;/p></description></item><item><title>rsync</title><link>https://hxhue.github.io/posts/cli/common/rsync/</link><pubDate>Sun, 19 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/common/rsync/</guid><description>&lt;p>和 scp 相比可以断点续传。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ rsync -avz -e ssh -r --info&lt;span style="color:#719e07">=&lt;/span>progress2 --info&lt;span style="color:#719e07">=&lt;/span>name0 coco/images/train2014.zip xxserver:/data/xxx/data/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2024年2月8日：这里已经是 zip 了，感觉没必要压缩。&lt;/p></description></item><item><title>在 VS Code 中使用 clangd</title><link>https://hxhue.github.io/posts/developer/vscode/%E5%9C%A8-VS-Code-%E4%B8%AD%E4%BD%BF%E7%94%A8-clangd/</link><pubDate>Sun, 19 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/%E5%9C%A8-VS-Code-%E4%B8%AD%E4%BD%BF%E7%94%A8-clangd/</guid><description>&lt;h1 id="设置-vs-code-clangd-检查的语言标准为-c17">设置 VS Code clangd 检查的语言标准为 C++17
&lt;a class="header-anchor" href="#%e8%ae%be%e7%bd%ae-vs-code-clangd-%e6%a3%80%e6%9f%a5%e7%9a%84%e8%af%ad%e8%a8%80%e6%a0%87%e5%87%86%e4%b8%ba-c17">&lt;/a>
&lt;/h1>&lt;p>






&lt;img src="https://hxhue.github.io/assets/75a1c84faccb284ac8b51a1f07d3fc57.webp">&lt;/p>
&lt;p>Set &lt;code>-std&lt;/code> in the &lt;code>.yaml&lt;/code> file and then reload window of VS Code.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">CompileFlags&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">Add&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --std=c++17,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -Wno-documentation,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -Wno-missing-prototypes,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">Diagnostics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">ClangTidy&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">Add&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> performance-*,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bugprone-*,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modernize-*,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clang-analyzer-*,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> readability-identifier*,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">CheckOptions&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">readability-identifier-naming.VariableCase&lt;/span>: camelCase
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="clangd-找不到头文件">Clangd 找不到头文件
&lt;a class="header-anchor" href="#clangd-%e6%89%be%e4%b8%8d%e5%88%b0%e5%a4%b4%e6%96%87%e4%bb%b6">&lt;/a>
&lt;/h1>&lt;p>macOS 自带的 &lt;code>/usr/local/bin&lt;/code> 中的 clang 不能提供查询路径。要么把绝对路径改成 &lt;code>PATH&lt;/code> 中的命令，要么添加 &lt;code>&amp;quot;--query-driver=/usr/bin/clang++&amp;quot;&lt;/code> 在参数中。&lt;/p></description></item><item><title>EDITOR, PAGER, BROWSER</title><link>https://hxhue.github.io/posts/systems/Linux/EDITOR-PAGER-BROWSER/</link><pubDate>Sat, 18 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/EDITOR-PAGER-BROWSER/</guid><description>&lt;p>&lt;a href="https://unix.stackexchange.com/questions/213367/where-do-editor-pager-browser-environment-variables-come-from" title="Where do EDITOR, PAGER, BROWSER environment variables come from? - Unix &amp;amp; Linux Stack Exchange" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Where do EDITOR, PAGER, BROWSER environment variables come from? - Unix &amp;amp; Linux Stack Exchange&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>EDITOR, PAGER, BROWSER 这三个环境变量控制 linux 中很多工具展示输出的方式。还有 &lt;code>SUDO_EDITOR&lt;/code> 可以设置 sudoedit 使用的编辑器。&lt;/p></description></item><item><title>Linux 创建新用户</title><link>https://hxhue.github.io/posts/systems/Linux/Linux-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7/</link><pubDate>Sat, 18 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/Linux-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7/</guid><description>&lt;p>adduser 有交互过程，比 useradd 更友好。事实上，adduser 是 useradd 的 wrapper。&lt;/p></description></item><item><title>C 语言算术运算的类型提升</title><link>https://hxhue.github.io/posts/programming/cpp/C-%E8%AF%AD%E8%A8%80%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87/</link><pubDate>Thu, 16 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C-%E8%AF%AD%E8%A8%80%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87/</guid><description>&lt;p>&lt;a href="https://stackoverflow.com/a/5563131/" title="https://stackoverflow.com/a/5563131/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/5563131/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">if&lt;/span>&lt;span style="color:#719e07">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">double&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">double&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">double&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">double&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">float&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">float&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>either is &lt;span style="color:#dc322f">int&lt;/span> other is promoted &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Otherwise:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>both operands are promoted to &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>git restore</title><link>https://hxhue.github.io/posts/cli/git/git-restore/</link><pubDate>Wed, 15 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/git/git-restore/</guid><description>&lt;p>在没有 &lt;code>--source&lt;/code> 选项时，有 &lt;code>--staged&lt;/code> 则默认使用 HEAD 来恢复，如果没有则默认使用 index。此时：&lt;/p>
&lt;ul>
&lt;li>&lt;code>git restore&lt;/code> 相当于 &lt;code>git restore --worktree&lt;/code>。&lt;/li>
&lt;li>&lt;code>git restore --staged&lt;/code> 用 HEAD 的信息来恢复 index，不会改动 working tree。&lt;/li>
&lt;li>&lt;code>git restore --worktree&lt;/code> 用 index 的信息来恢复 working tree。&lt;/li>
&lt;li>&lt;code>git restore --worktree --staged&lt;/code> 同时恢复 working tree 和 index。&lt;code>git restore --source HEAD --worktree --staged&lt;/code> 相当于 &lt;code>git reset --hard&lt;/code> 对于单个文件的效果。（虽然按照官方的描述来说是默认 source 为 HEAD，但是在 git 2.25.1 中实测这种情况下的默认 source 是 index）&lt;/li>
&lt;/ul>
&lt;blockquote>
 &lt;p>&lt;code>-W&lt;/code> &lt;a href="https://git-scm.com/docs/git-restore#Documentation/git-restore.txt---worktree" title="link1" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >link1&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>; &lt;a href="https://git-scm.com/docs/git-restore#Documentation/git-restore.txt--S" title="link2" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >link2&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> &lt;a href="https://git-scm.com/docs/git-restore#Documentation/git-restore.txt---staged" title="link3" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >link3&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>
Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying &lt;code>--staged&lt;/code> will only restore the index. Specifying both restores both.&lt;/p></description></item><item><title>inline namespace</title><link>https://hxhue.github.io/posts/programming/cpp/inline-namespace/</link><pubDate>Sun, 12 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/inline-namespace/</guid><description>&lt;p>&lt;a href="https://en.cppreference.com/w/cpp/language/namespace" title="Namespaces - cppreference.com" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Namespaces - cppreference.com&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>inline namespace 既本身存在，又将所有内容引入外围（enclosing）名字空间中。相当于名字空间后面加了一句：&lt;code>using namespace X;&lt;/code>&lt;/p>
&lt;p>例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">inline&lt;/span> &lt;span style="color:#719e07">namespace&lt;/span> A {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">using&lt;/span> Int &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#dc322f">int&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A&lt;span style="color:#719e07">::&lt;/span>Int a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Int b; &lt;span style="color:#586e75">// 也能成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>描述颜色的术语：色相、饱和度、亮度</title><link>https://hxhue.github.io/posts/unsorted/%E6%8F%8F%E8%BF%B0%E9%A2%9C%E8%89%B2%E7%9A%84%E6%9C%AF%E8%AF%AD%E8%89%B2%E7%9B%B8%E9%A5%B1%E5%92%8C%E5%BA%A6%E4%BA%AE%E5%BA%A6/</link><pubDate>Sun, 12 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/unsorted/%E6%8F%8F%E8%BF%B0%E9%A2%9C%E8%89%B2%E7%9A%84%E6%9C%AF%E8%AF%AD%E8%89%B2%E7%9B%B8%E9%A5%B1%E5%92%8C%E5%BA%A6%E4%BA%AE%E5%BA%A6/</guid><description>&lt;p>






&lt;img src="https://hxhue.github.io/assets/a38f57a7090157b88a31966c509f46fb.webp">&lt;/p>
&lt;p>这三个单词的含义分别是色相、饱和度、亮度。&lt;/p>
&lt;p>所有的粉色都是洋红色，所有的洋红色都是紫色。&lt;a href="https://english.stackexchange.com/questions/226940/what-is-pink-and-what-is-magenta" title="word choice - What is &amp;lsquo;pink&amp;rsquo; and what is &amp;lsquo;magenta&amp;rsquo;? - English Language &amp;amp; Usage Stack Exchange" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >word choice - What is &amp;lsquo;pink&amp;rsquo; and what is &amp;lsquo;magenta&amp;rsquo;? - English Language &amp;amp; Usage Stack Exchange&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p></description></item><item><title>bash 下不用转义符打印红色字符串</title><link>https://hxhue.github.io/posts/cli/bash/bash-%E4%B8%8B%E4%B8%8D%E7%94%A8%E8%BD%AC%E4%B9%89%E7%AC%A6%E6%89%93%E5%8D%B0%E7%BA%A2%E8%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Sat, 11 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/bash-%E4%B8%8B%E4%B8%8D%E7%94%A8%E8%BD%AC%E4%B9%89%E7%AC%A6%E6%89%93%E5%8D%B0%E7%BA%A2%E8%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>&lt;p>给一个必定匹配的模式让 grep 打印所有行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>... | grep -E &lt;span style="color:#2aa198">&amp;#39;(^|pattern)&amp;#39;&lt;/span> --color&lt;span style="color:#719e07">=&lt;/span>always
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Python re.match</title><link>https://hxhue.github.io/posts/programming/python/Python-re.match/</link><pubDate>Sat, 11 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/Python-re.match/</guid><description>&lt;p>Python 的正则表达式函数基本都是从第一个字符开始匹配的。不像 bash 和 JS 是任意位置匹配都行。所以要适当加上 &lt;code>.*&lt;/code>。&lt;/p></description></item><item><title>Windows 下用 CMD 或 powershell 一键重启显卡驱动</title><link>https://hxhue.github.io/posts/systems/Windows/Windows-%E4%B8%8B%E7%94%A8-CMD-%E6%88%96-powershell-%E4%B8%80%E9%94%AE%E9%87%8D%E5%90%AF%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Windows-%E4%B8%8B%E7%94%A8-CMD-%E6%88%96-powershell-%E4%B8%80%E9%94%AE%E9%87%8D%E5%90%AF%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</guid><description>&lt;p>主要是双显卡笔记本切换显示屏后，部分应用没有切换图形显示卡，导致未活跃的显卡时不时被唤醒，而每次唤醒会有一秒的卡顿。&lt;/p>
&lt;p>创建 bat 文件（&lt;strong>其中硬件驱动的实例路径需要在设备管理器上查看后根据实际修改&lt;/strong>）：&lt;/p></description></item><item><title>CUDA 调试</title><link>https://hxhue.github.io/posts/programming/cuda/CUDA-%E8%B0%83%E8%AF%95/</link><pubDate>Mon, 06 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cuda/CUDA-%E8%B0%83%E8%AF%95/</guid><description>&lt;p>cuda-gdb 是 cuda 的调试工具，执行非常慢。&lt;/p>
&lt;p>如果需要符号信息，nvcc 的编译选项需要加上 &lt;code>-g -G&lt;/code>，其中 &lt;code>-g&lt;/code> 是给 host 代码添加符号信息，而 &lt;code>-G&lt;/code> 是给 device 侧代码添加符号信息。&lt;/p></description></item><item><title>VS Code 远程主机插件不能下载</title><link>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E6%8F%92%E4%BB%B6%E4%B8%8D%E8%83%BD%E4%B8%8B%E8%BD%BD/</link><pubDate>Fri, 03 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/VS-Code-%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E6%8F%92%E4%BB%B6%E4%B8%8D%E8%83%BD%E4%B8%8B%E8%BD%BD/</guid><description>&lt;p>提示 XHR failed。&lt;/p>
&lt;p>找到插件的网页下载 Linux 版本，然后从文件资源管理器拖动文件到工作目录，拷贝文件后运行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>code --install-extension ./doxdocgen-1.4.0.vsix
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可能是本机的代理设置和远程主机的代理设置冲突了，可以修改远程主机的 &lt;code>&amp;quot;http.proxy&amp;quot;&lt;/code> 为空：&lt;/p></description></item><item><title>用 std::variant 的坑</title><link>https://hxhue.github.io/posts/programming/cpp/%E7%94%A8-variant-%E7%9A%84%E5%9D%91/</link><pubDate>Fri, 03 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E7%94%A8-variant-%E7%9A%84%E5%9D%91/</guid><description>&lt;h1 id="decltype-推导可能带有--属性">decltype 推导可能带有 &lt;code>&amp;amp;&lt;/code> 属性
&lt;a class="header-anchor" href="#decltype-%e6%8e%a8%e5%af%bc%e5%8f%af%e8%83%bd%e5%b8%a6%e6%9c%89--%e5%b1%9e%e6%80%a7">&lt;/a>
&lt;/h1>&lt;p>被 &lt;code>decltype&lt;/code> 坑了很多次。推导出来可能有引用类型，想要值类型时需要先去掉！&lt;/p>
&lt;h1 id="不同的-variant-在-visitor-的参数里必须独立">不同的 variant 在 visitor 的参数里必须独立
&lt;a class="header-anchor" href="#%e4%b8%8d%e5%90%8c%e7%9a%84-variant-%e5%9c%a8-visitor-%e7%9a%84%e5%8f%82%e6%95%b0%e9%87%8c%e5%bf%85%e9%a1%bb%e7%8b%ac%e7%ab%8b">&lt;/a>
&lt;/h1>&lt;p>&lt;code>std::visit&lt;/code> 的多个参数必须独立和模板参数匹配（或者 lambda 和 C++20 函数的 auto），所以即便是要求两个类型相等，也必须写成这样：&lt;/p></description></item><item><title>Docker GPU 支持</title><link>https://hxhue.github.io/posts/cli/docker/Docker-GPU-%E6%94%AF%E6%8C%81/</link><pubDate>Thu, 02 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Docker-GPU-%E6%94%AF%E6%8C%81/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">distribution&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#719e07">$(&lt;/span>. /etc/os-release; &lt;span style="color:#b58900">echo&lt;/span> &lt;span style="color:#268bd2">$ID$VERSION_ID&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># 如果 debian12 不支持可以改成 debian11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -s -L nvidia.github.io/nvidia-docker/&lt;span style="color:#268bd2">$distribution&lt;/span>/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install -y nvidia-docker2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># 必须重启 docker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl restart docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>阻止一个模板类被实例化并给出错误信息</title><link>https://hxhue.github.io/posts/programming/cpp/%E9%98%BB%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%B9%B6%E7%BB%99%E5%87%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/</link><pubDate>Thu, 02 Nov 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E9%98%BB%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%B9%B6%E7%BB%99%E5%87%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/</guid><description>&lt;p>注意，这个类作为（不完整）类型出现在别的模板的参数中是可以的，只有访问成员才会出错。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">typename&lt;/span> Target&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">FindValue&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>Target, TypeList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">static&lt;/span> &lt;span style="color:#268bd2">inline&lt;/span> &lt;span style="color:#719e07">constexpr&lt;/span> &lt;span style="color:#dc322f">bool&lt;/span> ALWAYS_FALSE &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">sizeof&lt;/span>(Target) &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">static_assert&lt;/span>(ALWAYS_FALSE, &lt;span style="color:#2aa198">&amp;#34;Unsupported type! Check `proj::detail::DataTypeList`.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://stackoverflow.com/a/40472836/" title="https://stackoverflow.com/a/40472836/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/40472836/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>任何类型要么是不完整类型，无法被 sizeof 评估（会报错），要么被评估为正整数（包括 void 也会被评估为 1）。用 -1 的话会有类型转换警告，所以用 0 就好了。&lt;/p></description></item><item><title>ssh 命令的代理功能</title><link>https://hxhue.github.io/posts/cli/ssh/ssh-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD/</link><pubDate>Sun, 29 Oct 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/ssh/ssh-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD/</guid><description>&lt;h1 id="几种模式">几种模式
&lt;a class="header-anchor" href="#%e5%87%a0%e7%a7%8d%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h1>&lt;p>模式有三种：&lt;/p>
&lt;ol>
&lt;li>&lt;code>-L&lt;/code> 将本地端口映射到远程（将客户端请求&lt;strong>转&lt;/strong>给远程服务器）&lt;/li>
&lt;li>&lt;code>-R&lt;/code> 将远程端口映射到本地（客户端和远程服务器&lt;strong>抢&lt;/strong>请求）&lt;/li>
&lt;li>&lt;code>-D&lt;/code> 动态代理，生成一个 socks 代理，支持 socks(4)/socks5 协议&lt;/li>
&lt;/ol>
&lt;h1 id="-r-代理">&lt;code>-R&lt;/code> 代理
&lt;a class="header-anchor" href="#-r-%e4%bb%a3%e7%90%86">&lt;/a>
&lt;/h1>&lt;p>服务器连不上外网的时候常用这个。见 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/posts/cli/ssh/ssh-%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%A4%96%E7%BD%91/" title="ssh 代理转发，让服务器上外网" >ssh 代理转发，让服务器上外网&lt;/a>&lt;/p></description></item><item><title>查询一个网址的所有子域名</title><link>https://hxhue.github.io/posts/unsorted/%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E5%9F%9F%E5%90%8D/</link><pubDate>Sat, 28 Oct 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/unsorted/%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E5%9F%9F%E5%90%8D/</guid><description>&lt;p>首先是 google 上能够搜到的所有答案。&lt;/p>
&lt;p>如果用 dig axfr 搜不到，说明域名服务器没开 axfr，或者子域名不在同一个 zone。简单来说，axfr 是一个允许 client 下载整个 zone 信息的协议。&lt;/p></description></item><item><title>VS Code CMake 工程中 C++ 提示不正常</title><link>https://hxhue.github.io/posts/developer/vscode/VS-Code-CMake-%E5%B7%A5%E7%A8%8B%E4%B8%AD-C++-%E6%8F%90%E7%A4%BA%E4%B8%8D%E6%AD%A3%E5%B8%B8/</link><pubDate>Thu, 26 Oct 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/developer/vscode/VS-Code-CMake-%E5%B7%A5%E7%A8%8B%E4%B8%AD-C++-%E6%8F%90%E7%A4%BA%E4%B8%8D%E6%AD%A3%E5%B8%B8/</guid><description>&lt;h1 id="如果用-intellisense">如果用 Intellisense
&lt;a class="header-anchor" href="#%e5%a6%82%e6%9e%9c%e7%94%a8-intellisense">&lt;/a>
&lt;/h1>&lt;p>以文件 &lt;code>.vscode/c_cpp_properties.json&lt;/code> 中 &lt;code>configuration&lt;/code> 的 &lt;code>configurationProvider&lt;/code> 的值来分类。&lt;/p>
&lt;h2 id="ms-vscodecmake-tools">ms-vscode.cmake-tools
&lt;a class="header-anchor" href="#ms-vscodecmake-tools">&lt;/a>
&lt;/h2>&lt;p>&lt;strong>缺点：文件不在编译数据库中时 include 路径不正确（对新文件不友好）&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>&lt;code>configurationProvider&lt;/code> 是 &lt;code>ms-vscode.cmake-tools&lt;/code> 时&lt;/strong>，&lt;code>compileCommands&lt;/code> 和 &lt;code>includePath&lt;/code> 设置是无效的。这个时候如果 &lt;code>compile_commands.json&lt;/code> （编译数据库）中没有这个文件（尤其是 &lt;code>CMakeLists.txt&lt;/code> 中可能尚未加入新编写的文件的情况），或者编译数据库尚未配置（需要先编译生成一次)，include 路径就不正确。&lt;/p></description></item><item><title>使用 nodejs 启动文件服务器</title><link>https://hxhue.github.io/posts/systems/Linux/%E4%BD%BF%E7%94%A8-nodejs-%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Thu, 26 Oct 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Linux/%E4%BD%BF%E7%94%A8-nodejs-%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>apt install nodejs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt install npm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># 校内可用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>npm config &lt;span style="color:#b58900">set&lt;/span> registry xxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>npm install --global http-server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>http-server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认的 serve 路径是 &lt;code>./public&lt;/code>，如果找不到则使用 &lt;code>.&lt;/code> 这个路径。&lt;/p></description></item><item><title>top</title><link>https://hxhue.github.io/posts/cli/common/top/</link><pubDate>Sun, 22 Oct 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/common/top/</guid><description>&lt;p>&lt;code>top -H&lt;/code> 显示人类能阅读的大小。&lt;/p>
&lt;p>进入 top 之后：&lt;/p>
&lt;ul>
&lt;li>shift + M：按照内存排序&lt;/li>
&lt;li>shift + P：按照 CPU 使用排序&lt;/li>
&lt;li>shift + T：按照时间排序&lt;/li>
&lt;li>shift + N：按照 PID 排序&lt;/li>
&lt;/ul>
&lt;p>其实不是一定要按 shift，只要输入大写字母即可（比如用 CapsLk）&lt;/p></description></item><item><title>不同语言闭包的捕获方式</title><link>https://hxhue.github.io/posts/unsorted/%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%9A%84%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F/</link><pubDate>Thu, 12 Oct 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/unsorted/%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%9A%84%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F/</guid><description>&lt;h1 id="总览">总览
&lt;a class="header-anchor" href="#%e6%80%bb%e8%a7%88">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>C++ 根据在捕获列表中标注的方式进行捕获。&lt;/li>
&lt;li>Java 按照值捕获（而且 Java 在某些情况下还要求显式的 final 修饰符）。&lt;/li>
&lt;li>JavaScript：见 
 
 &lt;a href="https://hxhue.github.io/posts/unsorted/%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%9A%84%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F#javascript-%e6%8d%95%e8%8e%b7" title="JavaScript 捕获" >JavaScript 捕获&lt;/a>。
&lt;ul>
&lt;li>注意：捕获和传值是不同的！例如：JavaScript 在函数参数传递时仍然时按照值传递。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Python/Go 按照引用捕获，for 循环不会创造新的作用域。&lt;/li>
&lt;/ul>
&lt;h1 id="javascript-捕获">JavaScript 捕获
&lt;a class="header-anchor" href="#javascript-%e6%8d%95%e8%8e%b7">&lt;/a>
&lt;/h1>&lt;p>看上去是引用捕获，但是 for 循环的 let 和 const 绑定会创造新的作用域。&lt;/p></description></item><item><title>WSL2 不能使用 code 打开 VS Code</title><link>https://hxhue.github.io/posts/systems/Windows/WSL2-%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8-code-%E6%89%93%E5%BC%80-VS-Code/</link><pubDate>Sun, 17 Sep 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/WSL2-%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8-code-%E6%89%93%E5%BC%80-VS-Code/</guid><description>&lt;p>首先检查 &lt;code>/etc/wsl.conf&lt;/code> 配置，如果设置了不追加 Windows 的 PATH，则需要自己额外添加 VS Code 的命令目录到 WSL 中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># /etc/wsl.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[boot]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd=&lt;span style="color:#cb4b16">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[interop]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>appendWindowsPath=&lt;span style="color:#cb4b16">false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"># ~/.bashrc 或者其他配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">export&lt;/span> &lt;span style="color:#268bd2">PATH&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#34;/mnt/c/Users/xxx/AppData/Local/Programs/Microsoft VS Code/bin:&lt;/span>&lt;span style="color:#268bd2">$PATH&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果报错：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>/mnt/c/Users/xxx/AppData/Local/Programs/Microsoft VS Code/bin/code: 61: /mnt/c/Users/xxx/AppData/Local/Programs/Microsoft VS Code/Code.exe: Exec format error
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>则可能是新版 WSL 的 systemd 打包问题。（参考 &lt;a href="https://github.com/microsoft/WSL/issues/8952#issuecomment-1568212651" title="https://github.com/microsoft/WSL/issues/8952#issuecomment-1568212651" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://github.com/microsoft/WSL/issues/8952#issuecomment-1568212651&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>）&lt;/p></description></item><item><title>Javascript Spread Operator</title><link>https://hxhue.github.io/posts/programming/www/Javascript-Spread-Operator/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/www/Javascript-Spread-Operator/</guid><description>&lt;p>&lt;strong>&lt;code>{...a, ...b}&lt;/code> 相当于 &lt;code>Object.assign({}, a, b)&lt;/code>&lt;/strong>。&lt;code>Object.assign&lt;/code> 还能给已经存在的对象赋值，而且会触发 setter。Spread operator 是在创建对象，不会触发 setter。&lt;/p>
&lt;p>&lt;strong>&lt;code>[...a, ...b]&lt;/code> 相当于 &lt;code>a.concat(b)&lt;/code>&lt;/strong>。&lt;/p></description></item><item><title>Javascript 中的迭代：ArrayLike, Symbol.iterator……</title><link>https://hxhue.github.io/posts/programming/www/Javascript-%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3ArrayLike-Symbol.iterator/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/www/Javascript-%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3ArrayLike-Symbol.iterator/</guid><description>&lt;h1 id="iterable">Iterable
&lt;a class="header-anchor" href="#iterable">&lt;/a>
&lt;/h1>&lt;p>&lt;code>Symbol.iterator&lt;/code> 是个特殊的键，属于 Iterator 规范的一部分。实现了 Iterable 接口的对象是可以用 spread operator 迭代的。&lt;/p>
&lt;h1 id="arraylike">ArrayLike
&lt;a class="header-anchor" href="#arraylike">&lt;/a>
&lt;/h1>&lt;p>有 &lt;code>length&lt;/code> 属性，且在 &lt;code>[0, length)&lt;/code> 范围内都可以访问的对象被称为 ArrayLike 的对象。ArrayLike 的对象可以使用诸如 &lt;code>Array.prototype.slice.call(obj, 2)&lt;/code> 的方式来作为 Array 调用。&lt;/p></description></item><item><title>awk</title><link>https://hxhue.github.io/posts/cli/common/awk/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/common/awk/</guid><description>&lt;h1 id="删除重复行">删除重复行
&lt;a class="header-anchor" href="#%e5%88%a0%e9%99%a4%e9%87%8d%e5%a4%8d%e8%a1%8c">&lt;/a>
&lt;/h1>&lt;p>可以用 &lt;code>awk '!x[$0]++'&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>$ cat text
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>aaaa
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>aaaa
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ awk &amp;#39;!x[$0]++&amp;#39; text
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>aaaa
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Git 合集</title><link>https://hxhue.github.io/posts/cli/git/Git-%E5%90%88%E9%9B%86/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/git/Git-%E5%90%88%E9%9B%86/</guid><description>&lt;h1 id="git-config">git-config
&lt;a class="header-anchor" href="#git-config">&lt;/a>
&lt;/h1>&lt;p>&lt;a href="https://git-scm.com/docs/git-config#_configuration_file" title="https://git-scm.com/docs/git-config#_configuration_file" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://git-scm.com/docs/git-config#_configuration_file&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>&lt;code>git config --global --edit&lt;/code> 能在命令行打开全局的配置文件，即 &lt;code>%userprofile%\.gitconfig&lt;/code> 或 &lt;code>~/.gitconfig&lt;/code> 文件。&lt;/p>
&lt;blockquote>
 &lt;p>如果想要更换编辑器比如用 VS Code 编辑，可以用 &lt;code> EDITOR=code git config --global --edit&lt;/code>。&lt;/p>
&lt;/blockquote>&lt;p>配置文件的格式：&lt;/p>
&lt;ol>
&lt;li>空白字符都被忽略（无论是 &lt;code>\t&lt;/code> 还是空格都可以）&lt;/li>
&lt;li>注释的开头可以是 &lt;code>#&lt;/code> 和 &lt;code>;&lt;/code>&lt;/li>
&lt;/ol>
&lt;h1 id="git-pull-origin-ab">git pull origin A:B
&lt;a class="header-anchor" href="#git-pull-origin-ab">&lt;/a>
&lt;/h1>&lt;p>需要本地有 B 才能成功拉取，不然会拉取到当前分支。拉取的时候会自动 merge。&lt;/p></description></item><item><title>Android 内存管理</title><link>https://hxhue.github.io/posts/unsorted/Android-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/unsorted/Android-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>&lt;p>内存不足时：&lt;/p>
&lt;ol>
&lt;li>首先由 &lt;code>kswapd&lt;/code> 尝试交换页面。&lt;/li>
&lt;li>如果内存仍然不够，系统用 
 
 &lt;a href="https://hxhue.github.io/posts/unsorted/%3Chttps:/developer.android.com/reference/android/content/ComponentCallbacks2%3Fhl=zh-cn#ontrimmemoryint" title="" >&lt;/a> 通知应用程序内存不足，希望应用主动减少内存使用。&lt;/li>
&lt;li>如果内存仍然不够，使用 LMK 按照一定的优先级杀死应用。







&lt;img src="https://hxhue.github.io/assets/5ea5ab880c7530adc97b880fe01a1cbb.svg">&lt;/li>
&lt;/ol>
&lt;h1 id="交换">交换
&lt;a class="header-anchor" href="#%e4%ba%a4%e6%8d%a2">&lt;/a>
&lt;/h1>&lt;p>&lt;code>kswapd&lt;/code> 负责在内存不足时交换内存页面。zram 和 swap file 都是交换区的实现。狭义的交换指的是 disk swap。&lt;/p></description></item><item><title>Javascript's Hoisting（变量提升、函数提升、类提升）</title><link>https://hxhue.github.io/posts/programming/www/Javascripts-Hoisting%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E7%B1%BB%E6%8F%90%E5%8D%87/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/www/Javascripts-Hoisting%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E7%B1%BB%E6%8F%90%E5%8D%87/</guid><description>&lt;h1 id="function-hoisting">Function hoisting
&lt;a class="header-anchor" href="#function-hoisting">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">const&lt;/span> callerArrow &lt;span style="color:#719e07">=&lt;/span> () =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> callee(); &lt;span style="color:#586e75">// 刚定义这个函数时，callee 的状态是：defined but uninitialized
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 只要 callee 在调用这个函数之前初始化了就没有问题
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// callee(); // 见不到定义，调用会出错
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">const&lt;/span> callee &lt;span style="color:#719e07">=&lt;/span> () =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.log(&lt;span style="color:#2aa198">&amp;#34;Hello from callee!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>callerArrow(); &lt;span style="color:#586e75">// callee 的定义出现了，可以调用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>calleeRegular();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">function&lt;/span> calleeRegular() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.log(&lt;span style="color:#2aa198">&amp;#34;Hello from calleeRegular!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在同一个词法定义域中的所有声明都是能被看见的。但如果声明是函数，则还能支持直接（向后）调用，即&lt;strong>函数提升&lt;/strong>规则。如果是箭头函数，则只能引用，不能调用。&lt;/p></description></item><item><title>Clash 相关</title><link>https://hxhue.github.io/posts/systems/Windows/Clash-for-Windows-%E7%9B%B8%E5%85%B3/</link><pubDate>Sun, 20 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Clash-for-Windows-%E7%9B%B8%E5%85%B3/</guid><description>&lt;h1 id="写在前面">写在前面
&lt;a class="header-anchor" href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2">&lt;/a>
&lt;/h1>&lt;p>现在是 2024 年 4 月 17 日，Clash 源码（包括内核和 Clash for Windows，即 CFW）已经没了，&lt;a href="https://clash.wiki/" title="clash.wiki" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >clash.wiki&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 仍然能访问，并且里面有一些下载资源。虽然 Clash 现在不支持新协议了，也不继续维护了，但是它的一系列客户端实在是太好用了……&lt;/p></description></item><item><title>Pointer Events 样式</title><link>https://hxhue.github.io/posts/programming/www/Pointer-Events-%E6%A0%B7%E5%BC%8F/</link><pubDate>Sat, 19 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/www/Pointer-Events-%E6%A0%B7%E5%BC%8F/</guid><description>&lt;p>在 &lt;code>&amp;lt;a&amp;gt;&lt;/code> 中加上 &lt;code>style=&amp;quot;pointer-events: none;&amp;quot;&lt;/code> 会使得标签本身不能点击，但是其子元素可以点击。而在 &lt;code>&amp;lt;div&amp;gt;&lt;/code> 中加同样的样式，会使得标签本身和子元素都不能点击。&lt;/p>
&lt;p>其他元素基本上都是只禁用本身，只有 &lt;code>&amp;lt;div&amp;gt;&lt;/code> 元素会将子元素也禁用。&lt;/p></description></item><item><title>Python dict 和 OrderedDict</title><link>https://hxhue.github.io/posts/programming/python/Python-dict-%E5%92%8C-OrderedDict/</link><pubDate>Sat, 19 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/Python-dict-%E5%92%8C-OrderedDict/</guid><description>&lt;h1 id="有序性">有序性
&lt;a class="header-anchor" href="#%e6%9c%89%e5%ba%8f%e6%80%a7">&lt;/a>
&lt;/h1>&lt;p>这里说的有序指的是&lt;strong>维持键的插入顺序&lt;/strong>，并不是指使用二叉树维持键的大小关系。&lt;/p>
&lt;blockquote>
 &lt;p>&lt;strong>As of Python version 3.7, dictionaries are ordered&lt;/strong>. In Python 3.6 and earlier, dictionaries are unordered.&lt;/p>
&lt;/blockquote>&lt;p>而 &lt;code>OrderedDict&lt;/code> 一直是有序的。&lt;/p>
&lt;p>&lt;a href="https://devdocs.io/python~3.11/library/collections#collections.OrderedDict" title="https://devdocs.io/python~3.11/library/collections#collections.OrderedDict" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://devdocs.io/python~3.11/library/collections#collections.OrderedDict&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;h1 id="比较">比较
&lt;a class="header-anchor" href="#%e6%af%94%e8%be%83">&lt;/a>
&lt;/h1>&lt;ol>
&lt;li>Python 内置的字典主要用于查询（但在 3.7 版本之后也附带了维持插入顺序的功能），如果要频繁使用排序的功能，&lt;code>OrderedDict&lt;/code> 性能更好。&lt;/li>
&lt;li>&lt;code>OrderedDict&lt;/code> 有一些排序的接口，方便实现 LRU 缓存等。&lt;/li>
&lt;li>&lt;code>OrderedDict&lt;/code> 在相等比较时会额外比较键的顺序。&lt;/li>
&lt;/ol>
&lt;blockquote>
 &lt;p>A &lt;a href="https://devdocs.io/python~3.11/library/stdtypes#dict%20%22dict%22" title="regular" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >regular&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> can emulate the order sensitive equality test with :
&lt;code>p == q and all(k1 == k2 for k1, k2 in zip(p, q))&lt;/code>.&lt;/p></description></item><item><title>Do53、DoT、DoH 速度比较</title><link>https://hxhue.github.io/posts/unsorted/Do53DoTDoH-%E9%80%9F%E5%BA%A6%E6%AF%94%E8%BE%83/</link><pubDate>Fri, 18 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/unsorted/Do53DoTDoH-%E9%80%9F%E5%BA%A6%E6%AF%94%E8%BE%83/</guid><description>&lt;h1 id="测试方式">测试方式
&lt;a class="header-anchor" href="#%e6%b5%8b%e8%af%95%e6%96%b9%e5%bc%8f">&lt;/a>
&lt;/h1>&lt;p>用 Windows 电脑向阿里云的 &lt;code>223.5.5.5&lt;/code> 服务器发送请求。本文只提供一个直观的比较，并不追求全面的讲解。&lt;/p>
&lt;h1 id="doh">DOH
&lt;a class="header-anchor" href="#doh">&lt;/a>
&lt;/h1>&lt;p>端口号 443。&lt;/p>
&lt;p>接口比较复杂，要求我们制作一个 dns 查询包，然后将其转换成 base64 编码，再去掉末尾多余的 &lt;code>=&lt;/code>（base64 规定不足 4 字节的整数倍则需要补充 &lt;code>=&lt;/code>）。然后将得到的字符串作为 &lt;code>dns&lt;/code> 参数放在 url 中。返回的结果也是二进制数据。&lt;/p></description></item><item><title>Windows cmd 调用和退出</title><link>https://hxhue.github.io/posts/systems/Windows/Windows-cmd-%E8%B0%83%E7%94%A8%E5%92%8C%E9%80%80%E5%87%BA/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Windows-cmd-%E8%B0%83%E7%94%A8%E5%92%8C%E9%80%80%E5%87%BA/</guid><description>&lt;ul>
&lt;li>&lt;code>exit&lt;/code>：退出整个 &lt;code>cmd.exe&lt;/code>。&lt;/li>
&lt;li>&lt;code>exit /b&lt;/code>：只退出当前的批处理脚本。&lt;/li>
&lt;li>&lt;code>xx.bat&lt;/code>：转去运行 &lt;code>xx.bat&lt;/code>，不再返回。&lt;/li>
&lt;li>&lt;code>call xx.bat&lt;/code>：转去运行 &lt;code>xx.bat&lt;/code>，结束后返回（除非调用了 &lt;code>exit&lt;/code> 使得整个 &lt;code>cmd.exe&lt;/code> 中止）。&lt;/li>
&lt;li>&lt;code>cmd /c yy&lt;/code>：执行 &lt;code>yy&lt;/code> 命令，结束后在交互界面继续等待操作。&lt;/li>
&lt;li>&lt;code>cmd /k yy&lt;/code>：执行 &lt;code>yy&lt;/code> 命令，结束后退出。&lt;/li>
&lt;li>&lt;code>start zz&lt;/code>：创建一个新的窗口运行 &lt;code>zz&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>如果想要在子脚本有 &lt;code>exit&lt;/code>（而不是 &lt;code>exit /b&lt;/code>）的情况还能不退出，可以使用 &lt;code>cmd&lt;/code> 或者 &lt;code>start&lt;/code> 创建新的命令行提示符。&lt;/p></description></item><item><title>在 Windows 的 bat 脚本中写 python 代码</title><link>https://hxhue.github.io/posts/programming/python/%E5%9C%A8-Windows-%E7%9A%84-bat-%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%86%99-python-%E4%BB%A3%E7%A0%81/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/%E5%9C%A8-Windows-%E7%9A%84-bat-%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%86%99-python-%E4%BB%A3%E7%A0%81/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">&amp;#34;python&amp;#34;&lt;/span> &lt;span style="color:#2aa198">&amp;#34;%~dp0%~nx0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">字符串对于 cmd 来说是外部命令或参数，对于 python 来说是可拼接的字面量。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">exit 对 cmd 来说是退出，对于 python 来说是一个函数名。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">exit 会中止调用者，但在桌面点击运行的环境下可以正常使用。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> uuid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> subprocess
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">def&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">while&lt;/span> (&lt;span style="color:#b58900">input&lt;/span>(&lt;span style="color:#2aa198">&amp;#39;Hit enter to generate another key: &amp;#39;&lt;/span>)&lt;span style="color:#719e07">.&lt;/span>strip() &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;&amp;#39;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#b58900">str&lt;/span>(uuid&lt;span style="color:#719e07">.&lt;/span>uuid4())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> subprocess&lt;span style="color:#719e07">.&lt;/span>run(&lt;span style="color:#2aa198">&amp;#34;clip&amp;#34;&lt;/span>, text&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#cb4b16">True&lt;/span>, &lt;span style="color:#b58900">input&lt;/span>&lt;span style="color:#719e07">=&lt;/span>s)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b58900">print&lt;/span>(&lt;span style="color:#2aa198">f&lt;/span>&lt;span style="color:#2aa198">&amp;#39;&lt;/span>&lt;span style="color:#2aa198">{&lt;/span>s&lt;span style="color:#2aa198">}&lt;/span>&lt;span style="color:#2aa198"> is sent to your clipboard!&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">if&lt;/span> __name__ &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;__main__&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> main()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">except&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">pass&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b58900">input&lt;/span>(&lt;span style="color:#2aa198">&amp;#39;&lt;/span>&lt;span style="color:#cb4b16">\n&lt;/span>&lt;span style="color:#2aa198">You entered something else. Program will end after your next input.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Python 判断字符串是否为空</title><link>https://hxhue.github.io/posts/programming/python/Python-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/</link><pubDate>Tue, 15 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/Python-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">def&lt;/span> &lt;span style="color:#268bd2">empty&lt;/span>(s): &lt;span style="color:#719e07">return&lt;/span> s &lt;span style="color:#719e07">is&lt;/span> &lt;span style="color:#cb4b16">None&lt;/span> &lt;span style="color:#719e07">or&lt;/span> &lt;span style="color:#b58900">len&lt;/span>(s) &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">0&lt;/span> &lt;span style="color:#719e07">or&lt;/span> s&lt;span style="color:#719e07">.&lt;/span>isblank()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>(libstdc++ vs libc++) std::tuple</title><link>https://hxhue.github.io/posts/programming/cpp/libstdc++-vs-libc++-std_tuple/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libstdc++-vs-libc++-std_tuple/</guid><description>&lt;h1 id="列表构造顺序">列表构造顺序
&lt;a class="header-anchor" href="#%e5%88%97%e8%a1%a8%e6%9e%84%e9%80%a0%e9%a1%ba%e5%ba%8f">&lt;/a>
&lt;/h1>&lt;p>&lt;code>libstdc++&lt;/code> 用的是递归反向构造，尾部的参数先构造。与之对应，&lt;code>libc++&lt;/code> 用的是 parameter pack 继承，是正向构造。&lt;/p>
&lt;h1 id="下标编号">下标编号
&lt;a class="header-anchor" href="#%e4%b8%8b%e6%a0%87%e7%bc%96%e5%8f%b7">&lt;/a>
&lt;/h1>&lt;p>两者都使用了下标编号。这样即便 &lt;code>std::tuple&lt;/code> 的某两个参数类型相同，也能通过不同的下标把两个元素区分开。&lt;/p></description></item><item><title>(libstdc++) std::function</title><link>https://hxhue.github.io/posts/programming/cpp/libstdc++-std_function/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libstdc++-std_function/</guid><description>&lt;p>涉及的 libstdc++ 源码文件：&lt;code>bits/std_function.h&lt;/code>。&lt;/p>
&lt;p>印象： &lt;code>std::function&lt;/code> 做了小对象优化，同时在避免使用虚函数（尽管它可以用继承和虚函数来实现）。&lt;/p>
&lt;p>关于成员指针，见 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/posts/programming/cpp/Pointer-to-Member/" title="Pointer to Member" >Pointer to Member&lt;/a>。&lt;/p></description></item><item><title>(libstdc++) std::set</title><link>https://hxhue.github.io/posts/programming/cpp/libstdc++-std_set/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/libstdc++-std_set/</guid><description>&lt;p>相关文件：&lt;/p>
&lt;ul>
&lt;li>&lt;code>include/set&lt;/code> 头文件按顺序引入了 &lt;code>include/bits/stl_tree.h&lt;/code> 和 &lt;code>include/bits/stl_set.h&lt;/code>。&lt;/li>
&lt;li>&lt;code>include/bits/stl_set.h&lt;/code> 定义了 &lt;code>std::set&lt;/code>，依赖了 &lt;code>include/bits/stl_tree.h&lt;/code> 却没有明确包含它。&lt;/li>
&lt;li>&lt;code>include/bits/stl_tree.h&lt;/code> 定义了诸多类型，&lt;em>如未明确指出则默认下面提到的类型都是来自于这个头文件&lt;/em>。&lt;/li>
&lt;li>&lt;code>src/c++98/tree.cc&lt;/code> 实现了红黑树用到的非模板算法。这个文件只有 400 多行。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>std::set&lt;/code> 将实现转发给 &lt;code>_Rb_tree&lt;/code> 处理，而它又将实现转发给了 &lt;code>_Rb_tree_impl&lt;/code> 处理。&lt;/p></description></item><item><title>Abominable Function</title><link>https://hxhue.github.io/posts/programming/cpp/Abominable-Function/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Abominable-Function/</guid><description>&lt;p>在 &lt;a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html" title="Abominable Function Types (open-std.org)" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Abominable Function Types (open-std.org)&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 中：&lt;/p>
&lt;blockquote>
 &lt;p>For the purposes of this paper, an &lt;em>abominable&lt;/em> function type is the type produced by writing a function type followed by a &lt;em>cv-ref&lt;/em> qualifier. Example:
&lt;code>using regular = void();&lt;/code>
&lt;code>using abominable = void() const volatile &amp;amp;&amp;amp;;&lt;/code>&lt;/p>
&lt;/blockquote>&lt;p>通过一些模板手段能把类中的成员函数转换成可憎函数（怎么翻译更合适？）。可憎函数形式复杂，模板匹配困难。C++23 explicit object parameter (deducing this) 可以一定程度上解决这个问题。&lt;/p></description></item><item><title>ADL</title><link>https://hxhue.github.io/posts/programming/cpp/ADL/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/ADL/</guid><description>&lt;p>例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;numeric&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    std&lt;span style="color:#719e07">::&lt;/span>vector v{&lt;span style="color:#2aa198">1&lt;/span>, &lt;span style="color:#2aa198">3&lt;/span>, &lt;span style="color:#2aa198">5&lt;/span>}; &lt;span style="color:#586e75">// 模板类参数推导：T=int
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>    std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>accumulate(begin(v), end(v), &lt;span style="color:#2aa198">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#586e75">// ^^ ^^ ^^ 都是ADL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>begin&lt;/code>、&lt;code>end&lt;/code>、&lt;code>swap&lt;/code> 等函数模板时，先引入其名字到当前空间中，然后再调用，有助于 ADL 查找到性能更优的函数实现：&lt;/p></description></item><item><title>Aggregate</title><link>https://hxhue.github.io/posts/programming/cpp/Aggregate/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Aggregate/</guid><description>&lt;p>






&lt;img src="https://hxhue.github.io/assets/06486f8b0865616fe9a68551e46d4412.webp">&lt;/p>
&lt;p>注意，有 &lt;strong>bit fields&lt;/strong> 或者 &lt;strong>有成员默认值&lt;/strong> 或者 &lt;strong>有匿名 union 成员&lt;/strong> 也可以是 aggregate。&lt;/p>
&lt;p>对含有 union 成员的聚合类使用 &lt;em>花括号&lt;/em> 或 &lt;em>默认的全参数构造函数&lt;/em> 初始化时，初始化的是 union 的第一个元素（不管 union 是不是匿名的）。&lt;/p></description></item><item><title>auto + decltype</title><link>https://hxhue.github.io/posts/programming/cpp/auto-+-decltype/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/auto-+-decltype/</guid><description>&lt;h1 id="用于标注函数返回值">用于标注函数返回值
&lt;a class="header-anchor" href="#%e7%94%a8%e4%ba%8e%e6%a0%87%e6%b3%a8%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e5%80%bc">&lt;/a>
&lt;/h1>&lt;p>令人意外的是：C++14 加入的返回值推导是一种特殊的类型，和前向声明并不兼容。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">known&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">auto&lt;/span> &lt;span style="color:#268bd2">known&lt;/span>() { &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">42&lt;/span>; } &lt;span style="color:#586e75">// 错误：类型不兼容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// int known() { return 42; } // ok
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// auto known() -&amp;gt; int { return 42; } // ok
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样：&lt;/p></description></item><item><title>bash 配置</title><link>https://hxhue.github.io/posts/cli/bash/bash-%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/bash/bash-%E9%85%8D%E7%BD%AE/</guid><description>&lt;h1 id="bash-的两个配置文件">bash 的两个配置文件
&lt;a class="header-anchor" href="#bash-%e7%9a%84%e4%b8%a4%e4%b8%aa%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6">&lt;/a>
&lt;/h1>&lt;p>login 时只加载 &lt;code>.bash_profile&lt;/code>（如果存在），其他时候只加载 &lt;code>.bashrc&lt;/code>。&lt;/p>
&lt;p>最好是把内容放在 &lt;code>.bashrc&lt;/code>，然后让 ~/.bash_profile 去 &lt;code>source ~/.bashrc&lt;/code>。&lt;/p>
&lt;p>虽然 &lt;code>~/.bashrc&lt;/code> 是所有非登陆的 bash 都会读，但默认的 &lt;code>~/.bashrc&lt;/code> 的开头检查了当前是否为交互终端，如果不是则退出。如果非要绕过这个限制，可以强制一个终端为交互终端：&lt;code>bash -i&lt;/code>。&lt;/p></description></item><item><title>C/C++ 全局定义应该放在 .bss 还是 .data</title><link>https://hxhue.github.io/posts/programming/cpp/C-%E5%92%8C-C++-%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8-.bss-%E8%BF%98%E6%98%AF-.data/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C-%E5%92%8C-C++-%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8-.bss-%E8%BF%98%E6%98%AF-.data/</guid><description>&lt;h1 id="cc-中全局定义声明的区别">C/C++ 中全局定义/声明的区别
&lt;a class="header-anchor" href="#cc-%e4%b8%ad%e5%85%a8%e5%b1%80%e5%ae%9a%e4%b9%89%e5%a3%b0%e6%98%8e%e7%9a%84%e5%8c%ba%e5%88%ab">&lt;/a>
&lt;/h1>&lt;p>无论在 C 还是 C++，想要仅声明而不在翻译单元中定义全局变量，都需要 extern。&lt;/p>
&lt;p>&lt;strong>C语言&lt;/strong>：（强弱是方便我叙述引出的概念）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> global &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>; &lt;span style="color:#586e75">// 强定义，和其他强定义互斥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#dc322f">int&lt;/span> global;     &lt;span style="color:#586e75">// 弱定义，可以和同文件其他定义兼容（最终只保留一份定义）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#dc322f">int&lt;/span> global;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>能编译！但是上面的代码和其他目标文件一起链接时，若出现多次定义同样会引发重复定义的错误。&lt;/p></description></item><item><title>C++ 几种新增类型转换的区别 + 标准库模板函数</title><link>https://hxhue.github.io/posts/programming/cpp/C++-%E5%87%A0%E7%A7%8D%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB-+-%E6%A0%87%E5%87%86%E5%BA%93%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++-%E5%87%A0%E7%A7%8D%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB-+-%E6%A0%87%E5%87%86%E5%BA%93%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</guid><description>&lt;h1 id="四大关键字">四大关键字
&lt;a class="header-anchor" href="#%e5%9b%9b%e5%a4%a7%e5%85%b3%e9%94%ae%e5%ad%97">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>&lt;code>static_cast&lt;/code> 大多数转换，包括左右值转换、&lt;strong>父子类指针/引用之间的转换&lt;/strong>（不进行安全检查，但会修正指针偏移）。&lt;/li>
&lt;li>&lt;code>const_cast&lt;/code> 也能进行 volatile 属性的修改！！&lt;/li>
&lt;li>&lt;code>dynamic_cast&lt;/code> 父子类指针/引用之间的转换。其中子类转向基类相当于使用 &lt;code>static_cast&lt;/code> ，没有运行时安全检查。而基类转向子类则有运行时安全检查，而且要求基类是多态类，否则无法编译。&lt;/li>
&lt;li>&lt;code>reinterpret_cast&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="标准库的共享指针转换模板">标准库的共享指针转换模板
&lt;a class="header-anchor" href="#%e6%a0%87%e5%87%86%e5%ba%93%e7%9a%84%e5%85%b1%e4%ba%ab%e6%8c%87%e9%92%88%e8%bd%ac%e6%8d%a2%e6%a8%a1%e6%9d%bf">&lt;/a>
&lt;/h1>&lt;p>标准库中还有针对于 &lt;code>std::shared_ptr&lt;/code> 的类型转换模板。转换后返回一个共享指针，但其包裹的类型被转换成了对应的类型：&lt;/p></description></item><item><title>C++23 std::forward_like</title><link>https://hxhue.github.io/posts/programming/cpp/C++23-std_forward_like/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/C++23-std_forward_like/</guid><description>&lt;p>&lt;code>std::forward&lt;/code> 需要我们提供一个模板参数，它能把同类型（不包括值类别）的参数转发出去。&lt;/p>
&lt;p>&lt;code>std::forward_like&lt;/code> 则有两个模板参数，第一个参数需要显式提供，第二个参数从实参中推导。它从模板参数中获得转发需要使用的引用类型，并将实参转发出去。&lt;strong>这意味着实参和模板参数的类型可以不一致！&lt;/strong>&lt;/p></description></item><item><title>cppreference 协程例子理解</title><link>https://hxhue.github.io/posts/programming/cpp/cppreference-%E5%8D%8F%E7%A8%8B%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/cppreference-%E5%8D%8F%E7%A8%8B%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3/</guid><description>&lt;p>我的理解是：C++ 的协程是无栈的，这意味着协程只是计算任务，仅在运行时需要栈，在 suspend 之后就会保存状态并脱离栈。要想要跨线程转移计算任务（比如实现工作窃取池），只需要将离栈协程在另外一个线程上 resume 即可。&lt;/p></description></item><item><title>enum class</title><link>https://hxhue.github.io/posts/programming/cpp/enum-class/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/enum-class/</guid><description>&lt;p>C 风格枚举和 C++ 新增的 enum class：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">enum&lt;/span> { ITEM_A1, ITEM_A2 };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">enum&lt;/span> &lt;span style="color:#268bd2">B&lt;/span> { ITEM_B1, ITEM_B2 };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 从 C 沿用来的语法：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 1. 底层类型默认为int，但也能手动指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 2. 枚举名裸露在外
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 区别：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// C 允许前向声明 enum
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// C++ 允许枚举列表为空；允许在表示类型时省略 enum 关键字；虽然枚举名裸露但也能通过限定名访问
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// C++ 新增 enum class
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">enum&lt;/span> &lt;span style="color:#268bd2">C&lt;/span> { ITEM_C1, ITEM_C2 };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 类型不再裸露，需要使用限定名访问
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 没有默认底层类型，但是可以手动指定
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C++ enum class 禁止了隐式转换，但是用来表示 id 还是不太方便：&lt;/p></description></item><item><title>explicit</title><link>https://hxhue.github.io/posts/programming/cpp/explicit/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/explicit/</guid><description>&lt;p>一般认为 &lt;code>explicit&lt;/code> 是用在单参数构造函数 上防止隐式类型转换的。但如果参数有多个，explicit 关键字也有其他的作用。&lt;/p>
&lt;h1 id="explicit-可以阻止--推导">&lt;code>explicit&lt;/code> 可以阻止 &lt;code>{}&lt;/code> 推导
&lt;a class="header-anchor" href="#explicit-%e5%8f%af%e4%bb%a5%e9%98%bb%e6%ad%a2--%e6%8e%a8%e5%af%bc">&lt;/a>
&lt;/h1>&lt;p>&lt;a href="https://stackoverflow.com/a/39122237/" title="https://stackoverflow.com/a/39122237/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/39122237/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>可以参考另一篇文章：{ } Syntax。&lt;/p></description></item><item><title>Heterogeneous Lookup</title><link>https://hxhue.github.io/posts/programming/cpp/Heterogeneous-Lookup/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Heterogeneous-Lookup/</guid><description>&lt;p>&lt;a href="https://www.cppstories.com/2021/heterogeneous-access-cpp20/" title="https://www.cppstories.com/2021/heterogeneous-access-cpp20/" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://www.cppstories.com/2021/heterogeneous-access-cpp20/&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;h1 id="c-14-加入了对有序容器的异质查找">C++ 14 加入了对有序容器的异质查找
&lt;a class="header-anchor" href="#c-14-%e5%8a%a0%e5%85%a5%e4%ba%86%e5%af%b9%e6%9c%89%e5%ba%8f%e5%ae%b9%e5%99%a8%e7%9a%84%e5%bc%82%e8%b4%a8%e6%9f%a5%e6%89%be">&lt;/a>
&lt;/h1>&lt;p>用户的工作量很小，对标准库中的类型，只需要加上第三个模板参数：&lt;code>std::less&amp;lt;&amp;gt;&lt;/code>（它的默认参数是 void）。&lt;code>std::less&amp;lt;void&amp;gt;&lt;/code> 类中申明了 &lt;code>is_transparent&lt;/code> 类型，所以可以用于异质查找。&lt;/p></description></item><item><title>Hidden Friends</title><link>https://hxhue.github.io/posts/programming/cpp/Hidden-Friends/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Hidden-Friends/</guid><description>&lt;p>下面的代码中，Bar 能够隐式转换成 Foo。想要重载 Foo 的等于运算符至少有三种方案：&lt;/p>
&lt;ol>
&lt;li>重载全局的 &lt;code>==&lt;/code> 运算符&lt;/li>
&lt;li>重载 Foo 中的 hidden friend，即 &lt;code>friend bool operator==(Foo const &amp;amp;a, Foo const &amp;amp;b)&lt;/code>&lt;/li>
&lt;li>重载 &lt;code>bool operator==(Foo const &amp;amp;a) const&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>第一种方案会污染全局的名字空间，使得 Bar 和 Bar 之间也能通过转换两个参数进行比较；第三种方案允许第二个参数的隐式类型转换，但要求第一个参数必须是 Foo 类型；第二种方案只要求任一个参数为 Foo 类型，使得 ADL 能够参与找到这个函数，另一个参数则可以通过隐式类型转换来得到。&lt;/p></description></item><item><title>Inheritance</title><link>https://hxhue.github.io/posts/programming/cpp/Inheritance/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Inheritance/</guid><description>&lt;div style="overflow-x: auto">
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;/th>
 &lt;th>public&lt;/th>
 &lt;th>protected&lt;/th>
 &lt;th>private&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>共有继承&lt;/td>
 &lt;td>public&lt;/td>
 &lt;td>protected&lt;/td>
 &lt;td>不可见&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>私有继承&lt;/td>
 &lt;td>private&lt;/td>
 &lt;td>private&lt;/td>
 &lt;td>不可见&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>保护继承&lt;/td>
 &lt;td>protected&lt;/td>
 &lt;td>protected&lt;/td>
 &lt;td>不可见&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;/div>&lt;p>可见继承属性就是对于来自基类的 public 和 protected 成员进行一个取最小权限的操作（定义权限 public &amp;gt; protected &amp;gt; private）。&lt;/p></description></item><item><title>Javascript 从 DOMNodeInserted 到 MutationObserver</title><link>https://hxhue.github.io/posts/programming/www/Javascript-%E4%BB%8E-DOMNodeInserted-%E5%88%B0-MutationObserver/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/www/Javascript-%E4%BB%8E-DOMNodeInserted-%E5%88%B0-MutationObserver/</guid><description>&lt;p>这段代码是在 Tamper Monkey 的 content.js 中发现的。被浏览器警告应该替换掉这种写法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>bn.addEventListener(&lt;span style="color:#2aa198">&amp;#34;DOMNodeInserted&amp;#34;&lt;/span>, o, s)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>替换成&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">var&lt;/span> [adder, remover] &lt;span style="color:#719e07">=&lt;/span> ((bn, o, s) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">var&lt;/span> helper &lt;span style="color:#719e07">=&lt;/span> { remove &lt;span style="color:#719e07">:&lt;/span> () =&amp;gt; {}, add &lt;span style="color:#719e07">:&lt;/span> () =&amp;gt; {} }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">var&lt;/span> observer &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> MutationObserver(&lt;span style="color:#268bd2">function&lt;/span>(mutations) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mutations.forEach(&lt;span style="color:#268bd2">function&lt;/span>(mutation) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">var&lt;/span> nodes &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#b58900">Array&lt;/span>.prototype.slice.call(mutation.addedNodes);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes.forEach((node_) =&amp;gt; { o(); helper.remove() });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> helper.remove &lt;span style="color:#719e07">=&lt;/span> () =&amp;gt; observer.disconnect();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> helper.add &lt;span style="color:#719e07">=&lt;/span> () =&amp;gt; observer.observe(bn, { childList&lt;span style="color:#719e07">:&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>, subtree&lt;span style="color:#719e07">:&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>, };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> [helper.add, helper.remove];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})(bn, o, s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>adder()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>bn.removeEventListener(&lt;span style="color:#2aa198">&amp;#34;DOMNodeInserted&amp;#34;&lt;/span>, o, s)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>替换成&lt;/p></description></item><item><title>Lambda 在各 C++ 版本的演进</title><link>https://hxhue.github.io/posts/programming/cpp/Lambda-%E5%9C%A8%E5%90%84-C++-%E7%89%88%E6%9C%AC%E7%9A%84%E6%BC%94%E8%BF%9B/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Lambda-%E5%9C%A8%E5%90%84-C++-%E7%89%88%E6%9C%AC%E7%9A%84%E6%BC%94%E8%BF%9B/</guid><description>&lt;h1 id="c11">C++11
&lt;a class="header-anchor" href="#c11">&lt;/a>
&lt;/h1>&lt;p>虽然有了 auto 关键字，但是用起来还是需要 trailing return type 声明。&lt;/p>
&lt;h1 id="c14">C++14
&lt;a class="header-anchor" href="#c14">&lt;/a>
&lt;/h1>&lt;p>可以省略尾部声明（以下两种写法都是要 C++14 才能支持）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">auto&lt;/span> &lt;span style="color:#268bd2">f&lt;/span>() { &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">42&lt;/span>; } &lt;span style="color:#586e75">// #1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">auto&lt;/span> &lt;span style="color:#268bd2">f&lt;/span>() &lt;span style="color:#719e07">-&amp;gt;&lt;/span> &lt;span style="color:#719e07">auto&lt;/span> { &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">42&lt;/span>; } &lt;span style="color:#586e75">// #2，相当于 #1
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="markdown-alert markdown-alert-note">
 &lt;p class="markdown-alert-title">&lt;svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16"
 aria-hidden="true">
 &lt;path
 d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
 &lt;/path>
 &lt;/svg>Note&lt;/p></description></item><item><title>Makefile</title><link>https://hxhue.github.io/posts/cli/Makefile/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/Makefile/</guid><description>&lt;h1 id="-和-">&lt;code>$()&lt;/code> 和 &lt;code>${}&lt;/code>
&lt;a class="header-anchor" href="#-%e5%92%8c-">&lt;/a>
&lt;/h1>&lt;p>除了 &lt;code>$&lt;/code> 之外，&lt;code>$()&lt;/code> 和 &lt;code>${}&lt;/code> 都是 make 替换变量的语法。但是 &lt;code>${}&lt;/code> 还能被某些 shell（比如 bash）继续替换。&lt;/p>
&lt;p>此外，它们也能调用 make 提供的命令，比如字符串替换、过滤和调用 shell。&lt;/p></description></item><item><title>noexcept + throw</title><link>https://hxhue.github.io/posts/programming/cpp/noexcept-+-throw/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/noexcept-+-throw/</guid><description>&lt;p>noexcept 有几个用法：&lt;/p>
&lt;ol>
&lt;li>在编译期返回一个常量布尔值，评估其表达式是否会抛出异常。&lt;/li>
&lt;li>用于标志一个函数是否能抛出异常，需要一个编译期布尔常量作为参数。&lt;/li>
&lt;li>标志函数不会抛出异常。相当于 &lt;code>noexcept(true)&lt;/code>。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// whether foo is declared noexcept depends on if the expression
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// T() will throw any exceptions
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">template&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">T&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> foo() &lt;span style="color:#719e07">noexcept&lt;/span>(&lt;span style="color:#719e07">noexcept&lt;/span>(T())) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">bar&lt;/span>() &lt;span style="color:#719e07">noexcept&lt;/span>(&lt;span style="color:#b58900">true&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">baz&lt;/span>() &lt;span style="color:#719e07">noexcept&lt;/span> { &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#2aa198">42&lt;/span>; } &lt;span style="color:#586e75">// noexcept is the same as noexcept(true)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> foo&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>(); &lt;span style="color:#586e75">// noexcept(noexcept(int())) =&amp;gt; noexcept(true), so this is fine
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bar(); &lt;span style="color:#586e75">// fine
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> baz(); &lt;span style="color:#586e75">// compiles, but at runtime this calls std::terminate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C++17 已经禁用 &lt;code>throw&lt;/code> 的显式异常声明。（被称为 &lt;code>Dynamic exception specification&lt;/code>）&lt;/p></description></item><item><title>OpenJDK: ConcurrentHashMap</title><link>https://hxhue.github.io/posts/programming/java/ConcurrentHashMap/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/java/ConcurrentHashMap/</guid><description>&lt;p>现在已经没有 Segment 概念，并发系数不生效。能支持高效的并发：&lt;/p>
&lt;ol>
&lt;li>支持懒初始化，第一次写的时候发生，可能需要自旋但不需要加锁。&lt;/li>
&lt;li>读的时候可能需要自旋，不需要加锁。&lt;/li>
&lt;li>写的时候如果遇到正在扩容，则加入一起扩容；如果写时槽位为空，则只需要原子操作；写时操作非空，且不处在特殊状态，则需要加对象锁。因而读写互不阻塞、不同槽位的写不会阻塞、扩容不会阻塞（因为扩容时其他竞争线程也会被分配任务）、仅有单个槽位的多写需要阻塞。&lt;/li>
&lt;/ol>
&lt;p>为了节省空间，在 &lt;code>Node[]&lt;/code> 中用 hash 为负的头结点来表示该拉链处于特殊状态：树结点、转移中、预留等。&lt;/p></description></item><item><title>OpenJDK: CopyOnWriteArrayList</title><link>https://hxhue.github.io/posts/programming/java/CopyOnWriteArrayList/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/java/CopyOnWriteArrayList/</guid><description>&lt;p>写的时候加锁（因为要替换 array 数组的引用，而且复制的过程比较耗时，不宜自旋），读的时候不用加锁。替换的安全性由 Java volatile 保证。&lt;/p></description></item><item><title>OpenJDK: Java Memory Order</title><link>https://hxhue.github.io/posts/programming/java/Java-Memory-Order/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/java/Java-Memory-Order/</guid><description>&lt;p>CPU 内存屏障：&lt;a href="https://sf-zhou.github.io/programming/memory_barrier.html" title="https://sf-zhou.github.io/programming/memory_barrier.html" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://sf-zhou.github.io/programming/memory_barrier.html&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>volatile 与内存屏障总结： &lt;a href="https://zhuanlan.zhihu.com/p/43526907" title="https://zhuanlan.zhihu.com/p/43526907" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://zhuanlan.zhihu.com/p/43526907&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;blockquote>
 &lt;p>X86-64 下仅支持一种指令重排：Store-Load ，即读操作可能会重排到写操作前面，同时不同线程的写操作并没有保证全局可见，例子见《Intel® 64 and IA-32 Architectures Software Developer’s Manual》手册 8.6.1、8.2.3.7 节。要注意的是这个问题只能用 mfence 解决，不能靠组合 sfence 和 lfence 解决。（用 sfence+lfence 组合仅可以解决重排问题，但不能解决全局可见性问题，简单理解不如视为 &lt;code>sfence&lt;/code> 和 &lt;code>lfence&lt;/code> 本身也能乱序重排）&lt;/p></description></item><item><title>OpenJDK: JUC locks</title><link>https://hxhue.github.io/posts/programming/java/JUC-locks/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/java/JUC-locks/</guid><description>&lt;h1 id="reentrantlock-公平锁和非公平锁的实现">ReentrantLock 公平锁和非公平锁的实现
&lt;a class="header-anchor" href="#reentrantlock-%e5%85%ac%e5%b9%b3%e9%94%81%e5%92%8c%e9%9d%9e%e5%85%ac%e5%b9%b3%e9%94%81%e7%9a%84%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h1>&lt;p>






&lt;img src="https://hxhue.github.io/assets/d6745452123368b4ec805513d2ac0e8a.svg">&lt;/p>
&lt;p>如果需要长时间等待，AQS 总是会将等待线程加入到队列尾部，唤醒时总是唤醒队首线程。这样做能够保证已经被睡眠的线程必定按照顺序唤醒。这样做难道不是永远都是公平锁？&lt;/p></description></item><item><title>OpenJDK: Project Loom</title><link>https://hxhue.github.io/posts/programming/java/Project-Loom/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/java/Project-Loom/</guid><description>&lt;h1 id="互斥锁">互斥：锁
&lt;a class="header-anchor" href="#%e4%ba%92%e6%96%a5%e9%94%81">&lt;/a>
&lt;/h1>&lt;p>现在对象锁不尊重虚拟线程，但是 JUC 下的锁是尊重虚拟线程的。&lt;/p>
&lt;h1 id="共享scopedvalue">共享：ScopedValue
&lt;a class="header-anchor" href="#%e5%85%b1%e4%ba%abscopedvalue">&lt;/a>
&lt;/h1>&lt;p>ThreadLocal 和虚拟线程配合的不是很好，尽管功能上 ThreadLocal 是支持虚拟线程的，但是由于虚拟线程数量众多、生命周期短，使用 ThreadLocal 时虽然保证了线程安全，却创建了大量对象——这个问题在平台线程上就不明显。JEP 429 ScopedValues (Java 20) 是为了解决这个问题的。&lt;/p></description></item><item><title>P2266R3: Simpler implicit move 对 C++23 函数返回表达式值类别的改变</title><link>https://hxhue.github.io/posts/programming/cpp/P2266R3-Simpler-implicit-move-%E5%AF%B9-C++23-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%80%BC%E7%B1%BB%E5%88%AB%E7%9A%84%E6%94%B9%E5%8F%98/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/P2266R3-Simpler-implicit-move-%E5%AF%B9-C++23-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%80%BC%E7%B1%BB%E5%88%AB%E7%9A%84%E6%94%B9%E5%8F%98/</guid><description>&lt;h1 id="写在前面">写在前面
&lt;a class="header-anchor" href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2">&lt;/a>
&lt;/h1>&lt;p>本篇内容参考提案 &lt;a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2266r3.html" title="Simpler implicit move" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Simpler implicit move&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>。&lt;/p>
&lt;p>隐式移动是函数返回值优化的一种，在 C++ 不同版本有不同的规则，这篇文章主要讲隐式移动，不涉及其他返回值优化的内容。&lt;/p></description></item><item><title>POD</title><link>https://hxhue.github.io/posts/programming/cpp/POD/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/POD/</guid><description>&lt;p>Plain Old Data&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/a/4178176/" title="https://stackoverflow.com/a/4178176" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/4178176&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>成为 POD 的条件：&lt;/p>
&lt;ol>
&lt;li>所有的标准类型都是 POD（尽管不是 aggregate）。&lt;/li>
&lt;li>数组要成为 POD 的条件是每个元素都是 POD。&lt;/li>
&lt;li>一个类要成为 POD，则必须首先是 &lt;strong>aggregate&lt;/strong>，然后：
&lt;ol>
&lt;li>没有用户定义的赋值运算符。&lt;/li>
&lt;li>没有析构函数。&lt;/li>
&lt;li>所有成员都是 POD（递归定义）。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol></description></item><item><title>Pointer to Member</title><link>https://hxhue.github.io/posts/programming/cpp/Pointer-to-Member/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Pointer-to-Member/</guid><description>&lt;h1 id="数据成员指针存储的是偏移">数据成员指针存储的是偏移
&lt;a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e6%88%90%e5%91%98%e6%8c%87%e9%92%88%e5%ad%98%e5%82%a8%e7%9a%84%e6%98%af%e5%81%8f%e7%a7%bb">&lt;/a>
&lt;/h1>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>&lt;span style="color:#719e07">using&lt;/span> &lt;span style="color:#719e07">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">Foo&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Foo x{&lt;span style="color:#2aa198">2&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> Foo&lt;span style="color:#719e07">::*&lt;/span> px &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>Foo&lt;span style="color:#719e07">::&lt;/span>x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> Foo&lt;span style="color:#719e07">::*&lt;/span> py &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>Foo&lt;span style="color:#719e07">::&lt;/span>y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> (&lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>)px &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#586e75">// 输出0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> (&lt;span style="color:#dc322f">unsigned&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>)py &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#586e75">// 输出4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#719e07">sizeof&lt;/span>(px) &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#586e75">// gcc输出8
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>数据成员指针的大小和实现相关。&lt;/p>
&lt;h1 id="成员函数指针比一般指针占用更多空间">成员函数指针比一般指针占用更多空间
&lt;a class="header-anchor" href="#%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88%e6%af%94%e4%b8%80%e8%88%ac%e6%8c%87%e9%92%88%e5%8d%a0%e7%94%a8%e6%9b%b4%e5%a4%9a%e7%a9%ba%e9%97%b4">&lt;/a>
&lt;/h1>&lt;p>和编译器相关。gcc 里成员函数指针在 64 位机器下是 16 字节。&lt;/p></description></item><item><title>Python __pycache__</title><link>https://hxhue.github.io/posts/programming/python/Python-__pycache__/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/Python-__pycache__/</guid><description>&lt;h1 id="工作原理">工作原理
&lt;a class="header-anchor" href="#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86">&lt;/a>
&lt;/h1>&lt;p>&lt;a href="https://peps.python.org/pep-3147/#python-behavior" title="https://peps.python.org/pep-3147/#python-behavior" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://peps.python.org/pep-3147/#python-behavior&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/dbdbce0fb3f79132732f34d71c5fee8f.webp">&lt;/p>
&lt;p>每次 import 的时候，解释器检查当前目录下的 &lt;code>__pycache__&lt;/code> 文件夹，读取和 Python 版本对应的 cache，然后读取 cache 中库的修改时间（cache 文件中记录着源码的修改时间，并不是 cache 文件本身的修改时间）。将这个时间和源码的时间比较，如果这个时间不存在，或者比源码的时间新，就加载 &lt;code>.pyc&lt;/code> 而不必加载源码。&lt;/p></description></item><item><title>Python __slots__</title><link>https://hxhue.github.io/posts/programming/python/Python-__slots__/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/Python-__slots__/</guid><description>&lt;p>定义了 &lt;code>__slots__&lt;/code> 静态属性的类没有 &lt;code>__dict__&lt;/code> 属性。而且只能添加存在于槽中的属性（可以少加，不能多加）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">Point&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __slots__ &lt;span style="color:#719e07">=&lt;/span> [&lt;span style="color:#2aa198">&amp;#39;x&amp;#39;&lt;/span>, &lt;span style="color:#2aa198">&amp;#39;y&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">def&lt;/span> __init__(&lt;span style="color:#268bd2">self&lt;/span>, x, y):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">self&lt;/span>&lt;span style="color:#719e07">.&lt;/span>x &lt;span style="color:#719e07">=&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">self&lt;/span>&lt;span style="color:#719e07">.&lt;/span>y &lt;span style="color:#719e07">=&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>p &lt;span style="color:#719e07">=&lt;/span> Point(&lt;span style="color:#2aa198">1&lt;/span>, &lt;span style="color:#2aa198">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">print&lt;/span>(p&lt;span style="color:#719e07">.&lt;/span>__dict__) &lt;span style="color:#586e75"># 输出: AttributeError: &amp;#39;Point&amp;#39; object has no attribute &amp;#39;__dict__&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>槽最大的意义在于节省空间：共享 &lt;code>__slots__&lt;/code>，每个对象没有自己的 &lt;code>__dict__&lt;/code>。节省了字典的空间。对于属性较多的对象，使用槽访问速度可能会下降。&lt;/p></description></item><item><title>Python sys vs os</title><link>https://hxhue.github.io/posts/programming/python/Python-sys-vs-os/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/Python-sys-vs-os/</guid><description>&lt;p>sys 可以访问解释器（运行时功能）和系统特定功能（系统有关功能）。os 提供了操作系统上的统一抽象（系统无关功能）。&lt;/p>
&lt;ul>
&lt;li>解释器功能：比如 &lt;code>sys.argv&lt;/code> 访问命令行参数，&lt;code>sys.exit()&lt;/code> 退出程序，&lt;code>sys.path&lt;/code> 是 python 包的查询路径，&lt;code>sys.stdin/sys.stdout/sys.stderr&lt;/code> 分别表示三个系统管道。&lt;/li>
&lt;li>系统有关功能：比如 &lt;code>sys.getwindowsversion&lt;/code> 可以得到 windows 的大小版本号。&lt;code>sys.platform&lt;/code> 可以获得操作系统平台。&lt;code>sys.version&lt;/code> 是 python 安装信息。&lt;/li>
&lt;li>系统无关功能：操作文件系统，path 分隔符，环境变量等。&lt;/li>
&lt;/ul></description></item><item><title>Python 转置矩阵</title><link>https://hxhue.github.io/posts/programming/python/Python-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/python/Python-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>transpose &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">lambda&lt;/span> listA: &lt;span style="color:#b58900">list&lt;/span>(&lt;span style="color:#b58900">list&lt;/span>(t) &lt;span style="color:#719e07">for&lt;/span> t &lt;span style="color:#719e07">in&lt;/span> &lt;span style="color:#b58900">zip&lt;/span>(&lt;span style="color:#719e07">*&lt;/span>listA))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>range-for</title><link>https://hxhue.github.io/posts/programming/cpp/range-for/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/range-for/</guid><description>&lt;p>以前容易出现引用悬挂的问题。在新的语言标准中得到了改进。&lt;/p>
&lt;p>C++11 只是简单的语法糖，只能保证表达式返回值被临时变量接受并保留到循环结束：(&lt;a href="https://stackoverflow.com/a/51440883" title="https://stackoverflow.com/a/51440883" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >https://stackoverflow.com/a/51440883&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>)&lt;/p></description></item><item><title>Rust 程序设计语言 第一印象</title><link>https://hxhue.github.io/posts/programming/rust/Rust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-%E7%AC%AC%E4%B8%80%E5%8D%B0%E8%B1%A1/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/rust/Rust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-%E7%AC%AC%E4%B8%80%E5%8D%B0%E8%B1%A1/</guid><description>&lt;p>首先看这个：&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/fee648949a294fc8593f0a4dbbef67b1.webp">&lt;/p>
&lt;p>C++中在 C++14 之后可以使用 &lt;code>'&lt;/code> 来分隔数字字面量。而 Java 和 Rust 在设计阶段很早的时候就支持了用 &lt;code>_&lt;/code> 来分隔数字。&lt;/p>
&lt;p>个人感受：&lt;/p>
&lt;ul>
&lt;li>处处充斥强制移动语义。相关的是 Drop Trait，而基本类型还实现了 Copy Trait。（所有权和 C++ RAII 想要解决的问题相似）&lt;/li>
&lt;li>默认定义是常量，包括引用默认是常引用。（和 C++ 相反）&lt;/li>
&lt;li>允许同一个作用域内 shadow，试图把变量名当成真正的标签来用（类似 Python）。&lt;/li>
&lt;li>错误处理用 expect，比 try-catch 简洁。&lt;/li>
&lt;li>内置元组和 range、if 条件不需要加括号。&lt;/li>
&lt;li>很多实用包都得用 crate，在标准库中没提供……&lt;/li>
&lt;/ul>
&lt;h1 id="认识所有权">认识所有权
&lt;a class="header-anchor" href="#%e8%ae%a4%e8%af%86%e6%89%80%e6%9c%89%e6%9d%83">&lt;/a>
&lt;/h1>&lt;p>同一生存期，对对象 A 的可变引用将排斥任何对对象 A 的其他引用。当且仅当所有引用都是常量引用时编译才能够通过。一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。编译器能够把这一点检查出来。如果最后一次使用结束了，就不参与和其他引用的排斥行为了。&lt;/p></description></item><item><title>sizeof</title><link>https://hxhue.github.io/posts/programming/cpp/sizeof/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/sizeof/</guid><description>&lt;p>下面几个表达式相等：&lt;/p>
&lt;ul>
&lt;li>&lt;code>sizeof(T&amp;amp;)&lt;/code>&lt;/li>
&lt;li>&lt;code>sizeof(T&amp;amp;&amp;amp;)&lt;/code>&lt;/li>
&lt;li>&lt;code>sizeof(T)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>也就是说 &lt;code>sizeof&lt;/code> 会去掉引用。忘记出处了，twitter 上有人提过一个 quiz，什么类型 &lt;code>T&lt;/code> 能满足 &lt;code>struct {T x;}&lt;/code> 和 &lt;code>T&lt;/code> 的 sizeof 结果不相等，引用类型就满足这样的情况。&lt;/p></description></item><item><title>std::lower_bound/upper_bound</title><link>https://hxhue.github.io/posts/programming/cpp/std-lower_bound-upper_bound/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/std-lower_bound-upper_bound/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">public&lt;/span>&lt;span style="color:#719e07">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span> searchRange(vector&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#dc322f">int&lt;/span> target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> n &lt;span style="color:#719e07">=&lt;/span> (&lt;span style="color:#dc322f">int&lt;/span>)nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// lower_bound 的可能实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">auto&lt;/span> lowerbound &lt;span style="color:#719e07">=&lt;/span> [&lt;span style="color:#719e07">&amp;amp;&lt;/span>](&lt;span style="color:#719e07">auto&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span>less) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> lo &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>, hi &lt;span style="color:#719e07">=&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">while&lt;/span> (lo &lt;span style="color:#719e07">&amp;lt;&lt;/span> hi) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> mid &lt;span style="color:#719e07">=&lt;/span> (lo &lt;span style="color:#719e07">+&lt;/span> hi) &lt;span style="color:#719e07">/&lt;/span> &lt;span style="color:#2aa198">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (less(nums[mid], target)) lo &lt;span style="color:#719e07">=&lt;/span> mid &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">else&lt;/span> hi &lt;span style="color:#719e07">=&lt;/span> mid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> lo;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// std::lower_bound
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> left &lt;span style="color:#719e07">=&lt;/span> lowerbound(std&lt;span style="color:#719e07">::&lt;/span>less&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// std::upper_bound
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> right &lt;span style="color:#719e07">=&lt;/span> lowerbound(std&lt;span style="color:#719e07">::&lt;/span>less_equal&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (left &lt;span style="color:#719e07">&amp;lt;&lt;/span> n &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> nums[left] &lt;span style="color:#719e07">==&lt;/span> target) &lt;span style="color:#719e07">?&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>{left, right&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>} &lt;span style="color:#719e07">:&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#dc322f">int&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>{&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>, &lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Strict Aliasing</title><link>https://hxhue.github.io/posts/programming/cpp/Strict-Aliasing/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Strict-Aliasing/</guid><description>&lt;p>文章：&lt;a href="https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8" title="What is Strict Aliasing and Why do we Care? (github.com)" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >What is Strict Aliasing and Why do we Care? (github.com)&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>所谓 Strict Aliasing 就是指为 aliasing 设定条件，使得编译器大多数场景下认为代码没有 aliasing，从而可以激进优化代码。&lt;/p></description></item><item><title>Three-way Comparison =</title><link>https://hxhue.github.io/posts/programming/cpp/Three-way-Comparison/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Three-way-Comparison/</guid><description>&lt;h1 id="含义">含义
&lt;a class="header-anchor" href="#%e5%90%ab%e4%b9%89">&lt;/a>
&lt;/h1>&lt;p>C++ 20 加入了 &lt;code>&amp;lt;=&amp;gt;&lt;/code> 操作符，该操作符会按布局顺序比较成员，比较时会递归使用 &lt;code>&amp;lt;=&amp;gt;&lt;/code> 操作符。对于类类型来说，即便默认的 &lt;code>&amp;lt;=&amp;gt;&lt;/code> 操作符可用，也必须显式声明为 &lt;code>= default&lt;/code>，否则不能使用。&lt;/p></description></item><item><title>tmux</title><link>https://hxhue.github.io/posts/cli/common/tmux/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/common/tmux/</guid><description>&lt;p>配置文件在 &lt;code>~/.tmux.conf&lt;/code>。&lt;/p>
&lt;p>开启鼠标（可能是最正常的操作逻辑了）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">set&lt;/span> -g mouse on
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>打开之后能够支持切换 window、panel，调整 panel 之间的相对大小。右键还有一些便捷操作。比如 mark 提供复制功能。&lt;/p></description></item><item><title>type_index</title><link>https://hxhue.github.io/posts/programming/cpp/type_index/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/type_index/</guid><description>&lt;p>例子：bustub lab 0&lt;/p>
&lt;p>可以和 
 
 
 
 
 
 
 
 
 
 
 
 
 
 &lt;a href="https://hxhue.github.io/inside-the-cpp-object-model/vtable/" title="📌vtable" >📌vtable&lt;/a> 联系起来看。&lt;/p>
&lt;h1 id="dynamic_cast-何时可以使用">dynamic_cast 何时可以使用？
&lt;a class="header-anchor" href="#dynamic_cast-%e4%bd%95%e6%97%b6%e5%8f%af%e4%bb%a5%e4%bd%bf%e7%94%a8">&lt;/a>
&lt;/h1>&lt;p>使用要求：① 目标是类的指针或引用 ② 目标类含虚表&lt;/p>
&lt;p>我最初在 bustub lab 0 的实现中使用了向下转型的操作：在 &lt;code>Get&lt;/code> 操作中，当一个 &lt;code>TrieNode&lt;/code> 有值的时候，就尝试向下转型为 &lt;code>TrieNodeWithValue&amp;lt;T&amp;gt;&lt;/code>，这一步仍然正确就说明类型也正确，可以取出返回。&lt;/p></description></item><item><title>UB</title><link>https://hxhue.github.io/posts/programming/cpp/UB/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/UB/</guid><description>&lt;p>&lt;a href="https://en.cppreference.com/w/cpp/language/ub" title="Undefined behavior - cppreference.com" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Undefined behavior - cppreference.com&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/p>
&lt;p>&lt;em>ill-formed&lt;/em>：有语法错误，或者能被检查出的语义错误。必须提供诊断（编译错误）。&lt;/p>
&lt;p>&lt;em>ill-formed, &lt;a href="https://en.cppreference.com/w/cpp/language/ndr" title="no diagnostic required" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >no diagnostic required&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a>&lt;/em>：正常编译，但有 UB。&lt;/p></description></item><item><title>Value Categories</title><link>https://hxhue.github.io/posts/programming/cpp/Value-Categories/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/Value-Categories/</guid><description>&lt;p>&lt;a href="https://en.cppreference.com/w/cpp/language/value_category" title="Value categories - cppreference.com" rel="noopener external nofollow noreferrer"
 target="_blank" class=" exturl" >Value categories - cppreference.com&lt;i class="fa fa-external-link-alt">&lt;/i>&lt;/a> 有更详细的说明。&lt;/p>
&lt;h1 id="分类">分类
&lt;a class="header-anchor" href="#%e5%88%86%e7%b1%bb">&lt;/a>
&lt;/h1>&lt;p>






&lt;img src="https://hxhue.github.io/assets/5910006dfebc9695741390926be5186f.webp">&lt;/p>
&lt;p>lvalue / rvalue / xvalue 是互斥的，C++ 表达式只能是三者之一。glvalue 和 rvalue 都是复合类别：glvalue 包括 lvalue 和 xvalue，rvalue 包括 prvalue 和 xvalue。在翻译上，xvalue 叫（将）亡值，glvalue 叫泛左值。&lt;/p></description></item><item><title>vim</title><link>https://hxhue.github.io/posts/cli/common/vim/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/common/vim/</guid><description>&lt;h1 id="vim-配置文件位置">vim 配置文件位置
&lt;a class="header-anchor" href="#vim-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e4%bd%8d%e7%bd%ae">&lt;/a>
&lt;/h1>&lt;p>使用 &lt;code>:scriptnames&lt;/code> 查看。&lt;/p>
&lt;p>neovim + Windows 的配置文件：&lt;code>%userprofile%\AppData\Local\nvim\init.vim&lt;/code>&lt;/p>
&lt;p>macOS 和 Linux：&lt;code>~/.config/nvim/init.vim&lt;/code>&lt;/p></description></item><item><title>Windows 11 禁用笔记本键盘</title><link>https://hxhue.github.io/posts/systems/Windows/Windows-11-%E7%A6%81%E7%94%A8%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%94%AE%E7%9B%98/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Windows-11-%E7%A6%81%E7%94%A8%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%94%AE%E7%9B%98/</guid><description>&lt;p>&lt;strong>禁用&lt;/strong>：&lt;code>sc.exe config i8042prt start= disabled&lt;/code>&lt;/p>
&lt;p>&lt;strong>启用&lt;/strong>：&lt;code>sc.exe config i8042prt start= auto&lt;/code>&lt;/p>
&lt;p>需要重启。&lt;/p></description></item><item><title>Windows 查找已经修改过的组策略</title><link>https://hxhue.github.io/posts/systems/Windows/Windows-%E6%9F%A5%E6%89%BE%E5%B7%B2%E7%BB%8F%E4%BF%AE%E6%94%B9%E8%BF%87%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Windows-%E6%9F%A5%E6%89%BE%E5%B7%B2%E7%BB%8F%E4%BF%AE%E6%94%B9%E8%BF%87%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5/</guid><description>&lt;p>在所有设置中点排序。&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/1a5bb26a09cd937ee65801bf61378ad9.webp">&lt;/p></description></item><item><title>Windows 窗口栏在屏幕外不能移动</title><link>https://hxhue.github.io/posts/systems/Windows/Windows-%E7%AA%97%E5%8F%A3%E6%A0%8F%E5%9C%A8%E5%B1%8F%E5%B9%95%E5%A4%96%E4%B8%8D%E8%83%BD%E7%A7%BB%E5%8A%A8/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Windows-%E7%AA%97%E5%8F%A3%E6%A0%8F%E5%9C%A8%E5%B1%8F%E5%B9%95%E5%A4%96%E4%B8%8D%E8%83%BD%E7%A7%BB%E5%8A%A8/</guid><description>&lt;p>先把窗口激活（放到最前面）然后按 &lt;strong>&lt;code>Alt&lt;/code>&lt;/strong> + &lt;strong>&lt;code>Space&lt;/code>&lt;/strong>，就能出现菜单选择 &lt;strong>最大化/最小化/移动&lt;/strong>。&lt;/p>
&lt;p>如果不行，也可以把任何一个其他的窗口拖动到左屏，右侧选择位置不正确的窗口组成双栏分屏，然后将其拖出来恢复成正常窗口。&lt;/p></description></item><item><title>Windows 合集</title><link>https://hxhue.github.io/posts/systems/Windows/Windows-%E5%90%88%E9%9B%86/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Windows-%E5%90%88%E9%9B%86/</guid><description>&lt;h1 id="必做">🚩必做
&lt;a class="header-anchor" href="#%e5%bf%85%e5%81%9a">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>关闭实时保护&lt;/li>
&lt;li>关闭自动更新&lt;/li>
&lt;li>定时创建还原点&lt;/li>
&lt;/ul>
&lt;p>如果系统驱动有问题、难以修复而且没有创建还原点，全新安装新系统也可以，&lt;strong>Windows 不会抹除所有数据&lt;/strong>，受影响的只有注册表和 &lt;code>C:\Windows&lt;/code> 文件夹下的数据。用户文件夹会被备份到 &lt;code>C:\Windows.old&lt;/code> 中，QQ 和微信聊天数据、ssh/clash 等配置文件夹可以从其中复制过来。程序需要重新安装。&lt;/p></description></item><item><title>Windows 回退驱动或给已经删除的设备添加驱动</title><link>https://hxhue.github.io/posts/systems/Windows/Windows-%E5%9B%9E%E9%80%80%E9%A9%B1%E5%8A%A8%E6%88%96%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%88%A0%E9%99%A4%E7%9A%84%E8%AE%BE%E5%A4%87%E6%B7%BB%E5%8A%A0%E9%A9%B1%E5%8A%A8/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Windows-%E5%9B%9E%E9%80%80%E9%A9%B1%E5%8A%A8%E6%88%96%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%88%A0%E9%99%A4%E7%9A%84%E8%AE%BE%E5%A4%87%E6%B7%BB%E5%8A%A0%E9%A9%B1%E5%8A%A8/</guid><description>&lt;p>&lt;strong>如果想要恢复到曾经安装过的驱动&lt;/strong>。可以按照下面步骤操作：&lt;/p>
&lt;p>首先在设备管理器中选择添加过时硬件。&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/1b40b74499ab2e5aa844b2f760b83e97.webp">&lt;/p>
&lt;p>看到首页之后点下一页。然后选中手动安装，再点一次下一页。&lt;/p></description></item><item><title>Windows 提示被管理员禁止安装核显驱动、WSL 也无法启动</title><link>https://hxhue.github.io/posts/systems/Windows/Windows-%E6%8F%90%E7%A4%BA%E8%A2%AB%E7%AE%A1%E7%90%86%E5%91%98%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85%E6%A0%B8%E6%98%BE%E9%A9%B1%E5%8A%A8WSL-%E4%B9%9F%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/Windows-%E6%8F%90%E7%A4%BA%E8%A2%AB%E7%AE%A1%E7%90%86%E5%91%98%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85%E6%A0%B8%E6%98%BE%E9%A9%B1%E5%8A%A8WSL-%E4%B9%9F%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</guid><description>&lt;p>原因是很早之前按照知乎的说法启用了这个设置，本想禁用系统更新时自动安装旧版本的核显驱动，但也使得我的电脑核显驱动坏掉且不能自行安装。&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/df665a70a2b095157646fb53c02e2313.webp">&lt;/p>
&lt;p>恢复核显驱动首先应该关闭这项，然后去下载对应驱动安装，或者回退到旧的驱动。&lt;/p></description></item><item><title>WSL 合集</title><link>https://hxhue.github.io/posts/systems/Windows/WSL-%E5%90%88%E9%9B%86/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/Windows/WSL-%E5%90%88%E9%9B%86/</guid><description>&lt;h1 id="常见问题">常见问题
&lt;a class="header-anchor" href="#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98">&lt;/a>
&lt;/h1>&lt;p>&lt;strong>设置 apt 代理&lt;/strong>。编辑 /etc/apt/apt.conf，格式如下（ip 会变）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>// 很奇怪，注释竟然是//开头，而不是#
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Acquire::http::Proxy &amp;#34;http://192.168.1.56:12366/&amp;#34;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Acquire::https::Proxy &amp;#34;http://192.168.1.56:12366/&amp;#34;;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
 &lt;p>sudo 没有 &lt;code>$http_proxy&lt;/code> 代理的原因是默认不传递环境变量，使用 &lt;code>-E&lt;/code> 选项传递环境变量就可以不设置上面的代理。&lt;/p></description></item><item><title>读 On Java 8</title><link>https://hxhue.github.io/posts/programming/java/%E8%AF%BB-On-Java-8/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/java/%E8%AF%BB-On-Java-8/</guid><description>&lt;h1 id="chapter-00-11">Chapter 00-11
&lt;a class="header-anchor" href="#chapter-00-11">&lt;/a>
&lt;/h1>&lt;p>Java 对象构造顺序：1、基类 2、所有域 3、初始化块 4、自身的构造函数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#719e07">&amp;gt;&lt;/span> a &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> Foo()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Value initialization
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Initialization block
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Constructor
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为接口提供默认实现：&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/630546bf2b71cdf127d9f96b76c05aa1.webp">&lt;/p>
&lt;p>逆变、协变、不变的关系：&lt;/p>
&lt;p>






&lt;img src="https://hxhue.github.io/assets/3e7c37a37ad6d2386c55e8ac2a421164.webp">&lt;/p>
&lt;p>在 Java 的子类中 override 了父类的方法，返回一个协变类型也是可以的。比如基类规定的是返回 Object，重写的方法里面是可以写返回任意对象的。&lt;/p></description></item><item><title>实现简单的花括号插值打印</title><link>https://hxhue.github.io/posts/programming/cpp/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%8A%B1%E6%8B%AC%E5%8F%B7%E6%8F%92%E5%80%BC%E6%89%93%E5%8D%B0/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%8A%B1%E6%8B%AC%E5%8F%B7%E6%8F%92%E5%80%BC%E6%89%93%E5%8D%B0/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">#include&lt;/span> &lt;span style="color:#719e07">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#719e07">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">&lt;/span>&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">print&lt;/span>(std&lt;span style="color:#719e07">::&lt;/span>ostream &lt;span style="color:#719e07">&amp;amp;&lt;/span>os, &lt;span style="color:#719e07">const&lt;/span> &lt;span style="color:#dc322f">char&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">while&lt;/span> (&lt;span style="color:#719e07">*&lt;/span>s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">char&lt;/span> ch &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s&lt;span style="color:#719e07">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Treat &amp;#34;{}&amp;#34; as a normal substring when no arguments are left
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// if (ch == &amp;#39;{&amp;#39; &amp;amp;&amp;amp; *s == &amp;#39;}&amp;#39;) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> ((ch &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;{&amp;#39;&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;{&amp;#39;&lt;/span>) &lt;span style="color:#719e07">||&lt;/span> (ch &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;}&amp;#39;&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;}&amp;#39;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s&lt;span style="color:#719e07">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> ch;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">template&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">A&lt;/span>, &lt;span style="color:#719e07">class&lt;/span>... &lt;span style="color:#268bd2">Ts&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> print(std&lt;span style="color:#719e07">::&lt;/span>ostream &lt;span style="color:#719e07">&amp;amp;&lt;/span>os, &lt;span style="color:#719e07">const&lt;/span> &lt;span style="color:#dc322f">char&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s, A &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span>a, Ts &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span>...args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">while&lt;/span> (&lt;span style="color:#719e07">*&lt;/span>s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">char&lt;/span> ch &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s&lt;span style="color:#719e07">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ch &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;{&amp;#39;&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;}&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#268bd2">if&lt;/span> ((ch &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;{&amp;#39;&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;{&amp;#39;&lt;/span>) &lt;span style="color:#719e07">||&lt;/span> (ch &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;}&amp;#39;&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">&amp;#39;}&amp;#39;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#719e07">*&lt;/span>s&lt;span style="color:#719e07">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> ch;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">*&lt;/span>s) print(os, s &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>, std&lt;span style="color:#719e07">::&lt;/span>forward&lt;span style="color:#719e07">&amp;lt;&lt;/span>Ts&lt;span style="color:#719e07">&amp;gt;&lt;/span>(args)...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">int&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>(&lt;span style="color:#dc322f">int&lt;/span> argc, &lt;span style="color:#dc322f">char&lt;/span> &lt;span style="color:#719e07">**&lt;/span>argv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#719e07">::&lt;/span>cout &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>unitbuf;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(std&lt;span style="color:#719e07">::&lt;/span>cout, &lt;span style="color:#2aa198">&amp;#34;numbers : {} {} {}&lt;/span>&lt;span style="color:#cb4b16">\\&lt;/span>&lt;span style="color:#2aa198">n&amp;#34;&lt;/span>, &lt;span style="color:#2aa198">10&lt;/span>, &lt;span style="color:#2aa198">5&lt;/span>, &lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">7&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的写法依赖了 &lt;code>std::ostream&lt;/code>，而且不支持格式指定符。如果能够构造一个模板类 &lt;code>PrintArg&lt;/code> 包装 1 个任意类型参数和 1 个输出说明字符串，然后重载 &lt;code>std::ostream&lt;/code> 的 &lt;code>&amp;lt;&amp;lt;&lt;/code> 操作符，那么可以不用动 print 函数的逻辑。&lt;/p></description></item><item><title>使用 Iosevka（等距更纱黑体） 字体的坑</title><link>https://hxhue.github.io/posts/unsorted/%E4%BD%BF%E7%94%A8-Iosevka%E7%AD%89%E8%B7%9D%E6%9B%B4%E7%BA%B1%E9%BB%91%E4%BD%93-%E5%AD%97%E4%BD%93%E7%9A%84%E5%9D%91/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/unsorted/%E4%BD%BF%E7%94%A8-Iosevka%E7%AD%89%E8%B7%9D%E6%9B%B4%E7%BA%B1%E9%BB%91%E4%BD%93-%E5%AD%97%E4%BD%93%E7%9A%84%E5%9D%91/</guid><description>&lt;p>虽然展开字体在预览中描述的是 Extended，但是实际使用时需要写成 Expanded。&lt;/p></description></item><item><title>一些 macOS 和 GNU 的命令差异</title><link>https://hxhue.github.io/posts/systems/macOS/%E4%B8%80%E4%BA%9B-macOS-%E5%92%8C-GNU-%E7%9A%84%E5%91%BD%E4%BB%A4%E5%B7%AE%E5%BC%82/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/systems/macOS/%E4%B8%80%E4%BA%9B-macOS-%E5%92%8C-GNU-%E7%9A%84%E5%91%BD%E4%BB%A4%E5%B7%AE%E5%BC%82/</guid><description>&lt;h1 id="sed--i">sed -i
&lt;a class="header-anchor" href="#sed--i">&lt;/a>
&lt;/h1>&lt;p>macOS &lt;code>sed&lt;/code> 的 -i 需要指定参数，如果不需要备份文件，需要显式给出 &lt;code>sed -i ''&lt;/code>。不然可以用 &lt;code>gsed&lt;/code> 命令（用 brew 安装）。&lt;/p>
&lt;h1 id="xargs">xargs
&lt;a class="header-anchor" href="#xargs">&lt;/a>
&lt;/h1>&lt;p>如果没有收到输入，就不会运行。而 GNU 的 &lt;code>xargs&lt;/code> 在没有收到输入时会只运行右侧命令而不附带参数。要想 GNU xargs 在此时不运行命令，需要使用 &lt;code>-r&lt;/code> 选项。&lt;/p></description></item><item><title>用构造函数和 swap 实现 operator=</title><link>https://hxhue.github.io/posts/programming/cpp/%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C-swap-%E5%AE%9E%E7%8E%B0-operator/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/programming/cpp/%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C-swap-%E5%AE%9E%E7%8E%B0-operator/</guid><description>&lt;h1 id="代码展示">代码展示
&lt;a class="header-anchor" href="#%e4%bb%a3%e7%a0%81%e5%b1%95%e7%a4%ba">&lt;/a>
&lt;/h1>&lt;p>先在参数的位置创建一个新的对象，然后和 &lt;code>*this&lt;/code> 交换。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">struct&lt;/span> &lt;span style="color:#268bd2">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyClass&lt;span style="color:#719e07">&amp;amp;&lt;/span> &lt;span style="color:#719e07">operator&lt;/span>&lt;span style="color:#719e07">=&lt;/span>(MyClass other) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(&lt;span style="color:#719e07">*&lt;/span>&lt;span style="color:#719e07">this&lt;/span>, other);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">*&lt;/span>&lt;span style="color:#719e07">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">friend&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">swap&lt;/span>(MyClass &lt;span style="color:#719e07">&amp;amp;&lt;/span>a, MyClass &lt;span style="color:#719e07">&amp;amp;&lt;/span>b) &lt;span style="color:#719e07">noexcept&lt;/span>; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">using&lt;/span> std&lt;span style="color:#719e07">::&lt;/span>swap;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(a.member1, b.member1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(a.member2, b.member2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> member1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> member2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种实现既能够匹配 &lt;code>const MyClass &amp;amp;&lt;/code> 的情况，又能匹配 &lt;code>MyClass &amp;amp;&amp;amp;&lt;/code> 的情况，而且代码行数更短。&lt;/p></description></item><item><title>Windows 上 Docker 和 Hyper-V 的坑</title><link>https://hxhue.github.io/posts/cli/docker/Windows-%E4%B8%8A-Docker-%E5%92%8C-Hyper-V-%E7%9A%84%E5%9D%91/</link><pubDate>Mon, 19 Jun 2023 00:00:00 +0800</pubDate><guid>https://hxhue.github.io/posts/cli/docker/Windows-%E4%B8%8A-Docker-%E5%92%8C-Hyper-V-%E7%9A%84%E5%9D%91/</guid><description>&lt;blockquote>
 &lt;p>这个写的时间比较早了，当时有的问题现在可能已经被弥补了。&lt;/p>
&lt;/blockquote>&lt;p>&lt;code>bcdedit&lt;/code> 和 hypervisor 相关，直接关掉 hypervisor 还不能够完全关闭。一些软件仍然不能够运行。&lt;/p>
&lt;p>运行 &lt;code>bcdedit /set hypervisorlaunchtype off&lt;/code>（需要管理员权限）后再重启可以关掉这个功能。直接使用 &lt;code>bcdedit&lt;/code> 开始查看当前的配置状况。&lt;/p></description></item></channel></rss>