<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Posts"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":false,"path":"posts","permalink":"https://hxhue.github.io/posts/","title":"Posts","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>posts - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/cuda/cudaDeviceSynchronize-%E5%92%8C-cudaStreamSynchronize/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="cudaDeviceSynchronize 和 cudaStreamSynchronize"><meta itemprop=description content="我的理解

CUDA 的 API 都是和 device 相关的，调用前要先确保已经调用过 cudaSetDevice 将 context 关联到相关的设备上（据 Stackoverflow 的老提问，这个 context 会占用 150 MB 显存；从我这边来看，这个显存占用量还更大一些，有 200300 MB）。创建流是不需要提供设备号的，所以它肯定使用的是 thread_local 的 device。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/programming/cuda/cudaDeviceSynchronize-%E5%92%8C-cudaStreamSynchronize/ itemprop=url class=post-title-link>cudaDeviceSynchronize 和 cudaStreamSynchronize</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-04-25 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-04-25 00:00:00 +0800 CST">2024-04-25
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-04-28T00:00:00+08:00 itemprop=dateModified datetime=2024-04-28T00:00:00+08:00>2024-04-28</time></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=我的理解>我的理解
<a class=header-anchor href=#%e6%88%91%e7%9a%84%e7%90%86%e8%a7%a3></a></h1><p>CUDA 的 API 都是和 device 相关的，调用前要先确保已经调用过 <code>cudaSetDevice</code> 将 context 关联到相关的设备上（据 Stackoverflow 的<a href=https://stackoverflow.com/q/64854862/ title=老提问 rel="noopener external nofollow noreferrer" target=_blank class=exturl>老提问<i class="fa fa-external-link-alt"></i></a>，这个 context 会占用 <del>150 MB 显存；从我这边来看，这个显存占用量还更大一些，有 200</del>300 MB）。创建流是不需要提供设备号的，所以它肯定使用的是 thread_local 的 device。</p><p>也就是说，每个流是和设备关联起来的，用 <code>cudaDeviceSynchronize</code> 实际上是同步了这个设备上所有的流，而 <code>cudaStreamSynchronize</code> 是同步了单个流。<strong>前者的同步范围更大</strong>。</p><p>根据 Stackoverflow 的<a href=https://stackoverflow.com/a/72821558/ title=这个回答 rel="noopener external nofollow noreferrer" target=_blank class=exturl>这个回答<i class="fa fa-external-link-alt"></i></a>，<code>cudaStreamSynchronize</code> 的默认参数是 <code>nullptr</code>，也就是默认流，同步它相当于同步当前设备上的所有阻塞流。由于可以创建非阻塞流，所以就算不给 <code>cudaStreamSynchronize</code> 传参或者传 <code>nullptr</code>，效果也和 <code>cudaDeviceSynchronize()</code> 可能是不一样的。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span>cudaStreamCreateWithFlags( stream_0, cudaStreamNonBlocking );
</span></span><span style=display:flex><span>cudaStreamCreate( stream_1 );
</span></span><span style=display:flex><span><span style=color:#586e75>// ...
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>cudaStreamSynchronize( <span style=color:#719e07>nullptr</span> ); <span style=color:#586e75>// sync with stream_1 and legacy stream
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>cudaDeviceSynchronize(); <span style=color:#586e75>// sync with stream_0, stream_1 and legacy
</span></span></span></code></pre></div><h1 id=其他>其他
<a class=header-anchor href=#%e5%85%b6%e4%bb%96></a></h1><p><code>cudaThreadSynchronize</code> 方法和 <code>cudaDeviceSynchronize</code> 很相似，前者是过时方法，建议使用后者。</p></div><footer class=post-footer><div readmore=false><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/programming/cuda/cudaDeviceSynchronize-%E5%92%8C-cudaStreamSynchronize/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/cpp/inline-%E5%87%BD%E6%95%B0%E4%B8%8D%E5%AF%B9%E5%A4%96%E9%93%BE%E6%8E%A5gnu89-%E5%92%8C-c99-%E6%81%90%E6%80%96%E7%9A%84%E8%AF%AD%E4%B9%89%E5%AF%B9%E6%8D%A2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="inline 函数不对外链接？gnu89 和 c99 恐怖的语义对换！"><meta itemprop=description content="经过

遇到过一个坑：为共享库写函数，但是又需要从头文件隐藏实现时，不要将函数声明为内联。否则编译器会认为它未被使用并忽略它，链接的时候就找不到这个函数。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/programming/cpp/inline-%E5%87%BD%E6%95%B0%E4%B8%8D%E5%AF%B9%E5%A4%96%E9%93%BE%E6%8E%A5gnu89-%E5%92%8C-c99-%E6%81%90%E6%80%96%E7%9A%84%E8%AF%AD%E4%B9%89%E5%AF%B9%E6%8D%A2/ itemprop=url class=post-title-link>inline 函数不对外链接？gnu89 和 c99 恐怖的语义对换！</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-04-25 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-04-25 00:00:00 +0800 CST">2024-04-25
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-03-18T00:00:00+08:00 itemprop=dateModified datetime=2025-03-18T00:00:00+08:00>2025-03-18</time></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=经过>经过
<a class=header-anchor href=#%e7%bb%8f%e8%bf%87></a></h1><p>遇到过一个坑：为共享库写函数，但是又需要从头文件隐藏实现时，不要将函数声明为内联。否则编译器会认为它未被使用并忽略它，链接的时候就找不到这个函数。</p><p>项目使用的语言是 C++。</p><h1 id=tldr>TL;DR
<a class=header-anchor href=#tldr></a></h1><p>其实只是不会主动生成函数定义罢了，不是不能对外链接。除非调用处看到的声明带有 <code>inline</code> 关键字，从而尝试在其所在的翻译单元中寻找。</p><h1 id=尝试解释c-中内联函数按需生成>尝试解释：C++ 中内联函数按需生成
<a class=header-anchor href=#%e5%b0%9d%e8%af%95%e8%a7%a3%e9%87%8ac-%e4%b8%ad%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0%e6%8c%89%e9%9c%80%e7%94%9f%e6%88%90></a></h1><p><a href=https://zh.cppreference.com/w/cpp/language/inline title=https://zh.cppreference.com/w/cpp/language/inline rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://zh.cppreference.com/w/cpp/language/inline<i class="fa fa-external-link-alt"></i></a> 中有一句：</p><blockquote><p>内联函数或变量 (C++17 起) 的定义必须在访问它的翻译单元中可达（不一定要在访问点前）。</p></blockquote></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/programming/cpp/inline-%E5%87%BD%E6%95%B0%E4%B8%8D%E5%AF%B9%E5%A4%96%E9%93%BE%E6%8E%A5gnu89-%E5%92%8C-c99-%E6%81%90%E6%80%96%E7%9A%84%E8%AF%AD%E4%B9%89%E5%AF%B9%E6%8D%A2/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/systems/Linux/gitlab/gitlab-jh-%E5%92%8C-gitlab-ce-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E5%A3%B0%E6%98%8E/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="gitlab-jh 和 gitlab-ce 的区别以及博客内容声明"><meta itemprop=description content="Gitlab 极狐版本是极狐购买了经营权的版本，内部也分会员版。从免费版的功能来看，两者几乎没有区别。但是为了更严谨一些，本博客中所有内容都可能是在 gitlab-jh 或者 gitlab-ce 上试过（或者混用），不保证仅在 gitlab-ce 上操作（尽管它们的操作方式应该一致）。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/systems/Linux/gitlab/gitlab-jh-%E5%92%8C-gitlab-ce-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E5%A3%B0%E6%98%8E/ itemprop=url class=post-title-link>gitlab-jh 和 gitlab-ce 的区别以及博客内容声明</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-04-22 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-04-22 00:00:00 +0800 CST">2024-04-22</time></span></div></div></header><div class=post-body itemprop=articleBody><p>Gitlab 极狐版本是极狐购买了经营权的版本，内部也分会员版。从免费版的功能来看，两者几乎没有区别。但是为了更严谨一些，本博客中所有内容都可能是在 gitlab-jh 或者 gitlab-ce 上试过（或者混用），不保证仅在 gitlab-ce 上操作（尽管它们的操作方式应该一致）。</p></div><footer class=post-footer><div readmore=false><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/systems/Linux/gitlab/gitlab-jh-%E5%92%8C-gitlab-ce-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E5%A3%B0%E6%98%8E/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/developer/vscode/VS-Code-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8-cuda-gdb-%E8%B0%83%E8%AF%95/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="VS Code 无法使用 cuda-gdb 调试"><meta itemprop=description content="创建 launch.json 的时候找不到 cuda-gdb 这个 type：需要安装 Nsight Visual Studio Code Edition：







"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/developer/vscode/VS-Code-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8-cuda-gdb-%E8%B0%83%E8%AF%95/ itemprop=url class=post-title-link>VS Code 无法使用 cuda-gdb 调试</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-04-22 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-04-22 00:00:00 +0800 CST">2024-04-22</time></span></div></div></header><div class=post-body itemprop=articleBody><p>创建 <code>launch.json</code> 的时候找不到 <code>cuda-gdb</code> 这个 type：需要安装 Nsight Visual Studio Code Edition：</p><p><img src=/assets/VS%20Code%20%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%20cuda-gdb%20%E8%B0%83%E8%AF%95-20240422190718604.webp></p></div><footer class=post-footer><div readmore=false><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/developer/vscode/VS-Code-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8-cuda-gdb-%E8%B0%83%E8%AF%95/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/systems/Linux/gitlab/%E5%9C%A8-Gitlab-%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="在 Gitlab 实例之间创建仓库镜像"><meta itemprop=description content="
  
      
      
    Important"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/systems/Linux/gitlab/%E5%9C%A8-Gitlab-%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F/ itemprop=url class=post-title-link>在 Gitlab 实例之间创建仓库镜像</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-04-22 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-04-22 00:00:00 +0800 CST">2024-04-22</time></span></div></div></header><div class=post-body itemprop=articleBody><div class="markdown-alert markdown-alert-important"><p class=markdown-alert-title><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784.0 1.75.0h12.5C15.216.0 16 .784 16 1.75v9.5A1.75 1.75.0 0114.25 13H8.06l-2.573 2.573A1.458 1.458.0 013 14.543V13H1.75A1.75 1.75.0 010 11.25zm1.75-.25a.25.25.0 00-.25.25v9.5c0 .138.112.25.25.25h2a.75.75.0 01.75.75v2.19l2.72-2.72a.749.749.0 01.53-.22h6.5a.25.25.0 00.25-.25v-9.5a.25.25.0 00-.25-.25zm7 2.25v2.5a.75.75.0 01-1.5.0v-2.5a.75.75.0 011.5.0zM9 9A1 1 0 117 9a1 1 0 012 0z"/></svg>Important</p><p><a href=/posts/systems/Linux/gitlab/gitlab-jh-%E5%92%8C-gitlab-ce-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E5%A3%B0%E6%98%8E/ title="gitlab-jh 和 gitlab-ce 的区别以及博客内容声明">gitlab-jh 和 gitlab-ce 的区别以及博客内容声明</a></p></div><h1 id=问题简述>问题简述
<a class=header-anchor href=#%e9%97%ae%e9%a2%98%e7%ae%80%e8%bf%b0></a></h1><p>主机 A 有自己的内网服务，用的是 Gitlab Premium。主机 B 也有自己的内网服务，用的是 Gitlab 极狐（而且是免费版）。目前仓库是在 B 上的，需要在 A 上创建镜像仓库。</p><h1 id=分析>分析
<a class=header-anchor href=#%e5%88%86%e6%9e%90></a></h1><p>由于主机 A 是付费服务支持功能更多，所以我选择由主机 A 主动拉取（Pull） B 的仓库。</p><h1 id=过程>过程
<a class=header-anchor href=#%e8%bf%87%e7%a8%8b></a></h1><p>首先在 A 上面创建空仓库，然后点进去选择 Settings > Repository > Mirroring repositories，在下面填入仓库的 URL。我们的主机 B 只把 http 端口映射出来了，也没有映射出来 ssh 端口，所以不能使用公钥验证，而只能选择密码验证，URL 的协议也只能是 http（我们仓库没做 https）。</p><p>注意以下几点（这三个坑我都踩过）：</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/systems/Linux/gitlab/%E5%9C%A8-Gitlab-%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/cli/docker/Docker-%E6%9B%B4%E6%94%B9%E5%9C%B0%E5%9D%80%E6%AE%B5/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Docker 更改地址段"><meta itemprop=description content='先说解决方案

参考 Networking problems with WSL2 and Docker Desktop for windows，编辑 /etc/docker/daemon.json，加入 "bip": "192.168.200.1/24"（根据实际情况替换），然后 systemctl 重载配置、重启 Docker 一通操作后用 ip route 和 ifconfig 验证一下变化。'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/cli/docker/Docker-%E6%9B%B4%E6%94%B9%E5%9C%B0%E5%9D%80%E6%AE%B5/ itemprop=url class=post-title-link>Docker 更改地址段</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-04-17 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-04-17 00:00:00 +0800 CST">2024-04-17
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-02-16T00:00:00+08:00 itemprop=dateModified datetime=2025-02-16T00:00:00+08:00>2025-02-16</time></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=先说解决方案>先说解决方案
<a class=header-anchor href=#%e5%85%88%e8%af%b4%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88></a></h1><p>参考 <a href=https://stackoverflow.com/a/73287366/ title="Networking problems with WSL2 and Docker Desktop for windows" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Networking problems with WSL2 and Docker Desktop for windows<i class="fa fa-external-link-alt"></i></a>，编辑 /etc/docker/daemon.json，加入 <code>"bip": "192.168.200.1/24"</code>（根据实际情况替换），然后 <code>systemctl</code> 重载配置、重启 Docker 一通操作后用 <code>ip route</code> 和 <code>ifconfig</code> 验证一下变化。</p><h1 id=为什么会有这个需求>为什么会有这个需求
<a class=header-anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e6%9c%89%e8%bf%99%e4%b8%aa%e9%9c%80%e6%b1%82></a></h1><p>WSL2 的网段是 172.17 开头的，这恰好和 Docker 的默认网段撞了，导致 Docker 不能直接使用 WSL2 的网关 ip 前缀的系统代理（会被认为是 Docker 内部的网址）。每次都要根据 Windows 实际的局域网 ip 来写 http 代理，太麻烦了。修改 Docker 网段之后就可以继续使用系统代理（虽然还是得传递，但是可以直接在命令行上写 <code>--build-arg HTTP_PROXY=$http_proxy --build-arg HTTPS_PROXY=$http_proxy</code> 之类）。另外，由于网络代理请求是统一从 WSL2 的网关发起的，只需要在 Clash for Windows 中设置 <code>inbounds</code> 就能仅允许这些连接请求，这样就不必冒着裸奔的风险开启局域网内代理了。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>inbounds</span>:
</span></span><span style=display:flex><span>  - <span style=color:#2aa198>&#34;http://172.17.xxx.yyy:zzz&#34;</span>
</span></span></code></pre></div><h1 id=相关文章>相关文章
<a class=header-anchor href=#%e7%9b%b8%e5%85%b3%e6%96%87%e7%ab%a0></a></h1><p><a href=/posts/systems/Windows/Clash-for-Windows-%E7%9B%B8%E5%85%B3/ title="Clash for Windows 相关">Clash for Windows 相关</a></p></div><footer class=post-footer><div readmore=false><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/cli/docker/Docker-%E6%9B%B4%E6%94%B9%E5%9C%B0%E5%9D%80%E6%AE%B5/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/cpp/libc++-%E5%92%8C-libstdc++-%E4%B8%AD-basic_string-%E7%9A%84-SSO-%E6%AF%94%E8%BE%83/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="libc++ 和 libstdc++ 中 basic_string 的 SSO 比较"><meta itemprop=description content="参考

https://joellaity.com/2020/01/31/string.html
std::string 是 std::basic_string<> 的一个特化，该类的 value_type 是 char。本文虽然是讨论 std::basic_string<> 的实现方式，但是为了方便，假设 value_type 是 char、假设目标平台是 64 位，讨论时也将把 std::basic_string<> 和 std::string 互用。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/programming/cpp/libc++-%E5%92%8C-libstdc++-%E4%B8%AD-basic_string-%E7%9A%84-SSO-%E6%AF%94%E8%BE%83/ itemprop=url class=post-title-link>libc++ 和 libstdc++ 中 basic_string 的 SSO 比较</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-04-13 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-04-13 00:00:00 +0800 CST">2024-04-13
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-03-05T00:00:00+08:00 itemprop=dateModified datetime=2025-03-05T00:00:00+08:00>2025-03-05</time></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=参考>参考
<a class=header-anchor href=#%e5%8f%82%e8%80%83></a></h1><p><a href=https://joellaity.com/2020/01/31/string.html title=https://joellaity.com/2020/01/31/string.html rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://joellaity.com/2020/01/31/string.html<i class="fa fa-external-link-alt"></i></a></p><p><code>std::string</code> 是 <code>std::basic_string&lt;></code> 的一个特化，该类的 <code>value_type</code> 是 char。本文虽然是讨论 <code>std::basic_string&lt;></code> 的实现方式，但是为了方便，<strong>假设 <code>value_type</code> 是 <code>char</code>、假设目标平台是 64 位</strong>，讨论时也将把 <code>std::basic_string&lt;></code> 和 <code>std::string</code> 互用。</p><h1 id=libstdc>libstdc++
<a class=header-anchor href=#libstdc></a></h1><p>libstdc++ 是 gcc 所用的标准库实现，也是 clang 在不提供 <code>-stdlib=...</code> 选项下的默认标准库实现。在 64 位环境下，libstdc++ 中的 <code>std::string</code> 占用 32 个字节。</p><div class="markdown-alert markdown-alert-tip"><p class=markdown-alert-title><svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363.0-4 1.69-4 3.75.0.984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75.0 01-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456.0 00-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863.0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751.0 01-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304.0-2.06-1.637-3.75-4-3.75zM5.75 12h4.5a.75.75.0 010 1.5h-4.5a.75.75.0 010-1.5zM6 15.25a.75.75.0 01.75-.75h2.5a.75.75.0 010 1.5h-2.5A.75.75.0 016 15.25z"/></svg>Tip</p><p><code>std::vector&lt;></code> 的大小（<code>std::vector&lt;bool></code> 有特化，所以是例外，在 <a href=https://godbolt.org/z/cKhn3za69 title=测试 rel="noopener external nofollow noreferrer" target=_blank class=exturl>测试<i class="fa fa-external-link-alt"></i></a> 看到 libstdc++ 和 libc++ 中 <code>std::vector&lt;bool></code> 的大小分别是 40 和 24 字节）是 24 字节，因为它也需要 capacity + size + pointer 三元组。</p></div><p><code>std::string</code> 把 capacity + size + pointer 三元组的 capacity 改成了 buffer 和 capacity 的联合体，其中 buffer 大小为 16 字节，可以容纳除去 <code>\0</code> 的 15 个字符。当 size 小于等于临界值时，联合体存储的就是 buffer，否则是 capacity。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/programming/cpp/libc++-%E5%92%8C-libstdc++-%E4%B8%AD-basic_string-%E7%9A%84-SSO-%E6%AF%94%E8%BE%83/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/collaboration/%E5%A6%82%E4%BD%95%E6%8F%90%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="如何提技术问题？"><meta itemprop=description content="我在做什么？

你想要最终达成什么（目标）？你采用了什么样的路径来达成它（途径）？

  
    
      
      
    Tip"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/collaboration/%E5%A6%82%E4%BD%95%E6%8F%90%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/ itemprop=url class=post-title-link>如何提技术问题？</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-04-10 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-04-10 00:00:00 +0800 CST">2024-04-10</time></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=我在做什么>我在做什么？
<a class=header-anchor href=#%e6%88%91%e5%9c%a8%e5%81%9a%e4%bb%80%e4%b9%88></a></h1><p>你想要最终达成什么（目标）？你采用了什么样的路径来达成它（途径）？</p><div class="markdown-alert markdown-alert-tip"><p class=markdown-alert-title><svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363.0-4 1.69-4 3.75.0.984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75.0 01-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456.0 00-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863.0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751.0 01-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304.0-2.06-1.637-3.75-4-3.75zM5.75 12h4.5a.75.75.0 010 1.5h-4.5a.75.75.0 010-1.5zM6 15.25a.75.75.0 01.75-.75h2.5a.75.75.0 010 1.5h-2.5A.75.75.0 016 15.25z"/></svg>Tip</p><p>有可能你的目标是不现实的，或者是假想出来的替代目标，换一个目标同样能解决你的困难，但是解决起来容易很多。也可能你的路径是有错误的。</p></div><p>例子：我希望调用接口 A 来加载目录 B 下的所有图片，供程序的其他组件使用。</p><h1 id=预期结果>预期结果
<a class=header-anchor href=#%e9%a2%84%e6%9c%9f%e7%bb%93%e6%9e%9c></a></h1><p>按照你的理解，你觉得代码或者软件配置应该引发什么行为？</p><p>例子：调用接口从目录下加载得到的图片数量和目录下的真实图片数量相等，有 14 张图片就应该得到 1 个长度为 14 的图片数据的向量。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/collaboration/%E5%A6%82%E4%BD%95%E6%8F%90%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/cli/docker/Docker-%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E6%BA%90/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Docker 配置镜像源"><meta itemprop=description content="资源

可用 Docker Hub 镜像加速器列表见 Docker Hub 镜像加速器。
修改方式

网络上有不少教程是先修改 /etc/docker/daemon.json，然后："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/cli/docker/Docker-%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E6%BA%90/ itemprop=url class=post-title-link>Docker 配置镜像源</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-04-09 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-04-09 00:00:00 +0800 CST">2024-04-09
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-06-08T00:00:00+08:00 itemprop=dateModified datetime=2024-06-08T00:00:00+08:00>2024-06-08</time></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=资源>资源
<a class=header-anchor href=#%e8%b5%84%e6%ba%90></a></h1><p>可用 Docker Hub 镜像加速器列表见 <a href=https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6 title="Docker Hub 镜像加速器" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Docker Hub 镜像加速器<i class="fa fa-external-link-alt"></i></a>。</p><h1 id=修改方式>修改方式
<a class=header-anchor href=#%e4%bf%ae%e6%94%b9%e6%96%b9%e5%bc%8f></a></h1><p>网络上有不少教程是先修改 /etc/docker/daemon.json，然后：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart docker
</span></span></code></pre></div><p>但是这样需要重启 Docker。虽然可以先给 Docker 加上 live-store 属性，但是我也不敢冒这个风险。</p><p>查了相关资料之后我发现：让 docker 重新加载配置只需要向其发送一个信号。如果是用 systemctl 管理 docker，可以直接这样做（参考<a href=https://cloud.tencent.com/developer/article/2220151 title=这篇文章 rel="noopener external nofollow noreferrer" target=_blank class=exturl>这篇文章<i class="fa fa-external-link-alt"></i></a>）：</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/cli/docker/Docker-%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E6%BA%90/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/cpp/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E6%80%A7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="language/implicit_conversion 限定性类型转换"><meta itemprop=description content="写在前面

内容见 implicit conversion。
限定性转换指的是和 cv 属性有关的类型转换，它的发生必须满足一定的条件。
相似类型

忽略掉各层的 cv 属性，如果两个类型形式相同，就是相似类型。比如 const int* volatile * 和 int** const。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/programming/cpp/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E6%80%A7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/ itemprop=url class=post-title-link>language/implicit_conversion 限定性类型转换</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-04-07 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-04-07 00:00:00 +0800 CST">2024-04-07
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-05-18T00:00:00+08:00 itemprop=dateModified datetime=2024-05-18T00:00:00+08:00>2024-05-18</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpp-language itemprop=url rel=index><span itemprop=name>cpp-language</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=写在前面>写在前面
<a class=header-anchor href=#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2></a></h1><p>内容见 <a href=https://en.cppreference.com/w/cpp/language/implicit_conversion title="implicit conversion" rel="noopener external nofollow noreferrer" target=_blank class=exturl>implicit conversion<i class="fa fa-external-link-alt"></i></a>。</p><p>限定性转换指的是和 cv 属性有关的类型转换，它的发生必须满足一定的条件。</p><h1 id=相似类型>相似类型
<a class=header-anchor href=#%e7%9b%b8%e4%bc%bc%e7%b1%bb%e5%9e%8b></a></h1><p>忽略掉各层的 cv 属性，如果两个类型形式相同，就是相似类型。比如 <code>const int* volatile *</code> 和 <code>int** const</code>。</p><div class="markdown-alert markdown-alert-important"><p class=markdown-alert-title><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784.0 1.75.0h12.5C15.216.0 16 .784 16 1.75v9.5A1.75 1.75.0 0114.25 13H8.06l-2.573 2.573A1.458 1.458.0 013 14.543V13H1.75A1.75 1.75.0 010 11.25zm1.75-.25a.25.25.0 00-.25.25v9.5c0 .138.112.25.25.25h2a.75.75.0 01.75.75v2.19l2.72-2.72a.749.749.0 01.53-.22h6.5a.25.25.0 00.25-.25v-9.5a.25.25.0 00-.25-.25zm7 2.25v2.5a.75.75.0 01-1.5.0v-2.5a.75.75.0 011.5.0zM9 9A1 1 0 117 9a1 1 0 012 0z"/></svg>Important</p><p>函数指针对应函数的<strong>参数</strong>和<strong>返回值</strong>类型的 cv 属性不可以忽略。可见原页面的例子，这里略去。</p></div><h1 id=限定性分解>限定性分解
<a class=header-anchor href=#%e9%99%90%e5%ae%9a%e6%80%a7%e5%88%86%e8%a7%a3></a></h1><p><img src=/assets/Pasted%20image%2020240407210300.webp></p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/programming/cpp/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E6%80%A7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/posts/page/10/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/posts/page/7/>7</a>
<a class=page-number href=/posts/page/8/>8</a>
<a class=page-number href=/posts/page/9/>9</a>
<a class=page-number href=/posts/page/10/>10</a>
<span class="page-number current">11</span>
<a class=page-number href=/posts/page/12/>12</a>
<a class=page-number href=/posts/page/13/>13</a>
<a class=page-number href=/posts/page/14/>14</a>
<a class=page-number href=/posts/page/15/>15</a>
<a class="extend next" rel=next href=/posts/page/12/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>