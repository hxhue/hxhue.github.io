<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Posts"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":false,"path":"posts","permalink":"https://hxhue.github.io/posts/","title":"Posts","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>posts - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/cli/bash/bash-%E6%9F%A5%E6%89%BE-malloc-%E5%92%8C-free-%E6%98%AF%E5%90%A6%E9%85%8D%E5%AF%B9/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="查找 malloc 和 free 是否配对"><meta itemprop=description content='说明

因为项目有老代码所以才需要这样处理，一般建议用 RAII 等技术避免裸露资源。
find_malloc.sh

要点：

用 gcc 去除代码注释。
用 awk 对正则表达式计数。

check() {
  gcc -fpreprocessed -dD -E -P "$1" 2>/dev/null | awk -v file="$1" &#39;
    BEGIN {
      malloc=0;
      free=0;
      queueCreate=0;
      queueDestroy=0;
      notifierCreate=0;
      notifierDestroy=0;
      handleCreate=0;
      handleDestroy=0;
    }
    /cnrtMalloc\(/          { malloc++; }
    /cnrtFree\(/            { free++; }
    /cnrtQueueCreate\(/     { queueCreate++; }
    /cnrtCreateQueue\(/     { queueCreate++; }
    /cnrtDestroyQueue\(/    { queueDestroy++; }
    /cnrtQueueDestroy\(/    { queueDestroy++; }
    /cnrtCreateNotifier\(/  { notifierCreate++; }
    /cnrtDestroyNotifier\(/ { notifierDestroy++; }
    /cnnlCreate\(/          { handleCreate++; }
    /cnnlDestroy\(/         { handleDestroy++; }
    END {
      if (malloc != free) {
        print "file: " file ", malloc: " malloc ", free: " free
      }
      if (queueCreate != queueDestroy) {
        print "file: " file ", queueCreate: " queueCreate ", queueDestroy: " queueDestroy
      }
      if (notifierCreate != notifierDestroy) {
        print "file: " file ", notifierCreate: " notifierCreate ", notifierDestroy: " notifierDestroy
      }
      if (handleCreate != handleDestroy) {
        print "file: " file ", handleCreate: " handleCreate ", handleDestroy: " handleDestroy
      }
    }&#39;
}

check $1
find_malloc_all.sh

要点：使用 find 匹配时应该选择正则表达式类型，同时和 Python 的 re 模块一样要全字符串匹配（不能匹配只部分字符，因此想只匹配中间部分的时候，就要在两边加上 .*）。'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/cli/bash/bash-%E6%9F%A5%E6%89%BE-malloc-%E5%92%8C-free-%E6%98%AF%E5%90%A6%E9%85%8D%E5%AF%B9/ itemprop=url class=post-title-link>查找 malloc 和 free 是否配对</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-27 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-27 00:00:00 +0800 CST">2024-08-27</time></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=说明>说明
<a class=header-anchor href=#%e8%af%b4%e6%98%8e></a></h1><p>因为项目有老代码所以才需要这样处理，一般建议用 RAII 等技术避免裸露资源。</p><h1 id=find_mallocsh>find_malloc.sh
<a class=header-anchor href=#find_mallocsh></a></h1><p>要点：</p><ol><li>用 gcc 去除代码注释。</li><li>用 awk 对正则表达式计数。</li></ol><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>check<span style=color:#719e07>()</span> <span style=color:#719e07>{</span>
</span></span><span style=display:flex><span>  gcc -fpreprocessed -dD -E -P <span style=color:#2aa198>&#34;</span><span style=color:#268bd2>$1</span><span style=color:#2aa198>&#34;</span> 2&gt;/dev/null | awk -v <span style=color:#268bd2>file</span><span style=color:#719e07>=</span><span style=color:#2aa198>&#34;</span><span style=color:#268bd2>$1</span><span style=color:#2aa198>&#34;</span> <span style=color:#2aa198>&#39;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    BEGIN {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      malloc=0;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      free=0;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      queueCreate=0;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      queueDestroy=0;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      notifierCreate=0;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      notifierDestroy=0;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      handleCreate=0;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      handleDestroy=0;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    /cnrtMalloc\(/          { malloc++; }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    /cnrtFree\(/            { free++; }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    /cnrtQueueCreate\(/     { queueCreate++; }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    /cnrtCreateQueue\(/     { queueCreate++; }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    /cnrtDestroyQueue\(/    { queueDestroy++; }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    /cnrtQueueDestroy\(/    { queueDestroy++; }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    /cnrtCreateNotifier\(/  { notifierCreate++; }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    /cnrtDestroyNotifier\(/ { notifierDestroy++; }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    /cnnlCreate\(/          { handleCreate++; }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    /cnnlDestroy\(/         { handleDestroy++; }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    END {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      if (malloc != free) {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        print &#34;file: &#34; file &#34;, malloc: &#34; malloc &#34;, free: &#34; free
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      if (queueCreate != queueDestroy) {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        print &#34;file: &#34; file &#34;, queueCreate: &#34; queueCreate &#34;, queueDestroy: &#34; queueDestroy
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      if (notifierCreate != notifierDestroy) {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        print &#34;file: &#34; file &#34;, notifierCreate: &#34; notifierCreate &#34;, notifierDestroy: &#34; notifierDestroy
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      if (handleCreate != handleDestroy) {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        print &#34;file: &#34; file &#34;, handleCreate: &#34; handleCreate &#34;, handleDestroy: &#34; handleDestroy
</span></span></span><span style=display:flex><span><span style=color:#2aa198>      }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    }&#39;</span>
</span></span><span style=display:flex><span><span style=color:#719e07>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>check <span style=color:#268bd2>$1</span>
</span></span></code></pre></div><h1 id=find_malloc_allsh>find_malloc_all.sh
<a class=header-anchor href=#find_malloc_allsh></a></h1><p>要点：使用 <code>find</code> 匹配时应该选择正则表达式类型，同时和 Python 的 <code>re</code> 模块一样要全字符串匹配（不能匹配只部分字符，因此想只匹配中间部分的时候，就要在两边加上 <code>.*</code>）。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/cli/bash/bash-%E6%9F%A5%E6%89%BE-malloc-%E5%92%8C-free-%E6%98%AF%E5%90%A6%E9%85%8D%E5%AF%B9/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/systems/Windows/%E6%8D%A2%E6%96%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%B9%8B%E5%90%8E-OneDrive-%E6%B2%A1%E6%9C%89%E6%8A%8A%E6%A1%8C%E9%9D%A2%E5%90%8C%E6%AD%A5%E8%BF%87%E6%9D%A5/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="换新笔记本之后 OneDrive 没有把桌面同步过来"><meta itemprop=description content="OneDrive 可以同步桌面，我以前的桌面是 C:\Users\xxx\OneDrive\Desktop，现在我的新电脑的桌面是 C:\Users\xxx\Desktop，虽然 OneDrive 仍然保存了之前的文件夹，但是没有对桌面进行同步。
解决方案是从文件资源管理器进入用户目录，然后右键桌面，选择位置 > 移动。点击移动之后桌面上面的文件就会被移动到新的路径（新路径的旧文件不会被删除，遇到同名文件会询问是否覆盖），随后新的路径会被设置为桌面。







"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/systems/Windows/%E6%8D%A2%E6%96%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%B9%8B%E5%90%8E-OneDrive-%E6%B2%A1%E6%9C%89%E6%8A%8A%E6%A1%8C%E9%9D%A2%E5%90%8C%E6%AD%A5%E8%BF%87%E6%9D%A5/ itemprop=url class=post-title-link>换新笔记本之后 OneDrive 没有把桌面同步过来</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-19 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-19 00:00:00 +0800 CST">2024-08-19
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-09-04T00:00:00+08:00 itemprop=dateModified datetime=2024-09-04T00:00:00+08:00>2024-09-04</time></span></div></div></header><div class=post-body itemprop=articleBody><p>OneDrive 可以同步桌面，我以前的桌面是 <code>C:\Users\xxx\OneDrive\Desktop</code>，现在我的新电脑的桌面是 <code>C:\Users\xxx\Desktop</code>，虽然 OneDrive 仍然保存了之前的文件夹，但是没有对桌面进行同步。</p><p>解决方案是从文件资源管理器进入用户目录，然后右键桌面，选择位置 > 移动。点击移动之后桌面上面的文件就会被移动到新的路径（新路径的旧文件不会被删除，遇到同名文件会询问是否覆盖），随后新的路径会被设置为桌面。</p><p><img src=/assets/Pasted%20image%2020240819140125.webp></p></div><footer class=post-footer><div readmore=false><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/systems/Windows/%E6%8D%A2%E6%96%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%B9%8B%E5%90%8E-OneDrive-%E6%B2%A1%E6%9C%89%E6%8A%8A%E6%A1%8C%E9%9D%A2%E5%90%8C%E6%AD%A5%E8%BF%87%E6%9D%A5/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/python/PyTorch-%E7%9A%84-CPU-%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-double-%E4%BD%9C%E4%B8%BA-32-%E4%BD%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B4%AF%E5%8A%A0%E7%B1%BB%E5%9E%8B/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="PyTorch 的 CPU 计算为什么使用 double 作为 32 位浮点数的累加类型？"><meta itemprop=description content="
  
    
      
      
    Tip
  本文没有得到最终结论，只是一些个人猜想。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/programming/python/PyTorch-%E7%9A%84-CPU-%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-double-%E4%BD%9C%E4%B8%BA-32-%E4%BD%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B4%AF%E5%8A%A0%E7%B1%BB%E5%9E%8B/ itemprop=url class=post-title-link>PyTorch 的 CPU 计算为什么使用 double 作为 32 位浮点数的累加类型？</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-10 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-10 00:00:00 +0800 CST">2024-08-10
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-08-27T00:00:00+08:00 itemprop=dateModified datetime=2024-08-27T00:00:00+08:00>2024-08-27</time></span></div></div></header><div class=post-body itemprop=articleBody><div class="markdown-alert markdown-alert-tip"><p class=markdown-alert-title><svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363.0-4 1.69-4 3.75.0.984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75.0 01-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456.0 00-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863.0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751.0 01-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304.0-2.06-1.637-3.75-4-3.75zM5.75 12h4.5a.75.75.0 010 1.5h-4.5a.75.75.0 010-1.5zM6 15.25a.75.75.0 01.75-.75h2.5a.75.75.0 010 1.5h-2.5A.75.75.0 016 15.25z"/></svg>Tip</p><p>本文没有得到最终结论，只是一些个人猜想。</p></div><p><a href=/posts/programming/cuda/CUDA-Kernel-%E5%B8%B8%E7%94%A8-float-%E7%B1%BB%E5%9E%8B%E8%BF%99%E4%BB%B6%E4%BA%8B/ title="CUDA Kernel 常用 float 类型这件事">CUDA Kernel 常用 float 类型这件事</a> 这篇笔记提到一个 issue 里面说 ATen 使用 double 作为 32 位浮点数的累加类型是因为用 float 会挂掉一个 batchnorm 的测试。这在我看来不可思议，因为 GPU 上面测试都没有挂，为什么 CPU 上面反而会挂呢？本文记录笔者看 batchnorm 的实现、试图找到原因的过程。</p><p>PyTorch 的 batchnorm 要对每一轮的输入计算均值和标准差，其中计算均值就需要将输入都加起来（再除以元素总数），这中间就可能产生累加误差。标准差的计算也类似，会有累加产生的误差。</p><p>从 aten/src/ATen/native/native_functions.yaml 中可以找到 <code>native_batch_norm()</code> 函数是在哪里实现的：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#268bd2>func</span>: native_batch_norm(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float momentum, float eps) -&gt; (Tensor, Tensor, Tensor)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>dispatch</span>:
</span></span><span style=display:flex><span>    <span style=color:#268bd2>CPU</span>: batch_norm_cpu
</span></span><span style=display:flex><span>    <span style=color:#268bd2>CUDA</span>: batch_norm_cuda
</span></span><span style=display:flex><span>    <span style=color:#268bd2>MPS</span>: batch_norm_mps
</span></span><span style=display:flex><span>    <span style=color:#268bd2>MkldnnCPU</span>: mkldnn_batch_norm
</span></span></code></pre></div></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/programming/python/PyTorch-%E7%9A%84-CPU-%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-double-%E4%BD%9C%E4%B8%BA-32-%E4%BD%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B4%AF%E5%8A%A0%E7%B1%BB%E5%9E%8B/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/cuda/CUDA-Kernel-%E5%B8%B8%E7%94%A8-float-%E7%B1%BB%E5%9E%8B%E8%BF%99%E4%BB%B6%E4%BA%8B/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CUDA Kernel 常用 float 类型这件事"><meta itemprop=description content="本文分别讨论双精度、单精度、半精度的浮点数计算，最后提及混合精度。在 CPU 方面，仅考虑 x86-64 CPU 和 GNU/Linux 上的 GCC 编译器；GPU 方面仅考虑 NVIDIA GPU。
GPU 上双精度计算慢在哪里？

https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions 以上链接说明：GPU 双精度浮点数运算比单精度浮点数慢，在有些架构（很多 $x.y~(y \ne 0)$ 运算能力的 GPU 都是游戏卡）上甚至慢得多。除了指令慢之外，double 类型也不利于 cache 和全局内存带宽。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/programming/cuda/CUDA-Kernel-%E5%B8%B8%E7%94%A8-float-%E7%B1%BB%E5%9E%8B%E8%BF%99%E4%BB%B6%E4%BA%8B/ itemprop=url class=post-title-link>CUDA Kernel 常用 float 类型这件事</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-09 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-09 00:00:00 +0800 CST">2024-08-09
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-03-28T00:00:00+08:00 itemprop=dateModified datetime=2025-03-28T00:00:00+08:00>2025-03-28</time></span></div></div></header><div class=post-body itemprop=articleBody><p>本文分别讨论双精度、单精度、半精度的浮点数计算，最后提及混合精度。在 CPU 方面，仅考虑 x86-64 CPU 和 GNU/Linux 上的 GCC 编译器；GPU 方面仅考虑 NVIDIA GPU。</p><h1 id=gpu-上双精度计算慢在哪里>GPU 上双精度计算慢在哪里？
<a class=header-anchor href=#gpu-%e4%b8%8a%e5%8f%8c%e7%b2%be%e5%ba%a6%e8%ae%a1%e7%ae%97%e6%85%a2%e5%9c%a8%e5%93%aa%e9%87%8c></a></h1><p><a href=https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions title=https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions<i class="fa fa-external-link-alt"></i></a> 以上链接说明：GPU 双精度浮点数运算比单精度浮点数慢，在有些架构（很多 $x.y~(y \ne 0)$ 运算能力的 GPU 都是游戏卡）上甚至慢得多。除了指令慢之外，double 类型也不利于 cache 和全局内存带宽。</p><p><a href=https://forums.developer.nvidia.com/t/use-float-rather-than-double-in-a-kernel/107363 title=https://forums.developer.nvidia.com/t/use-float-rather-than-double-in-a-kernel/107363 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://forums.developer.nvidia.com/t/use-float-rather-than-double-in-a-kernel/107363<i class="fa fa-external-link-alt"></i></a> <em>A 64 bit double variable takes 2 registers. A 32 bit float can be stored in 1 register.</em> 双精度浮点数的使用会增加单个 CUDA 线程对寄存器数量的需求，从而减少实际上同时可以运行的线程数。</p><h1 id=怎么正确使用单精度类型谨防隐式转换成双精度>怎么正确使用单精度类型？——谨防隐式转换成双精度
<a class=header-anchor href=#%e6%80%8e%e4%b9%88%e6%ad%a3%e7%a1%ae%e4%bd%bf%e7%94%a8%e5%8d%95%e7%b2%be%e5%ba%a6%e7%b1%bb%e5%9e%8b%e8%b0%a8%e9%98%b2%e9%9a%90%e5%bc%8f%e8%bd%ac%e6%8d%a2%e6%88%90%e5%8f%8c%e7%b2%be%e5%ba%a6></a></h1><p><em>CUDA 和 C/C++ 都不会先将 float 转 double 再计算，除非……</em></p><p><a href=https://godbolt.org/z/Me66bEeaa title=https://godbolt.org/z/Me66bEeaa rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://godbolt.org/z/Me66bEeaa<i class="fa fa-external-link-alt"></i></a> 我在本地尝试构造浮点数精度损失，但是无法构造出来，去 compiler explorer 一看发现实际上单精度浮点数被转换成了双精度浮点数计算。为什么呢？</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/programming/cuda/CUDA-Kernel-%E5%B8%B8%E7%94%A8-float-%E7%B1%BB%E5%9E%8B%E8%BF%99%E4%BB%B6%E4%BA%8B/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/cpp/%E8%A6%81%E5%B0%8F%E5%BF%83-C++-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="要小心 C++ 静态初始化顺序"><meta itemprop=description content="https://godbolt.org/z/n5bjMGcx3
编译器并不会自动根据代码的依赖关系去编排静态初始化顺序，示例代码中 vec 在被推入两个元素之后又被初始化了一次（在 compiler explorer 中看汇编也能看出来）。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/programming/cpp/%E8%A6%81%E5%B0%8F%E5%BF%83-C++-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/ itemprop=url class=post-title-link>要小心 C++ 静态初始化顺序</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-06 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-06 00:00:00 +0800 CST">2024-08-06</time></span></div></div></header><div class=post-body itemprop=articleBody><p><a href=https://godbolt.org/z/n5bjMGcx3 title=https://godbolt.org/z/n5bjMGcx3 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://godbolt.org/z/n5bjMGcx3<i class="fa fa-external-link-alt"></i></a></p><p>编译器并不会自动根据代码的依赖关系去编排静态初始化顺序，示例代码中 <code>vec</code> 在被推入两个元素之后又被初始化了一次（在 compiler explorer 中看汇编也能看出来）。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;iostream&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;vector&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#719e07>extern</span> std<span style=color:#719e07>::</span>vector<span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span><span style=color:#719e07>&gt;</span> vec;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>report_size</span>() {
</span></span><span style=display:flex><span>    printf(<span style=color:#2aa198>&#34;vec.size(): %zd</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, vec.size());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>auto</span> _1 <span style=color:#719e07>=</span> []() {
</span></span><span style=display:flex><span>    vec.push_back(<span style=color:#2aa198>0</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#2aa198>&#34;first  &#34;</span>);
</span></span><span style=display:flex><span>    report_size();
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
</span></span><span style=display:flex><span>}();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>auto</span> _2 <span style=color:#719e07>=</span> []() {
</span></span><span style=display:flex><span>    vec.push_back(<span style=color:#2aa198>0</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#2aa198>&#34;second &#34;</span>);
</span></span><span style=display:flex><span>    report_size();
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
</span></span><span style=display:flex><span>}();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#719e07>::</span>vector<span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span><span style=color:#719e07>&gt;</span> vec;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    printf(<span style=color:#2aa198>&#34;main   &#34;</span>);
</span></span><span style=display:flex><span>    report_size();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-txt data-lang=txt><span style=display:flex><span>first  vec.size(): 1
</span></span><span style=display:flex><span>second vec.size(): 2
</span></span><span style=display:flex><span>main   vec.size(): 0
</span></span></code></pre></div></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/programming/cpp/%E8%A6%81%E5%B0%8F%E5%BF%83-C++-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/python/torch-%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC%E5%92%8C%E6%B4%BE%E5%8F%91%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9C%A8%E5%93%AA%E9%87%8C/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="torch 自动求导的代码在哪里？"><meta itemprop=description content="2024 年 8 月 5 日：当前 torch 发布的版本是 2.4。PyTorch 的源码中还有几个 YAML 文件，这些文件都挺重要的，可以关注一下。
tools/autograd/derivatives.yaml 中有一些求导代码片段：
- name: prod.dim_int(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
  self: prod_backward(grad, self.to(grad.scalar_type()), result, dim, keepdim)
  result: (prod_backward(at::ones({}, result.options()).expand_as(result), self_p.to(result.scalar_type()), result, dim, keepdim) * self_t.conj()).sum(dim, keepdim).conj()

- name: put(Tensor self, Tensor index, Tensor source, bool accumulate=False) -> Tensor
  self: &#34;accumulate ? grad : grad.put(index, zeros_like(source), false)&#34;
  index: non_differentiable
  source: grad.take(index).reshape_as(source)
  result: self_t.put(index, source_t, accumulate)

- name: linalg_qr(Tensor A, str mode='reduced') -> (Tensor Q, Tensor R)
  A: linalg_qr_backward(grad_Q, grad_R, Q, R, mode)
  Q, R: linalg_qr_jvp(A_t, Q, R, mode)

- name: rad2deg(Tensor self) -> Tensor
  self: rad2deg_backward(grad)
  result: auto_element_wise

- name: random_.from(Tensor(a!) self, int from, int? to, *, Generator? generator=None) -> Tensor(a!)
  self: zeros_like(grad)
  result: self_t.zero_()

- name: random_.to(Tensor(a!) self, int to, *, Generator? generator=None) -> Tensor(a!)
  self: zeros_like(grad)
  result: self_t.zero_()
看起来 name 是近似于 python 的伪代码，其他的都是 C++ 代码？"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/programming/python/torch-%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC%E5%92%8C%E6%B4%BE%E5%8F%91%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9C%A8%E5%93%AA%E9%87%8C/ itemprop=url class=post-title-link>torch 自动求导的代码在哪里？</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-08-05 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-08-05 00:00:00 +0800 CST">2024-08-05
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-08-10T00:00:00+08:00 itemprop=dateModified datetime=2024-08-10T00:00:00+08:00>2024-08-10</time></span></div></div></header><div class=post-body itemprop=articleBody><p>2024 年 8 月 5 日：当前 torch 发布的版本是 2.4。PyTorch 的源码中还有几个 YAML 文件，这些文件都挺重要的，可以关注一下。</p><p>tools/autograd/derivatives.yaml 中有一些求导代码片段：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#268bd2>name</span>: prod.dim_int(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None) -&gt; Tensor
</span></span><span style=display:flex><span>  <span style=color:#268bd2>self</span>: prod_backward(grad, self.to(grad.scalar_type()), result, dim, keepdim)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>result</span>: (prod_backward(at::ones({}, result.options()).expand_as(result), self_p.to(result.scalar_type()), result, dim, keepdim) * self_t.conj()).sum(dim, keepdim).conj()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#268bd2>name</span>: put(Tensor self, Tensor index, Tensor source, bool accumulate=False) -&gt; Tensor
</span></span><span style=display:flex><span>  <span style=color:#268bd2>self</span>: <span style=color:#2aa198>&#34;accumulate ? grad : grad.put(index, zeros_like(source), false)&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>index</span>: non_differentiable
</span></span><span style=display:flex><span>  <span style=color:#268bd2>source</span>: grad.take(index).reshape_as(source)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>result</span>: self_t.put(index, source_t, accumulate)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#268bd2>name</span>: linalg_qr(Tensor A, str mode=&#39;reduced&#39;) -&gt; (Tensor Q, Tensor R)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>A</span>: linalg_qr_backward(grad_Q, grad_R, Q, R, mode)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>Q, R</span>: linalg_qr_jvp(A_t, Q, R, mode)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#268bd2>name</span>: rad2deg(Tensor self) -&gt; Tensor
</span></span><span style=display:flex><span>  <span style=color:#268bd2>self</span>: rad2deg_backward(grad)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>result</span>: auto_element_wise
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#268bd2>name</span>: random_.from(Tensor(a!) self, int from, int? to, *, Generator? generator=None) -&gt; Tensor(a!)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>self</span>: zeros_like(grad)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>result</span>: self_t.zero_()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#268bd2>name</span>: random_.to(Tensor(a!) self, int to, *, Generator? generator=None) -&gt; Tensor(a!)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>self</span>: zeros_like(grad)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>result</span>: self_t.zero_()
</span></span></code></pre></div><p>看起来 <code>name</code> 是近似于 python 的伪代码，其他的都是 C++ 代码？</p><p>aten/src/ATen/native/native_functions.yaml 这个文件中有 native 函数在不同平台上的派发，比如：</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/programming/python/torch-%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC%E5%92%8C%E6%B4%BE%E5%8F%91%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9C%A8%E5%93%AA%E9%87%8C/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/cpp/%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="私有化构造函数"><meta itemprop=description content="有的时候我们希望私有化构造函数，然后要求用户只通过工厂方法访问我们的类型，在 
  
  
    
    
    
    
    
    
    
    
    
    
    
    std::enable_shared_from_this 的例子 中就有使用。这个例子是从 cppreference 上面抄来的。但是今天我发现去年 11 月有人修改了网页上的例子，修订记录为 https://en.cppreference.com/mwiki/index.php?title=cpp%2Fmemory%2Fenable_shared_from_this&diff=162885&oldid=153414 。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/programming/cpp/%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/ itemprop=url class=post-title-link>私有化构造函数</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-07-22 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-07-22 00:00:00 +0800 CST">2024-07-22</time></span></div></div></header><div class=post-body itemprop=articleBody><p>有的时候我们希望私有化构造函数，然后要求用户只通过工厂方法访问我们的类型，在
<a href=/cpp-templates-the-complete-guide/21-Templates-and-Inheritance/#std-enable_shared_from_this title="std::enable_shared_from_this 的例子"><code>std::enable_shared_from_this</code> 的例子</a> 中就有使用。这个例子是从 cppreference 上面抄来的。但是今天我发现去年 11 月有人修改了网页上的例子，修订记录为 <a href="https://en.cppreference.com/mwiki/index.php?title=cpp%2Fmemory%2Fenable_shared_from_this&amp;diff=162885&amp;oldid=153414" title="https://en.cppreference.com/mwiki/index.php?title=cpp%2Fmemory%2Fenable_shared_from_this&diff=162885&oldid=153414" rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://en.cppreference.com/mwiki/index.php?title=cpp%2Fmemory%2Fenable_shared_from_this&diff=162885&oldid=153414<i class="fa fa-external-link-alt"></i></a> 。</p><p>后来这个例子又有了<a href=https://en.cppreference.com/w/Talk:Main_Page/suggestions#enabled_shared_from_this_Private title=新的修订 rel="noopener external nofollow noreferrer" target=_blank class=exturl>新的修订<i class="fa fa-external-link-alt"></i></a>，现在这个例子是：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>Best</span> <span style=color:#719e07>:</span> <span style=color:#719e07>public</span> std<span style=color:#719e07>::</span>enable_shared_from_this<span style=color:#719e07>&lt;</span>Best<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#719e07>struct</span> <span style=color:#268bd2>Private</span>{ <span style=color:#719e07>explicit</span> <span style=color:#268bd2>Private</span>() <span style=color:#719e07>=</span> <span style=color:#719e07>default</span>; }; <span style=color:#586e75>// 这个 explicit 构造函数非常重要
</span></span></span><span style=display:flex><span><span style=color:#586e75></span> 
</span></span><span style=display:flex><span><span style=color:#719e07>public</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// Constructor is only usable by this class
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    Best(Private) {}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#586e75>// Everyone else has to use this factory function
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#586e75>// Hence all Best objects will be contained in shared_ptr
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>static</span> std<span style=color:#719e07>::</span>shared_ptr<span style=color:#719e07>&lt;</span>Best<span style=color:#719e07>&gt;</span> create()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> std<span style=color:#719e07>::</span>make_shared<span style=color:#719e07>&lt;</span>Best<span style=color:#719e07>&gt;</span>(Private());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>shared_ptr<span style=color:#719e07>&lt;</span>Best<span style=color:#719e07>&gt;</span> getptr()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> <span style=color:#268bd2>shared_from_this</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>构造函数不再私有，调用者能明确看到需要一个私有的标记类，从而对 API 的使用方式会更加清楚。</p><p>尤其是 <code>Private</code> 类中的 <code>explicit Private() = default;</code> 非常重要，如果没有这个，使用者可以通过避免明确书写 <code>Private</code> 类型而构造出 <code>Private</code> 类型的对象！这是非常危险的。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/programming/cpp/%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/cpp/GNU-%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95%E5%B8%A6%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A4%9A%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="GNU 扩展语法：带有返回值的多语句表达式"><meta itemprop=description content="https://godbolt.org/z/vo195MYGj
int main() {
    return ({
        1;
    });
}
以上代码返回 1。在花括号中写多条语句都没关系。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/programming/cpp/GNU-%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95%E5%B8%A6%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A4%9A%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F/ itemprop=url class=post-title-link>GNU 扩展语法：带有返回值的多语句表达式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-07-13 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-07-13 00:00:00 +0800 CST">2024-07-13
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-02-28T00:00:00+08:00 itemprop=dateModified datetime=2025-02-28T00:00:00+08:00>2025-02-28</time></span></div></div></header><div class=post-body itemprop=articleBody><p><a href=https://godbolt.org/z/vo195MYGj title=https://godbolt.org/z/vo195MYGj rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://godbolt.org/z/vo195MYGj<i class="fa fa-external-link-alt"></i></a></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> ({
</span></span><span style=display:flex><span>        <span style=color:#2aa198>1</span>;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上代码返回 1。在花括号中写多条语句都没关系。</p></div><footer class=post-footer><div readmore=false><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/programming/cpp/GNU-%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95%E5%B8%A6%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A4%9A%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/python/torch-%E5%88%86%E5%B8%83%E5%BC%8F%E7%A8%8B%E5%BA%8F%E4%BA%A7%E7%94%9F%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="torch 分布式程序产生僵尸进程"><meta itemprop=description content="聊天记录：

  A
torch 的分布式程序在一些异常结束的情况下会留下一些僵尸进程
我之前经常是这样
你 kill 掉主进程子进程不会被回收
B
为什么没有会回收？因为父进程没死且没有被回收，难道父进程不是 torch 的主进程，而是整个容器里面的一个活跃进程？
不在容器里使用是否不会出现这种情况？
如果父进程死了，应该由 init 回收
是否是因为容器的起始进程不是 init"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/programming/python/torch-%E5%88%86%E5%B8%83%E5%BC%8F%E7%A8%8B%E5%BA%8F%E4%BA%A7%E7%94%9F%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/ itemprop=url class=post-title-link>torch 分布式程序产生僵尸进程</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-07-08 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-07-08 00:00:00 +0800 CST">2024-07-08
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2025-04-21T00:00:00+08:00 itemprop=dateModified datetime=2025-04-21T00:00:00+08:00>2025-04-21</time></span></div></div></header><div class=post-body itemprop=articleBody><p>聊天记录：</p><blockquote><p>A
torch 的分布式程序在一些异常结束的情况下会留下一些僵尸进程
我之前经常是这样
你 kill 掉主进程子进程不会被回收</p><p>B
为什么没有会回收？因为父进程没死且没有被回收，难道父进程不是 torch 的主进程，而是整个容器里面的一个活跃进程？
不在容器里使用是否不会出现这种情况？
如果父进程死了，应该由 init 回收
是否是因为容器的起始进程不是 init</p><p>A
不知道</p><p>B
是在容器中吗</p><p>A
不是</p></blockquote><p>关联：</p><ul><li><a href=/posts/systems/Linux/NVIDIA-%E6%98%BE%E5%8D%A1%E6%98%BE%E5%AD%98%E5%8D%A0%E7%94%A8%E9%AB%98%E4%BD%86%E6%98%AF-nvidia-smi-%E6%9F%A5%E4%B8%8D%E5%88%B0/ title="NVIDIA 显卡显存占用高但是 nvidia-smi 查不到">NVIDIA 显卡显存占用高但是 nvidia-smi 查不到</a></li><li><a href=/posts/systems/Linux/%E9%AA%8C%E8%AF%81%E7%88%B6%E8%BF%9B%E7%A8%8B%E8%A2%AB%E6%9D%80%E6%AD%BB%E5%90%8E%E5%83%B5%E5%B0%B8%E4%BC%9A%E8%A2%AB-init-%E8%BF%9B%E7%A8%8B%E6%94%B6%E5%85%BB/ title="验证父进程被杀死后僵尸会被 init 进程收养">验证父进程被杀死后僵尸会被 init 进程收养</a></li><li><a href=/posts/programming/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%84%9A%E6%9C%AC%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/ title="Python 多进程脚本的常见问题">Python 多进程脚本的常见问题</a></li><li><a href=/the-linux-programming-interface/26-%E7%9B%91%E6%8E%A7%E5%AD%90%E8%BF%9B%E7%A8%8B-wait/ title="26 监控子进程 wait()">26 监控子进程 <code>wait()</code></a></li></ul><p>论坛帖子 <a href=https://discuss.pytorch.org/t/pytorch-doesnt-free-gpus-memory-of-it-gets-aborted-due-to-out-of-memory-error/13775/14 title="PyTorch doesn&rsquo;t free GPU&rsquo;s memory of it gets aborted due to out-of-memory error - PyTorch Forums" rel="noopener external nofollow noreferrer" target=_blank class=exturl>PyTorch doesn&rsquo;t free GPU&rsquo;s memory of it gets aborted due to out-of-memory error - PyTorch Forums<i class="fa fa-external-link-alt"></i></a> 有 PyTorch 开发者回答是 Python 的 multiprocessing 模块有 bug，可能会导致僵尸进程。</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/programming/python/torch-%E5%88%86%E5%B8%83%E5%BC%8F%E7%A8%8B%E5%BA%8F%E4%BA%A7%E7%94%9F%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/cli/cmake/%E5%AF%B9-CMake-%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B-CMAKE_BUILD_TYPE-%E7%9A%84%E8%80%83%E9%87%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="对 CMake 构建类型 CMAKE_BUILD_TYPE 的考量"><meta itemprop=description content="参考

https://stackoverflow.com/a/59314670/
https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html 的解释：

  Specifies the build type on single-configuration generators (e.g. Makefile Generators or Ninja). Typical values include Debug, Release, RelWithDebInfo and MinSizeRel, but custom build types can also be defined.
Stack Overflow 回答里提到的 BetaTest 等其他构建类型应该就是上面所说的 custom build types."></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/posts/cli/cmake/%E5%AF%B9-CMake-%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B-CMAKE_BUILD_TYPE-%E7%9A%84%E8%80%83%E9%87%8F/ itemprop=url class=post-title-link>对 CMake 构建类型 CMAKE_BUILD_TYPE 的考量</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-07-07 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-07-07 00:00:00 +0800 CST">2024-07-07</time></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=参考>参考
<a class=header-anchor href=#%e5%8f%82%e8%80%83></a></h1><p><a href=https://stackoverflow.com/a/59314670/ title=https://stackoverflow.com/a/59314670/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://stackoverflow.com/a/59314670/<i class="fa fa-external-link-alt"></i></a></p><p><a href=https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html title=https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html<i class="fa fa-external-link-alt"></i></a> 的解释：</p><blockquote><p>Specifies the build type on single-configuration generators (e.g. <a href=https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html#makefile-generators title="Makefile Generators" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Makefile Generators<i class="fa fa-external-link-alt"></i></a> or <a href=https://cmake.org/cmake/help/latest/generator/Ninja.html#generator:Ninja title=Ninja rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>Ninja</code><i class="fa fa-external-link-alt"></i></a>). Typical values include <code>Debug</code>, <code>Release</code>, <code>RelWithDebInfo</code> and <code>MinSizeRel</code>, but custom build types can also be defined.</p></blockquote><p>Stack Overflow 回答里提到的 BetaTest 等其他构建类型应该就是上面所说的 <em>custom build types</em>.</p><h1 id=在尽可能复现错误的情况下调试>在尽可能复现错误的情况下调试
<a class=header-anchor href=#%e5%9c%a8%e5%b0%bd%e5%8f%af%e8%83%bd%e5%a4%8d%e7%8e%b0%e9%94%99%e8%af%af%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b%e8%b0%83%e8%af%95></a></h1><h2 id=使用-relwithdebinfo>使用 RelWithDebInfo？
<a class=header-anchor href=#%e4%bd%bf%e7%94%a8-relwithdebinfo></a></h2><p>考虑编译器 gcc 或者 clang：</p></div><footer class=post-footer><div readmore=true><div class=readmore-overlay><div class=readmore-overlay-center><div class=post-button><a class=btn href=/posts/cli/cmake/%E5%AF%B9-CMake-%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B-CMAKE_BUILD_TYPE-%E7%9A%84%E8%80%83%E9%87%8F/#more rel=contents>阅读全文 &#187;</a></div></div></div><div class=no-more-to-read><hr><center>没有啦~</center></div></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/posts/page/7/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/posts/page/4/>4</a>
<a class=page-number href=/posts/page/5/>5</a>
<a class=page-number href=/posts/page/6/>6</a>
<a class=page-number href=/posts/page/7/>7</a>
<span class="page-number current">8</span>
<a class=page-number href=/posts/page/9/>9</a>
<a class=page-number href=/posts/page/10/>10</a>
<a class=page-number href=/posts/page/11/>11</a>
<a class=page-number href=/posts/page/12/>12</a>
<a class="extend next" rel=next href=/posts/page/9/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>