<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.143.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Strict Aliasing"><meta itemprop=description content="个人博客，主要是零散的笔记。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hxhue.github.io/imgs/371907.jpg"><meta itemprop=keywords content="cpp"><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.bea76f574a755574e17d42bea39502a74ca3ca4db65807b8c82d3e26dcec8420.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><link rel=stylesheet type=text/css href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/github-markdown-css@5.3.0/github-markdown-dark.css><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.mermaidAPI.initialize();
  window.mermaid = mermaid;
</script><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"Strict-Aliasing","permalink":"https://hxhue.github.io/posts/programming/cpp/Strict-Aliasing/","title":"Strict Aliasing","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Strict Aliasing - Bluegill</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Bluegill</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-hashtag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-daily"><a href=/daily/ class=hvr-icon-pulse rel=section><i class="fa fa-newspaper hvr-icon"></i>随笔</a></li><li class="menu-item menu-item-discovery"><a href=https://rift-fear-f2c.notion.site/2025-1e354a33cfb1802c841bdf29f2f3dab3 class=hvr-icon-pulse rel=section><i class="fa fa-compass hvr-icon"></i>发现</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#什么时候-aliasing-是允许的>什么时候 Aliasing 是允许的？</a></li><li><a href=#c-语言的-restrict-关键字>C 语言的 restrict 关键字</a></li><li><a href=#type-punning>Type Punning</a></li><li><a href=#common-initial-sequence>Common initial Sequence</a></li><li><a href=#c-stdlaunder>C++ <code>std::launder</code></a></li><li><a href=#回到最开始的例子>回到最开始的例子</a></li><li><a href=#总结>总结</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=🤖 src=/imgs/371907.jpg><p class=site-author-name itemprop=name>🤖</p><div class=site-description itemprop=description>个人博客，主要是零散的笔记。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>433</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>86</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hxhue title="Github → https://github.com/hxhue" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github
</a></span><span class=links-of-social-item><a href=/rss.xml title="RSS 订阅 → /rss.xml" rel=noopener target=_blank><i class="fa fa-rss fa-fw"></i>
RSS 订阅</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://shuai.guru/ title=https://shuai.guru/ target=_blank>shuai.guru</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hxhue.github.io/posts/programming/cpp/Strict-Aliasing/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/371907.jpg"><meta itemprop=name content="🤖"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="🤖"><meta itemprop=description content="个人博客，主要是零散的笔记。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Strict Aliasing"><meta itemprop=description content="文章：What is Strict Aliasing and Why do we Care? (github.com)
所谓 Strict Aliasing 就是指为 aliasing 设定条件，使得编译器大多数场景下认为代码没有 aliasing，从而可以激进优化代码。"></span><header class=post-header><h1 class=post-title itemprop="name headline">Strict Aliasing</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-08-12 00:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-12 00:00:00 +0800 CST">2023-08-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-04-08T00:00:00+08:00 itemprop=dateModified datetime=2024-04-08T00:00:00+08:00>2024-04-08</time></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>1989</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>4分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><p>文章：<a href=https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8 title="What is Strict Aliasing and Why do we Care? (github.com)" rel="noopener external nofollow noreferrer" target=_blank class=exturl>What is Strict Aliasing and Why do we Care? (github.com)<i class="fa fa-external-link-alt"></i></a></p><p>所谓 Strict Aliasing 就是指为 aliasing 设定条件，使得编译器大多数场景下认为代码没有 aliasing，从而可以激进优化代码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;iostream&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>foo</span>( <span style=color:#dc322f>float</span> <span style=color:#719e07>*</span>f, <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>i ) {
</span></span><span style=display:flex><span>    <span style=color:#719e07>*</span>i <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#719e07>*</span>f <span style=color:#719e07>=</span> <span style=color:#2aa198>0.f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#719e07>return</span> <span style=color:#719e07>*</span>i;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>int</span> x <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> x <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#34;</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>;   <span style=color:#586e75>// Expect 0
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    x <span style=color:#719e07>=</span> foo(<span style=color:#719e07>reinterpret_cast</span><span style=color:#719e07>&lt;</span><span style=color:#dc322f>float</span><span style=color:#719e07>*&gt;</span>(<span style=color:#719e07>&amp;</span>x), <span style=color:#719e07>&amp;</span>x);
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> x <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#34;</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>;   <span style=color:#586e75>// Expect 0?
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>上述代码在 <code>gcc 13.1 -O2</code> 下编译，第二行打印结果为 1。编译器认为 f 和 i 指针必定不重合，所以直接返回了 1。</p><h1 id=什么时候-aliasing-是允许的>什么时候 Aliasing 是允许的？
<a class=header-anchor href=#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99-aliasing-%e6%98%af%e5%85%81%e8%ae%b8%e7%9a%84></a></h1><p>比较复杂，而且 C 和 C++ 的要求不同。在 alias 可用时，编译器不会像上面那样激进优化。下面只提到了一部分规则。</p><p><strong>允许同类指针</strong>，而且两者都允许给指针加 cv 限定，但是 C++17 还允许 unsigned 和 signed 对应类型之间的别名，C11 不允许（尽管 gcc 和 clang 都是按照允许的方式实现的）。</p><p>最基本的保证是：无论指针如何变化，只要目的类型是对象的真实类型，就能正常使用。但是如何开启一个新对象的生命周期则有区别。<strong>C 语言中只要写入就已经可以按照写入类型启用一个新的生命周期。而在 C++ 必须保存用于写入的指针并在之后始终使用该指针！（C++17 新增了</strong> <code>std::launder</code><strong>，可以不必再保存指针但是要洗一下）</strong></p><p><img src=/assets/b7cb646b10cbc680cd7416f06f677cf2.webp></p><blockquote><p>问题：保存 memcpy 返回的指针可以吗？</p></blockquote><h1 id=c-语言的-restrict-关键字>C 语言的 restrict 关键字
<a class=header-anchor href=#c-%e8%af%ad%e8%a8%80%e7%9a%84-restrict-%e5%85%b3%e9%94%ae%e5%ad%97></a></h1><p><a href=https://stackoverflow.com/a/30827311/ title=https://stackoverflow.com/a/30827311/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://stackoverflow.com/a/30827311/<i class="fa fa-external-link-alt"></i></a></p><p>restrict 关键字是指针的属性，写在指针的右侧、变量名之前，它保证了一个指针和其他指针变量没有重叠（没有 aliasing），以便编译器在 aliasing 可用时仍激进优化（<strong>可以理解为优化同类指针，但实际上是兼容类型的都可以</strong>）。</p><h1 id=type-punning>Type Punning
<a class=header-anchor href=#type-punning></a></h1><p>把一种类型当成另一种来使用，即存 A 取 B。</p><p><strong>文章提出：安全无误的 type punning 可以用</strong> <code>memcpy</code><strong>。</strong></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>func1</span>( <span style=color:#dc322f>double</span> d ) {
</span></span><span style=display:flex><span>  std<span style=color:#719e07>::</span><span style=color:#dc322f>int64_t</span> n;
</span></span><span style=display:flex><span>  std<span style=color:#719e07>::</span>memcpy(<span style=color:#719e07>&amp;</span>n, <span style=color:#719e07>&amp;</span>d, <span style=color:#719e07>sizeof</span> d);
</span></span><span style=display:flex><span>  <span style=color:#586e75>//...
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>在这种比较简单的赋值场景下，只要没有用 <code>-fno-builtin</code> 禁止内置函数优化，<code>memcpy</code> 调用就能直接被优化掉，对于主流编译器来说即便是 <code>-O0</code> 也是如此！</p><p>memcpy 复制了值，不再使用指针，从而不受限于 aliasing 规则。</p><p>在访问目标的 alignment 和 size 都相同时，我认为 type punning 的不安全之处还是在于<strong>通过转换后指针对目标的修改，对于使用转换前指针的读可以是不可见的</strong>。复制值后当然就只能读不能写了。最开始的代码要是返回的是从 f 强转成 <code>int *</code> 之后再读取的，也不会出现这种情况。</p><blockquote><p>C++ <code>std::launder</code> 本来应该是应对上面加粗字体说明的情况的，但是我在对局部变量使用时没有成功。</p><p>2023 年 6 月 30 日：对于 A 类型的指针，强制转换为 B 类型后 launder，才能和其他 B 类型指针发生 aliasing 关系。（相容类型也可以 alias）</p></blockquote><p>下面是对非聚合类使用 memcpy：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;cstdio&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;cstring&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;cassert&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;vector&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#719e07>static_assert</span>(<span style=color:#719e07>sizeof</span>(std<span style=color:#719e07>::</span>vector<span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span><span style=color:#719e07>&gt;</span>) <span style=color:#719e07>==</span> <span style=color:#2aa198>24</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>vector<span style=color:#719e07>&lt;</span><span style=color:#dc322f>int</span><span style=color:#719e07>&gt;</span> v{<span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span>};
</span></span><span style=display:flex><span>    <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> buf[<span style=color:#719e07>sizeof</span>(v) <span style=color:#719e07>/</span> <span style=color:#719e07>sizeof</span>(<span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span>)];
</span></span><span style=display:flex><span>    memcpy(buf, <span style=color:#719e07>&amp;</span>v, <span style=color:#719e07>sizeof</span>(v));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printf(<span style=color:#2aa198>&#34;%lld %lld %lld</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, buf[<span style=color:#2aa198>0</span>], buf[<span style=color:#2aa198>1</span>], buf[<span style=color:#2aa198>2</span>]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://godbolt.org/z/zM4cY1b5n title=https://godbolt.org/z/zM4cY1b5n rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://godbolt.org/z/zM4cY1b5n<i class="fa fa-external-link-alt"></i></a></p><p>尽管在 <code>-O0</code> 时显式调用了 <code>memcpy</code>，但是 <code>-O1</code> 时就能内联成简单复制。</p><blockquote><p>如果不想复制怎么办？这种做法对于大对象合适吗？</p></blockquote><p>C++ 20 有 <code>std::bit_cast</code>，是对这种特殊情况下 std::memcpy 的替代方案。也是值语义复制，而且要求目的类型和参数类型所占空间一致，而且两种类型都是 <code>trivially copyable</code> 的。</p><h1 id=common-initial-sequence>Common initial Sequence
<a class=header-anchor href=#common-initial-sequence></a></h1><blockquote><p>It says that we are allowed to read the non-static data member of the non-active member if it is part of the common initial sequence of the the structs [class.mem.general]p26.</p></blockquote><p>看上去这条规则没有什么用，但是：</p><blockquote><p>It Is likely the common initial sequence rule was put in place to allow discriminated union without having the discriminator outside the the union and therefore likely have padding between the discriminator and the union itself e.g.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>union</span> { <span style=color:#719e07>struct</span> { <span style=color:#dc322f>char</span> kind; ... } a; <span style=color:#719e07>struct</span> { <span style=color:#dc322f>char</span> kind; ... } b; ... };
</span></span></code></pre></div><p>根据文章，这可能使得我们可以在 union 中利用 padding 存储 index，以提供 discriminated union 的功能。</p><h1 id=c-stdlaunder>C++ <code>std::launder</code>
<a class=header-anchor href=#c-stdlaunder></a></h1><p><code>std::launder</code> 有什么用呢？表面含义是洗，也就是让指针的来源难以追溯，目的是<strong>抑制非同类指针的激进优化</strong>。但实际上 <code>std::launder</code> 的作用还是非常局限的，因为它的使用有一些必须满足的条件（<strong>其中就包含指针的类型必须和其真实类型对应，以及不能传入 void 指针和函数指针</strong>）。</p><p><a href=https://en.cppreference.com/w/cpp/utility/launder title="std::launder - cppreference.com" rel="noopener external nofollow noreferrer" target=_blank class=exturl>std::launder - cppreference.com<i class="fa fa-external-link-alt"></i></a></p><p><img src=/assets/b706c07f3b79287bcabc594362b1e5c2.webp></p><p>典型的用法是用 placement new 在一块字符数组上面创建对象，然后用 <code>std::launder</code> 洗字符数组的首元素指针。</p><p>如果不这样做，按照 strict aliasing 的规则，也可以保存 placement new 的返回值到一个变量，然后每次都利用这个变量做操作。</p><p><a href=https://stackoverflow.com/a/63003406 title=https://stackoverflow.com/a/63003406 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://stackoverflow.com/a/63003406<i class="fa fa-external-link-alt"></i></a></p><p><img src=/assets/f012dc7d5ba56e6a5a1549e0a3b67b81.webp></p><ol><li>初始化，u.x 被激活。</li><li>赋值，u.f 被激活，u.x 失活。</li><li>placement new 不会激活子对象！</li><li>通过保存的指针返回不会有问题。</li><li>虽然是访问失活的元素，但是洗了指针。</li><li>直接访问失活元素，UB。</li></ol><h1 id=回到最开始的例子>回到最开始的例子
<a class=header-anchor href=#%e5%9b%9e%e5%88%b0%e6%9c%80%e5%bc%80%e5%a7%8b%e7%9a%84%e4%be%8b%e5%ad%90></a></h1><p>这一部分实际上都没洗成功。</p><p>将第一个部分的 C++ 代码改造如下：</p><p><a href=https://godbolt.org/z/ME4PTa74b title=https://godbolt.org/z/ME4PTa74b rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://godbolt.org/z/ME4PTa74b<i class="fa fa-external-link-alt"></i></a></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;iostream&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;new&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>foo</span>( <span style=color:#dc322f>float</span> <span style=color:#719e07>*</span>f, <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>i ) {
</span></span><span style=display:flex><span>    <span style=color:#719e07>*</span>i <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#719e07>*</span>f <span style=color:#719e07>=</span> <span style=color:#2aa198>0.f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#719e07>return</span> <span style=color:#719e07>*</span>std<span style=color:#719e07>::</span>launder(i);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>int</span> x <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> x <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#34;</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>;   <span style=color:#586e75>// Expect 0
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    x <span style=color:#719e07>=</span> foo(<span style=color:#719e07>reinterpret_cast</span><span style=color:#719e07>&lt;</span><span style=color:#dc322f>float</span> <span style=color:#719e07>*&gt;</span>(<span style=color:#719e07>&amp;</span>x), <span style=color:#719e07>&amp;</span>x);
</span></span><span style=display:flex><span>    std<span style=color:#719e07>::</span>cout <span style=color:#719e07>&lt;&lt;</span> x <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>&#34;</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>;   <span style=color:#586e75>// Expect 0?
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>没有洗成功。编译器预先假设了 f 和 i 无关，这样洗还是它还是觉得返回值只和 i 有关。想要 f 的结果被编译器看到，则必须让返回值和 f 建立起来联系。实际上，在 cppreference 对 <code>std::launder</code> 的用法说明中上面的例子就不满足条件，因为对象的真实类型是 float（<code>*f = 0.f)</code>，而要使用的类型却是 int。</p><p>还可以在中间穿插对其他 volatile 变量的访问（会禁止指令重排）。也可以直接用 volatile 访问目标数据。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;string.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>foo</span>( <span style=color:#dc322f>float</span> <span style=color:#719e07>*</span>f, <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>i ) {
</span></span><span style=display:flex><span>    <span style=color:#719e07>*</span>i <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#719e07>*</span>f <span style=color:#719e07>=</span> <span style=color:#2aa198>0.f</span>;
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> <span style=color:#719e07>*</span>(<span style=color:#dc322f>int</span> <span style=color:#719e07>volatile</span> <span style=color:#719e07>*</span>)i;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>int</span> x <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printf(<span style=color:#2aa198>&#34;%d</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, x);   <span style=color:#586e75>// Expect 0
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    x <span style=color:#719e07>=</span> foo((<span style=color:#dc322f>float</span> <span style=color:#719e07>*</span>)(<span style=color:#719e07>&amp;</span>x), <span style=color:#719e07>&amp;</span>x);
</span></span><span style=display:flex><span>    printf(<span style=color:#2aa198>&#34;%d</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, x);   <span style=color:#586e75>// Yes, it&#39;s 0
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>每次用 volatile 访存显然是 overkill，观察汇编得知比开启 <code>-fno-strict-aliasing</code> 生成的代码稍差。</p><h1 id=总结>总结
<a class=header-anchor href=#%e6%80%bb%e7%bb%93></a></h1><p>避免 strict aliasing violation 的方法：</p><ol><li>用 <code>memcpy</code> 或 <code>std::bit_cast</code> 复制数据。</li><li>禁用编译器的 strict aliasing 功能。</li><li>保存函数或操作符的返回值 并在其上操作，或者在 placement new 之后洗指针。</li></ol><blockquote><p>“保存函数或操作符的返回值”：这样后续操作就对返回值产生了依赖性，不需要洗指针。</p><p>The Linux kernel is compiled with <code>-fno-strict-aliasing</code>. Linus justifies this in <a href=https://www.mail-archive.com/linux-btrfs@vger.kernel.org/msg01647.html title=https://www.mail-archive.com/linux-btrfs@vger.kernel.org/msg01647.html rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://www.mail-archive.com/linux-btrfs@vger.kernel.org/msg01647.html<i class="fa fa-external-link-alt"></i></a> .</p></blockquote></div><footer class=post-footer><div class=post-tags><a href=/tags/cpp>cpp</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/posts/programming/cpp/std-lower_bound-upper_bound/ rel=next title=std::lower_bound/upper_bound><i class="fa fa-chevron-left"></i> std::lower_bound/upper_bound</a></div><div class="post-nav-prev post-nav-item"><a href=/posts/programming/cpp/Three-way-Comparison/ rel=prev title="Three-way Comparison =">Three-way Comparison =
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>🤖</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.143.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://hxhue.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","menu_item":"fadeInDown","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"cdnjs","router":"https://cdnjs.cloudflare.com/ajax/libs"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.37ba8b54f9d4d784d08028c45eea93b5d4e13eda8ee7fb0d2edd6f3fac66cfd2.js defer></script></body></html>